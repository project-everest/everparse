(*
 Autogenerated by Thrift Compiler (0.22.0)

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
module Type = 
struct
  type t = 
    | BOOLEAN
    | INT32
    | INT64
    | INT96
    | FLOAT
    | DOUBLE
    | BYTE_ARRAY
    | FIXED_LEN_BYTE_ARRAY
  let to_i = function
    | BOOLEAN -> 0l
    | INT32 -> 1l
    | INT64 -> 2l
    | INT96 -> 3l
    | FLOAT -> 4l
    | DOUBLE -> 5l
    | BYTE_ARRAY -> 6l
    | FIXED_LEN_BYTE_ARRAY -> 7l
  let of_i = function
    | 0l -> BOOLEAN
    | 1l -> INT32
    | 2l -> INT64
    | 3l -> INT96
    | 4l -> FLOAT
    | 5l -> DOUBLE
    | 6l -> BYTE_ARRAY
    | 7l -> FIXED_LEN_BYTE_ARRAY
    | _ -> raise Thrift_error
end
module ConvertedType = 
struct
  type t = 
    | UTF8
    | MAP
    | MAP_KEY_VALUE
    | LIST
    | ENUM
    | DECIMAL
    | DATE
    | TIME_MILLIS
    | TIME_MICROS
    | TIMESTAMP_MILLIS
    | TIMESTAMP_MICROS
    | UINT_8
    | UINT_16
    | UINT_32
    | UINT_64
    | INT_8
    | INT_16
    | INT_32
    | INT_64
    | JSON
    | BSON
    | INTERVAL
  let to_i = function
    | UTF8 -> 0l
    | MAP -> 1l
    | MAP_KEY_VALUE -> 2l
    | LIST -> 3l
    | ENUM -> 4l
    | DECIMAL -> 5l
    | DATE -> 6l
    | TIME_MILLIS -> 7l
    | TIME_MICROS -> 8l
    | TIMESTAMP_MILLIS -> 9l
    | TIMESTAMP_MICROS -> 10l
    | UINT_8 -> 11l
    | UINT_16 -> 12l
    | UINT_32 -> 13l
    | UINT_64 -> 14l
    | INT_8 -> 15l
    | INT_16 -> 16l
    | INT_32 -> 17l
    | INT_64 -> 18l
    | JSON -> 19l
    | BSON -> 20l
    | INTERVAL -> 21l
  let of_i = function
    | 0l -> UTF8
    | 1l -> MAP
    | 2l -> MAP_KEY_VALUE
    | 3l -> LIST
    | 4l -> ENUM
    | 5l -> DECIMAL
    | 6l -> DATE
    | 7l -> TIME_MILLIS
    | 8l -> TIME_MICROS
    | 9l -> TIMESTAMP_MILLIS
    | 10l -> TIMESTAMP_MICROS
    | 11l -> UINT_8
    | 12l -> UINT_16
    | 13l -> UINT_32
    | 14l -> UINT_64
    | 15l -> INT_8
    | 16l -> INT_16
    | 17l -> INT_32
    | 18l -> INT_64
    | 19l -> JSON
    | 20l -> BSON
    | 21l -> INTERVAL
    | _ -> raise Thrift_error
end
module FieldRepetitionType = 
struct
  type t = 
    | REQUIRED
    | OPTIONAL
    | REPEATED
  let to_i = function
    | REQUIRED -> 0l
    | OPTIONAL -> 1l
    | REPEATED -> 2l
  let of_i = function
    | 0l -> REQUIRED
    | 1l -> OPTIONAL
    | 2l -> REPEATED
    | _ -> raise Thrift_error
end
module EdgeInterpolationAlgorithm = 
struct
  type t = 
    | SPHERICAL
    | VINCENTY
    | THOMAS
    | ANDOYER
    | KARNEY
  let to_i = function
    | SPHERICAL -> 0l
    | VINCENTY -> 1l
    | THOMAS -> 2l
    | ANDOYER -> 3l
    | KARNEY -> 4l
  let of_i = function
    | 0l -> SPHERICAL
    | 1l -> VINCENTY
    | 2l -> THOMAS
    | 3l -> ANDOYER
    | 4l -> KARNEY
    | _ -> raise Thrift_error
end
module Encoding = 
struct
  type t = 
    | PLAIN
    | PLAIN_DICTIONARY
    | RLE
    | BIT_PACKED
    | DELTA_BINARY_PACKED
    | DELTA_LENGTH_BYTE_ARRAY
    | DELTA_BYTE_ARRAY
    | RLE_DICTIONARY
    | BYTE_STREAM_SPLIT
  let to_i = function
    | PLAIN -> 0l
    | PLAIN_DICTIONARY -> 2l
    | RLE -> 3l
    | BIT_PACKED -> 4l
    | DELTA_BINARY_PACKED -> 5l
    | DELTA_LENGTH_BYTE_ARRAY -> 6l
    | DELTA_BYTE_ARRAY -> 7l
    | RLE_DICTIONARY -> 8l
    | BYTE_STREAM_SPLIT -> 9l
  let of_i = function
    | 0l -> PLAIN
    | 2l -> PLAIN_DICTIONARY
    | 3l -> RLE
    | 4l -> BIT_PACKED
    | 5l -> DELTA_BINARY_PACKED
    | 6l -> DELTA_LENGTH_BYTE_ARRAY
    | 7l -> DELTA_BYTE_ARRAY
    | 8l -> RLE_DICTIONARY
    | 9l -> BYTE_STREAM_SPLIT
    | _ -> raise Thrift_error
end
module CompressionCodec = 
struct
  type t = 
    | UNCOMPRESSED
    | SNAPPY
    | GZIP
    | LZO
    | BROTLI
    | LZ4
    | ZSTD
    | LZ4_RAW
  let to_i = function
    | UNCOMPRESSED -> 0l
    | SNAPPY -> 1l
    | GZIP -> 2l
    | LZO -> 3l
    | BROTLI -> 4l
    | LZ4 -> 5l
    | ZSTD -> 6l
    | LZ4_RAW -> 7l
  let of_i = function
    | 0l -> UNCOMPRESSED
    | 1l -> SNAPPY
    | 2l -> GZIP
    | 3l -> LZO
    | 4l -> BROTLI
    | 5l -> LZ4
    | 6l -> ZSTD
    | 7l -> LZ4_RAW
    | _ -> raise Thrift_error
end
module PageType = 
struct
  type t = 
    | DATA_PAGE
    | INDEX_PAGE
    | DICTIONARY_PAGE
    | DATA_PAGE_V2
  let to_i = function
    | DATA_PAGE -> 0l
    | INDEX_PAGE -> 1l
    | DICTIONARY_PAGE -> 2l
    | DATA_PAGE_V2 -> 3l
  let of_i = function
    | 0l -> DATA_PAGE
    | 1l -> INDEX_PAGE
    | 2l -> DICTIONARY_PAGE
    | 3l -> DATA_PAGE_V2
    | _ -> raise Thrift_error
end
module BoundaryOrder = 
struct
  type t = 
    | UNORDERED
    | ASCENDING
    | DESCENDING
  let to_i = function
    | UNORDERED -> 0l
    | ASCENDING -> 1l
    | DESCENDING -> 2l
  let of_i = function
    | 0l -> UNORDERED
    | 1l -> ASCENDING
    | 2l -> DESCENDING
    | _ -> raise Thrift_error
end
class sizeStatistics =
object (self)
  val mutable _unencoded_byte_array_data_bytes : Int64.t option = None
  method get_unencoded_byte_array_data_bytes = _unencoded_byte_array_data_bytes
  method grab_unencoded_byte_array_data_bytes = match _unencoded_byte_array_data_bytes with None->raise (Field_empty "sizeStatistics.unencoded_byte_array_data_bytes") | Some _x0 -> _x0
  method set_unencoded_byte_array_data_bytes _x0 = _unencoded_byte_array_data_bytes <- Some _x0
  method unset_unencoded_byte_array_data_bytes = _unencoded_byte_array_data_bytes <- None
  method reset_unencoded_byte_array_data_bytes = _unencoded_byte_array_data_bytes <- None

  val mutable _repetition_level_histogram : Int64.t list option = None
  method get_repetition_level_histogram = _repetition_level_histogram
  method grab_repetition_level_histogram = match _repetition_level_histogram with None->raise (Field_empty "sizeStatistics.repetition_level_histogram") | Some _x1 -> _x1
  method set_repetition_level_histogram _x1 = _repetition_level_histogram <- Some _x1
  method unset_repetition_level_histogram = _repetition_level_histogram <- None
  method reset_repetition_level_histogram = _repetition_level_histogram <- None

  val mutable _definition_level_histogram : Int64.t list option = None
  method get_definition_level_histogram = _definition_level_histogram
  method grab_definition_level_histogram = match _definition_level_histogram with None->raise (Field_empty "sizeStatistics.definition_level_histogram") | Some _x2 -> _x2
  method set_definition_level_histogram _x2 = _definition_level_histogram <- Some _x2
  method unset_definition_level_histogram = _definition_level_histogram <- None
  method reset_definition_level_histogram = _definition_level_histogram <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SizeStatistics";
    (match _unencoded_byte_array_data_bytes with None -> () | Some _v -> 
      oprot#writeFieldBegin("unencoded_byte_array_data_bytes",Protocol.T_I64,1);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _repetition_level_histogram with None -> () | Some _v -> 
      oprot#writeFieldBegin("repetition_level_histogram",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_I64,List.length _v);
      List.iter (fun _iter5 ->         oprot#writeI64(_iter5);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _definition_level_histogram with None -> () | Some _v -> 
      oprot#writeFieldBegin("definition_level_histogram",Protocol.T_LIST,3);
      oprot#writeListBegin(Protocol.T_I64,List.length _v);
      List.iter (fun _iter6 ->         oprot#writeI64(_iter6);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_sizeStatistics (iprot : Protocol.t) =
  let _str7 = new sizeStatistics in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t8,_id9) = iprot#readFieldBegin in
        if _t8 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id9 with 
          | 1 -> (if _t8 = Protocol.T_I64 then
              _str7#set_unencoded_byte_array_data_bytes iprot#readI64
            else
              iprot#skip _t8)
          | 2 -> (if _t8 = Protocol.T_LIST then
              _str7#set_repetition_level_histogram 
                (let (_etype13,_size10) = iprot#readListBegin in
                  let _con14 = (Array.to_list (Array.init _size10 (fun _ -> iprot#readI64))) in
                    iprot#readListEnd; _con14)
            else
              iprot#skip _t8)
          | 3 -> (if _t8 = Protocol.T_LIST then
              _str7#set_definition_level_histogram 
                (let (_etype18,_size15) = iprot#readListBegin in
                  let _con19 = (Array.to_list (Array.init _size15 (fun _ -> iprot#readI64))) in
                    iprot#readListEnd; _con19)
            else
              iprot#skip _t8)
          | _ -> iprot#skip _t8);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str7

class boundingBox =
object (self)
  val mutable _xmin : float option = None
  method get_xmin = _xmin
  method grab_xmin = match _xmin with None->raise (Field_empty "boundingBox.xmin") | Some _x21 -> _x21
  method set_xmin _x21 = _xmin <- Some _x21
  method unset_xmin = _xmin <- None
  method reset_xmin = _xmin <- None

  val mutable _xmax : float option = None
  method get_xmax = _xmax
  method grab_xmax = match _xmax with None->raise (Field_empty "boundingBox.xmax") | Some _x22 -> _x22
  method set_xmax _x22 = _xmax <- Some _x22
  method unset_xmax = _xmax <- None
  method reset_xmax = _xmax <- None

  val mutable _ymin : float option = None
  method get_ymin = _ymin
  method grab_ymin = match _ymin with None->raise (Field_empty "boundingBox.ymin") | Some _x23 -> _x23
  method set_ymin _x23 = _ymin <- Some _x23
  method unset_ymin = _ymin <- None
  method reset_ymin = _ymin <- None

  val mutable _ymax : float option = None
  method get_ymax = _ymax
  method grab_ymax = match _ymax with None->raise (Field_empty "boundingBox.ymax") | Some _x24 -> _x24
  method set_ymax _x24 = _ymax <- Some _x24
  method unset_ymax = _ymax <- None
  method reset_ymax = _ymax <- None

  val mutable _zmin : float option = None
  method get_zmin = _zmin
  method grab_zmin = match _zmin with None->raise (Field_empty "boundingBox.zmin") | Some _x25 -> _x25
  method set_zmin _x25 = _zmin <- Some _x25
  method unset_zmin = _zmin <- None
  method reset_zmin = _zmin <- None

  val mutable _zmax : float option = None
  method get_zmax = _zmax
  method grab_zmax = match _zmax with None->raise (Field_empty "boundingBox.zmax") | Some _x26 -> _x26
  method set_zmax _x26 = _zmax <- Some _x26
  method unset_zmax = _zmax <- None
  method reset_zmax = _zmax <- None

  val mutable _mmin : float option = None
  method get_mmin = _mmin
  method grab_mmin = match _mmin with None->raise (Field_empty "boundingBox.mmin") | Some _x27 -> _x27
  method set_mmin _x27 = _mmin <- Some _x27
  method unset_mmin = _mmin <- None
  method reset_mmin = _mmin <- None

  val mutable _mmax : float option = None
  method get_mmax = _mmax
  method grab_mmax = match _mmax with None->raise (Field_empty "boundingBox.mmax") | Some _x28 -> _x28
  method set_mmax _x28 = _mmax <- Some _x28
  method unset_mmax = _mmax <- None
  method reset_mmax = _mmax <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "BoundingBox";
    (match _xmin with 
    | None -> raise (Field_empty "boundingBox._xmin")
    | Some _v -> 
      oprot#writeFieldBegin("xmin",Protocol.T_DOUBLE,1);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _xmax with 
    | None -> raise (Field_empty "boundingBox._xmax")
    | Some _v -> 
      oprot#writeFieldBegin("xmax",Protocol.T_DOUBLE,2);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _ymin with 
    | None -> raise (Field_empty "boundingBox._ymin")
    | Some _v -> 
      oprot#writeFieldBegin("ymin",Protocol.T_DOUBLE,3);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _ymax with 
    | None -> raise (Field_empty "boundingBox._ymax")
    | Some _v -> 
      oprot#writeFieldBegin("ymax",Protocol.T_DOUBLE,4);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _zmin with None -> () | Some _v -> 
      oprot#writeFieldBegin("zmin",Protocol.T_DOUBLE,5);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _zmax with None -> () | Some _v -> 
      oprot#writeFieldBegin("zmax",Protocol.T_DOUBLE,6);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _mmin with None -> () | Some _v -> 
      oprot#writeFieldBegin("mmin",Protocol.T_DOUBLE,7);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _mmax with None -> () | Some _v -> 
      oprot#writeFieldBegin("mmax",Protocol.T_DOUBLE,8);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_boundingBox (iprot : Protocol.t) =
  let _str31 = new boundingBox in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t32,_id33) = iprot#readFieldBegin in
        if _t32 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id33 with 
          | 1 -> (if _t32 = Protocol.T_DOUBLE then
              _str31#set_xmin iprot#readDouble
            else
              iprot#skip _t32)
          | 2 -> (if _t32 = Protocol.T_DOUBLE then
              _str31#set_xmax iprot#readDouble
            else
              iprot#skip _t32)
          | 3 -> (if _t32 = Protocol.T_DOUBLE then
              _str31#set_ymin iprot#readDouble
            else
              iprot#skip _t32)
          | 4 -> (if _t32 = Protocol.T_DOUBLE then
              _str31#set_ymax iprot#readDouble
            else
              iprot#skip _t32)
          | 5 -> (if _t32 = Protocol.T_DOUBLE then
              _str31#set_zmin iprot#readDouble
            else
              iprot#skip _t32)
          | 6 -> (if _t32 = Protocol.T_DOUBLE then
              _str31#set_zmax iprot#readDouble
            else
              iprot#skip _t32)
          | 7 -> (if _t32 = Protocol.T_DOUBLE then
              _str31#set_mmin iprot#readDouble
            else
              iprot#skip _t32)
          | 8 -> (if _t32 = Protocol.T_DOUBLE then
              _str31#set_mmax iprot#readDouble
            else
              iprot#skip _t32)
          | _ -> iprot#skip _t32);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str31

class geospatialStatistics =
object (self)
  val mutable _bbox : boundingBox option = None
  method get_bbox = _bbox
  method grab_bbox = match _bbox with None->raise (Field_empty "geospatialStatistics.bbox") | Some _x35 -> _x35
  method set_bbox _x35 = _bbox <- Some _x35
  method unset_bbox = _bbox <- None
  method reset_bbox = _bbox <- None

  val mutable _geospatial_types : Int32.t list option = None
  method get_geospatial_types = _geospatial_types
  method grab_geospatial_types = match _geospatial_types with None->raise (Field_empty "geospatialStatistics.geospatial_types") | Some _x36 -> _x36
  method set_geospatial_types _x36 = _geospatial_types <- Some _x36
  method unset_geospatial_types = _geospatial_types <- None
  method reset_geospatial_types = _geospatial_types <- None

  method copy =
      let _new = Oo.copy self in
      if _bbox <> None then
        _new#set_bbox self#grab_bbox#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "GeospatialStatistics";
    (match _bbox with None -> () | Some _v -> 
      oprot#writeFieldBegin("bbox",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _geospatial_types with None -> () | Some _v -> 
      oprot#writeFieldBegin("geospatial_types",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_I32,List.length _v);
      List.iter (fun _iter39 ->         oprot#writeI32(_iter39);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_geospatialStatistics (iprot : Protocol.t) =
  let _str40 = new geospatialStatistics in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t41,_id42) = iprot#readFieldBegin in
        if _t41 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id42 with 
          | 1 -> (if _t41 = Protocol.T_STRUCT then
              _str40#set_bbox (read_boundingBox iprot)
            else
              iprot#skip _t41)
          | 2 -> (if _t41 = Protocol.T_LIST then
              _str40#set_geospatial_types 
                (let (_etype46,_size43) = iprot#readListBegin in
                  let _con47 = (Array.to_list (Array.init _size43 (fun _ -> iprot#readI32))) in
                    iprot#readListEnd; _con47)
            else
              iprot#skip _t41)
          | _ -> iprot#skip _t41);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str40

class statistics =
object (self)
  val mutable _max : string option = None
  method get_max = _max
  method grab_max = match _max with None->raise (Field_empty "statistics.max") | Some _x49 -> _x49
  method set_max _x49 = _max <- Some _x49
  method unset_max = _max <- None
  method reset_max = _max <- None

  val mutable _min : string option = None
  method get_min = _min
  method grab_min = match _min with None->raise (Field_empty "statistics.min") | Some _x50 -> _x50
  method set_min _x50 = _min <- Some _x50
  method unset_min = _min <- None
  method reset_min = _min <- None

  val mutable _null_count : Int64.t option = None
  method get_null_count = _null_count
  method grab_null_count = match _null_count with None->raise (Field_empty "statistics.null_count") | Some _x51 -> _x51
  method set_null_count _x51 = _null_count <- Some _x51
  method unset_null_count = _null_count <- None
  method reset_null_count = _null_count <- None

  val mutable _distinct_count : Int64.t option = None
  method get_distinct_count = _distinct_count
  method grab_distinct_count = match _distinct_count with None->raise (Field_empty "statistics.distinct_count") | Some _x52 -> _x52
  method set_distinct_count _x52 = _distinct_count <- Some _x52
  method unset_distinct_count = _distinct_count <- None
  method reset_distinct_count = _distinct_count <- None

  val mutable _max_value : string option = None
  method get_max_value = _max_value
  method grab_max_value = match _max_value with None->raise (Field_empty "statistics.max_value") | Some _x53 -> _x53
  method set_max_value _x53 = _max_value <- Some _x53
  method unset_max_value = _max_value <- None
  method reset_max_value = _max_value <- None

  val mutable _min_value : string option = None
  method get_min_value = _min_value
  method grab_min_value = match _min_value with None->raise (Field_empty "statistics.min_value") | Some _x54 -> _x54
  method set_min_value _x54 = _min_value <- Some _x54
  method unset_min_value = _min_value <- None
  method reset_min_value = _min_value <- None

  val mutable _is_max_value_exact : bool option = None
  method get_is_max_value_exact = _is_max_value_exact
  method grab_is_max_value_exact = match _is_max_value_exact with None->raise (Field_empty "statistics.is_max_value_exact") | Some _x55 -> _x55
  method set_is_max_value_exact _x55 = _is_max_value_exact <- Some _x55
  method unset_is_max_value_exact = _is_max_value_exact <- None
  method reset_is_max_value_exact = _is_max_value_exact <- None

  val mutable _is_min_value_exact : bool option = None
  method get_is_min_value_exact = _is_min_value_exact
  method grab_is_min_value_exact = match _is_min_value_exact with None->raise (Field_empty "statistics.is_min_value_exact") | Some _x56 -> _x56
  method set_is_min_value_exact _x56 = _is_min_value_exact <- Some _x56
  method unset_is_min_value_exact = _is_min_value_exact <- None
  method reset_is_min_value_exact = _is_min_value_exact <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Statistics";
    (match _max with None -> () | Some _v -> 
      oprot#writeFieldBegin("max",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _min with None -> () | Some _v -> 
      oprot#writeFieldBegin("min",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _null_count with None -> () | Some _v -> 
      oprot#writeFieldBegin("null_count",Protocol.T_I64,3);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _distinct_count with None -> () | Some _v -> 
      oprot#writeFieldBegin("distinct_count",Protocol.T_I64,4);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _max_value with None -> () | Some _v -> 
      oprot#writeFieldBegin("max_value",Protocol.T_STRING,5);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _min_value with None -> () | Some _v -> 
      oprot#writeFieldBegin("min_value",Protocol.T_STRING,6);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _is_max_value_exact with None -> () | Some _v -> 
      oprot#writeFieldBegin("is_max_value_exact",Protocol.T_BOOL,7);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    (match _is_min_value_exact with None -> () | Some _v -> 
      oprot#writeFieldBegin("is_min_value_exact",Protocol.T_BOOL,8);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_statistics (iprot : Protocol.t) =
  let _str59 = new statistics in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t60,_id61) = iprot#readFieldBegin in
        if _t60 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id61 with 
          | 1 -> (if _t60 = Protocol.T_STRING then
              _str59#set_max iprot#readString
            else
              iprot#skip _t60)
          | 2 -> (if _t60 = Protocol.T_STRING then
              _str59#set_min iprot#readString
            else
              iprot#skip _t60)
          | 3 -> (if _t60 = Protocol.T_I64 then
              _str59#set_null_count iprot#readI64
            else
              iprot#skip _t60)
          | 4 -> (if _t60 = Protocol.T_I64 then
              _str59#set_distinct_count iprot#readI64
            else
              iprot#skip _t60)
          | 5 -> (if _t60 = Protocol.T_STRING then
              _str59#set_max_value iprot#readString
            else
              iprot#skip _t60)
          | 6 -> (if _t60 = Protocol.T_STRING then
              _str59#set_min_value iprot#readString
            else
              iprot#skip _t60)
          | 7 -> (if _t60 = Protocol.T_BOOL then
              _str59#set_is_max_value_exact iprot#readBool
            else
              iprot#skip _t60)
          | 8 -> (if _t60 = Protocol.T_BOOL then
              _str59#set_is_min_value_exact iprot#readBool
            else
              iprot#skip _t60)
          | _ -> iprot#skip _t60);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str59

class stringType =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "StringType";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_stringType (iprot : Protocol.t) =
  let _str65 = new stringType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t66,_id67) = iprot#readFieldBegin in
        if _t66 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id67 with 
          | _ -> iprot#skip _t66);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str65

class uUIDType =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "UUIDType";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_uUIDType (iprot : Protocol.t) =
  let _str71 = new uUIDType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t72,_id73) = iprot#readFieldBegin in
        if _t72 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id73 with 
          | _ -> iprot#skip _t72);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str71

class mapType =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "MapType";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_mapType (iprot : Protocol.t) =
  let _str77 = new mapType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t78,_id79) = iprot#readFieldBegin in
        if _t78 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id79 with 
          | _ -> iprot#skip _t78);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str77

class listType =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ListType";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_listType (iprot : Protocol.t) =
  let _str83 = new listType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t84,_id85) = iprot#readFieldBegin in
        if _t84 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id85 with 
          | _ -> iprot#skip _t84);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str83

class enumType =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "EnumType";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_enumType (iprot : Protocol.t) =
  let _str89 = new enumType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t90,_id91) = iprot#readFieldBegin in
        if _t90 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id91 with 
          | _ -> iprot#skip _t90);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str89

class dateType =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "DateType";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_dateType (iprot : Protocol.t) =
  let _str95 = new dateType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t96,_id97) = iprot#readFieldBegin in
        if _t96 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id97 with 
          | _ -> iprot#skip _t96);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str95

class float16Type =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Float16Type";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_float16Type (iprot : Protocol.t) =
  let _str101 = new float16Type in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t102,_id103) = iprot#readFieldBegin in
        if _t102 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id103 with 
          | _ -> iprot#skip _t102);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str101

class nullType =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "NullType";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_nullType (iprot : Protocol.t) =
  let _str107 = new nullType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t108,_id109) = iprot#readFieldBegin in
        if _t108 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id109 with 
          | _ -> iprot#skip _t108);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str107

class decimalType =
object (self)
  val mutable _scale : Int32.t option = None
  method get_scale = _scale
  method grab_scale = match _scale with None->raise (Field_empty "decimalType.scale") | Some _x111 -> _x111
  method set_scale _x111 = _scale <- Some _x111
  method unset_scale = _scale <- None
  method reset_scale = _scale <- None

  val mutable _precision : Int32.t option = None
  method get_precision = _precision
  method grab_precision = match _precision with None->raise (Field_empty "decimalType.precision") | Some _x112 -> _x112
  method set_precision _x112 = _precision <- Some _x112
  method unset_precision = _precision <- None
  method reset_precision = _precision <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "DecimalType";
    (match _scale with 
    | None -> raise (Field_empty "decimalType._scale")
    | Some _v -> 
      oprot#writeFieldBegin("scale",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _precision with 
    | None -> raise (Field_empty "decimalType._precision")
    | Some _v -> 
      oprot#writeFieldBegin("precision",Protocol.T_I32,2);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_decimalType (iprot : Protocol.t) =
  let _str115 = new decimalType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t116,_id117) = iprot#readFieldBegin in
        if _t116 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id117 with 
          | 1 -> (if _t116 = Protocol.T_I32 then
              _str115#set_scale iprot#readI32
            else
              iprot#skip _t116)
          | 2 -> (if _t116 = Protocol.T_I32 then
              _str115#set_precision iprot#readI32
            else
              iprot#skip _t116)
          | _ -> iprot#skip _t116);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str115

class milliSeconds =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "MilliSeconds";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_milliSeconds (iprot : Protocol.t) =
  let _str121 = new milliSeconds in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t122,_id123) = iprot#readFieldBegin in
        if _t122 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id123 with 
          | _ -> iprot#skip _t122);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str121

class microSeconds =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "MicroSeconds";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_microSeconds (iprot : Protocol.t) =
  let _str127 = new microSeconds in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t128,_id129) = iprot#readFieldBegin in
        if _t128 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id129 with 
          | _ -> iprot#skip _t128);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str127

class nanoSeconds =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "NanoSeconds";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_nanoSeconds (iprot : Protocol.t) =
  let _str133 = new nanoSeconds in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t134,_id135) = iprot#readFieldBegin in
        if _t134 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id135 with 
          | _ -> iprot#skip _t134);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str133

class timeUnit =
object (self)
  val mutable _mILLIS : milliSeconds option = None
  method get_mILLIS = _mILLIS
  method grab_mILLIS = match _mILLIS with None->raise (Field_empty "timeUnit.mILLIS") | Some _x137 -> _x137
  method set_mILLIS _x137 = _mILLIS <- Some _x137
  method unset_mILLIS = _mILLIS <- None
  method reset_mILLIS = _mILLIS <- None

  val mutable _mICROS : microSeconds option = None
  method get_mICROS = _mICROS
  method grab_mICROS = match _mICROS with None->raise (Field_empty "timeUnit.mICROS") | Some _x138 -> _x138
  method set_mICROS _x138 = _mICROS <- Some _x138
  method unset_mICROS = _mICROS <- None
  method reset_mICROS = _mICROS <- None

  val mutable _nANOS : nanoSeconds option = None
  method get_nANOS = _nANOS
  method grab_nANOS = match _nANOS with None->raise (Field_empty "timeUnit.nANOS") | Some _x139 -> _x139
  method set_nANOS _x139 = _nANOS <- Some _x139
  method unset_nANOS = _nANOS <- None
  method reset_nANOS = _nANOS <- None

  method copy =
      let _new = Oo.copy self in
      if _mILLIS <> None then
        _new#set_mILLIS self#grab_mILLIS#copy;
      if _mICROS <> None then
        _new#set_mICROS self#grab_mICROS#copy;
      if _nANOS <> None then
        _new#set_nANOS self#grab_nANOS#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "TimeUnit";
    (match _mILLIS with None -> () | Some _v -> 
      oprot#writeFieldBegin("MILLIS",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _mICROS with None -> () | Some _v -> 
      oprot#writeFieldBegin("MICROS",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nANOS with None -> () | Some _v -> 
      oprot#writeFieldBegin("NANOS",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_timeUnit (iprot : Protocol.t) =
  let _str142 = new timeUnit in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t143,_id144) = iprot#readFieldBegin in
        if _t143 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id144 with 
          | 1 -> (if _t143 = Protocol.T_STRUCT then
              _str142#set_mILLIS (read_milliSeconds iprot)
            else
              iprot#skip _t143)
          | 2 -> (if _t143 = Protocol.T_STRUCT then
              _str142#set_mICROS (read_microSeconds iprot)
            else
              iprot#skip _t143)
          | 3 -> (if _t143 = Protocol.T_STRUCT then
              _str142#set_nANOS (read_nanoSeconds iprot)
            else
              iprot#skip _t143)
          | _ -> iprot#skip _t143);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str142

class timestampType =
object (self)
  val mutable _isAdjustedToUTC : bool option = None
  method get_isAdjustedToUTC = _isAdjustedToUTC
  method grab_isAdjustedToUTC = match _isAdjustedToUTC with None->raise (Field_empty "timestampType.isAdjustedToUTC") | Some _x146 -> _x146
  method set_isAdjustedToUTC _x146 = _isAdjustedToUTC <- Some _x146
  method unset_isAdjustedToUTC = _isAdjustedToUTC <- None
  method reset_isAdjustedToUTC = _isAdjustedToUTC <- None

  val mutable _unit : timeUnit option = None
  method get_unit = _unit
  method grab_unit = match _unit with None->raise (Field_empty "timestampType.unit") | Some _x147 -> _x147
  method set_unit _x147 = _unit <- Some _x147
  method unset_unit = _unit <- None
  method reset_unit = _unit <- None

  method copy =
      let _new = Oo.copy self in
      if _unit <> None then
        _new#set_unit self#grab_unit#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "TimestampType";
    (match _isAdjustedToUTC with 
    | None -> raise (Field_empty "timestampType._isAdjustedToUTC")
    | Some _v -> 
      oprot#writeFieldBegin("isAdjustedToUTC",Protocol.T_BOOL,1);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    (match _unit with 
    | None -> raise (Field_empty "timestampType._unit")
    | Some _v -> 
      oprot#writeFieldBegin("unit",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_timestampType (iprot : Protocol.t) =
  let _str150 = new timestampType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t151,_id152) = iprot#readFieldBegin in
        if _t151 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id152 with 
          | 1 -> (if _t151 = Protocol.T_BOOL then
              _str150#set_isAdjustedToUTC iprot#readBool
            else
              iprot#skip _t151)
          | 2 -> (if _t151 = Protocol.T_STRUCT then
              _str150#set_unit (read_timeUnit iprot)
            else
              iprot#skip _t151)
          | _ -> iprot#skip _t151);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str150

class timeType =
object (self)
  val mutable _isAdjustedToUTC : bool option = None
  method get_isAdjustedToUTC = _isAdjustedToUTC
  method grab_isAdjustedToUTC = match _isAdjustedToUTC with None->raise (Field_empty "timeType.isAdjustedToUTC") | Some _x154 -> _x154
  method set_isAdjustedToUTC _x154 = _isAdjustedToUTC <- Some _x154
  method unset_isAdjustedToUTC = _isAdjustedToUTC <- None
  method reset_isAdjustedToUTC = _isAdjustedToUTC <- None

  val mutable _unit : timeUnit option = None
  method get_unit = _unit
  method grab_unit = match _unit with None->raise (Field_empty "timeType.unit") | Some _x155 -> _x155
  method set_unit _x155 = _unit <- Some _x155
  method unset_unit = _unit <- None
  method reset_unit = _unit <- None

  method copy =
      let _new = Oo.copy self in
      if _unit <> None then
        _new#set_unit self#grab_unit#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "TimeType";
    (match _isAdjustedToUTC with 
    | None -> raise (Field_empty "timeType._isAdjustedToUTC")
    | Some _v -> 
      oprot#writeFieldBegin("isAdjustedToUTC",Protocol.T_BOOL,1);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    (match _unit with 
    | None -> raise (Field_empty "timeType._unit")
    | Some _v -> 
      oprot#writeFieldBegin("unit",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_timeType (iprot : Protocol.t) =
  let _str158 = new timeType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t159,_id160) = iprot#readFieldBegin in
        if _t159 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id160 with 
          | 1 -> (if _t159 = Protocol.T_BOOL then
              _str158#set_isAdjustedToUTC iprot#readBool
            else
              iprot#skip _t159)
          | 2 -> (if _t159 = Protocol.T_STRUCT then
              _str158#set_unit (read_timeUnit iprot)
            else
              iprot#skip _t159)
          | _ -> iprot#skip _t159);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str158

class intType =
object (self)
  val mutable _bitWidth : int option = None
  method get_bitWidth = _bitWidth
  method grab_bitWidth = match _bitWidth with None->raise (Field_empty "intType.bitWidth") | Some _x162 -> _x162
  method set_bitWidth _x162 = _bitWidth <- Some _x162
  method unset_bitWidth = _bitWidth <- None
  method reset_bitWidth = _bitWidth <- None

  val mutable _isSigned : bool option = None
  method get_isSigned = _isSigned
  method grab_isSigned = match _isSigned with None->raise (Field_empty "intType.isSigned") | Some _x163 -> _x163
  method set_isSigned _x163 = _isSigned <- Some _x163
  method unset_isSigned = _isSigned <- None
  method reset_isSigned = _isSigned <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "IntType";
    (match _bitWidth with 
    | None -> raise (Field_empty "intType._bitWidth")
    | Some _v -> 
      oprot#writeFieldBegin("bitWidth",Protocol.T_BYTE,1);
      oprot#writeByte(_v);
      oprot#writeFieldEnd
    );
    (match _isSigned with 
    | None -> raise (Field_empty "intType._isSigned")
    | Some _v -> 
      oprot#writeFieldBegin("isSigned",Protocol.T_BOOL,2);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_intType (iprot : Protocol.t) =
  let _str166 = new intType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t167,_id168) = iprot#readFieldBegin in
        if _t167 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id168 with 
          | 1 -> (if _t167 = Protocol.T_BYTE then
              _str166#set_bitWidth iprot#readByte
            else
              iprot#skip _t167)
          | 2 -> (if _t167 = Protocol.T_BOOL then
              _str166#set_isSigned iprot#readBool
            else
              iprot#skip _t167)
          | _ -> iprot#skip _t167);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str166

class jsonType =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "JsonType";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_jsonType (iprot : Protocol.t) =
  let _str172 = new jsonType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t173,_id174) = iprot#readFieldBegin in
        if _t173 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id174 with 
          | _ -> iprot#skip _t173);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str172

class bsonType =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "BsonType";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_bsonType (iprot : Protocol.t) =
  let _str178 = new bsonType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t179,_id180) = iprot#readFieldBegin in
        if _t179 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id180 with 
          | _ -> iprot#skip _t179);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str178

class variantType =
object (self)
  val mutable _specification_version : int option = None
  method get_specification_version = _specification_version
  method grab_specification_version = match _specification_version with None->raise (Field_empty "variantType.specification_version") | Some _x182 -> _x182
  method set_specification_version _x182 = _specification_version <- Some _x182
  method unset_specification_version = _specification_version <- None
  method reset_specification_version = _specification_version <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "VariantType";
    (match _specification_version with None -> () | Some _v -> 
      oprot#writeFieldBegin("specification_version",Protocol.T_BYTE,1);
      oprot#writeByte(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_variantType (iprot : Protocol.t) =
  let _str185 = new variantType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t186,_id187) = iprot#readFieldBegin in
        if _t186 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id187 with 
          | 1 -> (if _t186 = Protocol.T_BYTE then
              _str185#set_specification_version iprot#readByte
            else
              iprot#skip _t186)
          | _ -> iprot#skip _t186);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str185

class geometryType =
object (self)
  val mutable _crs : string option = None
  method get_crs = _crs
  method grab_crs = match _crs with None->raise (Field_empty "geometryType.crs") | Some _x189 -> _x189
  method set_crs _x189 = _crs <- Some _x189
  method unset_crs = _crs <- None
  method reset_crs = _crs <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "GeometryType";
    (match _crs with None -> () | Some _v -> 
      oprot#writeFieldBegin("crs",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_geometryType (iprot : Protocol.t) =
  let _str192 = new geometryType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t193,_id194) = iprot#readFieldBegin in
        if _t193 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id194 with 
          | 1 -> (if _t193 = Protocol.T_STRING then
              _str192#set_crs iprot#readString
            else
              iprot#skip _t193)
          | _ -> iprot#skip _t193);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str192

class geographyType =
object (self)
  val mutable _crs : string option = None
  method get_crs = _crs
  method grab_crs = match _crs with None->raise (Field_empty "geographyType.crs") | Some _x196 -> _x196
  method set_crs _x196 = _crs <- Some _x196
  method unset_crs = _crs <- None
  method reset_crs = _crs <- None

  val mutable _algorithm : EdgeInterpolationAlgorithm.t option = None
  method get_algorithm = _algorithm
  method grab_algorithm = match _algorithm with None->raise (Field_empty "geographyType.algorithm") | Some _x197 -> _x197
  method set_algorithm _x197 = _algorithm <- Some _x197
  method unset_algorithm = _algorithm <- None
  method reset_algorithm = _algorithm <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "GeographyType";
    (match _crs with None -> () | Some _v -> 
      oprot#writeFieldBegin("crs",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _algorithm with None -> () | Some _v -> 
      oprot#writeFieldBegin("algorithm",Protocol.T_I32,2);
      oprot#writeI32(EdgeInterpolationAlgorithm.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_geographyType (iprot : Protocol.t) =
  let _str200 = new geographyType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t201,_id202) = iprot#readFieldBegin in
        if _t201 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id202 with 
          | 1 -> (if _t201 = Protocol.T_STRING then
              _str200#set_crs iprot#readString
            else
              iprot#skip _t201)
          | 2 -> (if _t201 = Protocol.T_I32 then
              _str200#set_algorithm (EdgeInterpolationAlgorithm.of_i iprot#readI32)
            else
              iprot#skip _t201)
          | _ -> iprot#skip _t201);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str200

class logicalType =
object (self)
  val mutable _sTRING : stringType option = None
  method get_sTRING = _sTRING
  method grab_sTRING = match _sTRING with None->raise (Field_empty "logicalType.sTRING") | Some _x204 -> _x204
  method set_sTRING _x204 = _sTRING <- Some _x204
  method unset_sTRING = _sTRING <- None
  method reset_sTRING = _sTRING <- None

  val mutable _mAP : mapType option = None
  method get_mAP = _mAP
  method grab_mAP = match _mAP with None->raise (Field_empty "logicalType.mAP") | Some _x205 -> _x205
  method set_mAP _x205 = _mAP <- Some _x205
  method unset_mAP = _mAP <- None
  method reset_mAP = _mAP <- None

  val mutable _lIST : listType option = None
  method get_lIST = _lIST
  method grab_lIST = match _lIST with None->raise (Field_empty "logicalType.lIST") | Some _x206 -> _x206
  method set_lIST _x206 = _lIST <- Some _x206
  method unset_lIST = _lIST <- None
  method reset_lIST = _lIST <- None

  val mutable _eNUM : enumType option = None
  method get_eNUM = _eNUM
  method grab_eNUM = match _eNUM with None->raise (Field_empty "logicalType.eNUM") | Some _x207 -> _x207
  method set_eNUM _x207 = _eNUM <- Some _x207
  method unset_eNUM = _eNUM <- None
  method reset_eNUM = _eNUM <- None

  val mutable _dECIMAL : decimalType option = None
  method get_dECIMAL = _dECIMAL
  method grab_dECIMAL = match _dECIMAL with None->raise (Field_empty "logicalType.dECIMAL") | Some _x208 -> _x208
  method set_dECIMAL _x208 = _dECIMAL <- Some _x208
  method unset_dECIMAL = _dECIMAL <- None
  method reset_dECIMAL = _dECIMAL <- None

  val mutable _dATE : dateType option = None
  method get_dATE = _dATE
  method grab_dATE = match _dATE with None->raise (Field_empty "logicalType.dATE") | Some _x209 -> _x209
  method set_dATE _x209 = _dATE <- Some _x209
  method unset_dATE = _dATE <- None
  method reset_dATE = _dATE <- None

  val mutable _tIME : timeType option = None
  method get_tIME = _tIME
  method grab_tIME = match _tIME with None->raise (Field_empty "logicalType.tIME") | Some _x210 -> _x210
  method set_tIME _x210 = _tIME <- Some _x210
  method unset_tIME = _tIME <- None
  method reset_tIME = _tIME <- None

  val mutable _tIMESTAMP : timestampType option = None
  method get_tIMESTAMP = _tIMESTAMP
  method grab_tIMESTAMP = match _tIMESTAMP with None->raise (Field_empty "logicalType.tIMESTAMP") | Some _x211 -> _x211
  method set_tIMESTAMP _x211 = _tIMESTAMP <- Some _x211
  method unset_tIMESTAMP = _tIMESTAMP <- None
  method reset_tIMESTAMP = _tIMESTAMP <- None

  val mutable _iNTEGER : intType option = None
  method get_iNTEGER = _iNTEGER
  method grab_iNTEGER = match _iNTEGER with None->raise (Field_empty "logicalType.iNTEGER") | Some _x212 -> _x212
  method set_iNTEGER _x212 = _iNTEGER <- Some _x212
  method unset_iNTEGER = _iNTEGER <- None
  method reset_iNTEGER = _iNTEGER <- None

  val mutable _uNKNOWN : nullType option = None
  method get_uNKNOWN = _uNKNOWN
  method grab_uNKNOWN = match _uNKNOWN with None->raise (Field_empty "logicalType.uNKNOWN") | Some _x213 -> _x213
  method set_uNKNOWN _x213 = _uNKNOWN <- Some _x213
  method unset_uNKNOWN = _uNKNOWN <- None
  method reset_uNKNOWN = _uNKNOWN <- None

  val mutable _jSON : jsonType option = None
  method get_jSON = _jSON
  method grab_jSON = match _jSON with None->raise (Field_empty "logicalType.jSON") | Some _x214 -> _x214
  method set_jSON _x214 = _jSON <- Some _x214
  method unset_jSON = _jSON <- None
  method reset_jSON = _jSON <- None

  val mutable _bSON : bsonType option = None
  method get_bSON = _bSON
  method grab_bSON = match _bSON with None->raise (Field_empty "logicalType.bSON") | Some _x215 -> _x215
  method set_bSON _x215 = _bSON <- Some _x215
  method unset_bSON = _bSON <- None
  method reset_bSON = _bSON <- None

  val mutable _uUID : uUIDType option = None
  method get_uUID = _uUID
  method grab_uUID = match _uUID with None->raise (Field_empty "logicalType.uUID") | Some _x216 -> _x216
  method set_uUID _x216 = _uUID <- Some _x216
  method unset_uUID = _uUID <- None
  method reset_uUID = _uUID <- None

  val mutable _fLOAT16 : float16Type option = None
  method get_fLOAT16 = _fLOAT16
  method grab_fLOAT16 = match _fLOAT16 with None->raise (Field_empty "logicalType.fLOAT16") | Some _x217 -> _x217
  method set_fLOAT16 _x217 = _fLOAT16 <- Some _x217
  method unset_fLOAT16 = _fLOAT16 <- None
  method reset_fLOAT16 = _fLOAT16 <- None

  val mutable _vARIANT : variantType option = None
  method get_vARIANT = _vARIANT
  method grab_vARIANT = match _vARIANT with None->raise (Field_empty "logicalType.vARIANT") | Some _x218 -> _x218
  method set_vARIANT _x218 = _vARIANT <- Some _x218
  method unset_vARIANT = _vARIANT <- None
  method reset_vARIANT = _vARIANT <- None

  val mutable _gEOMETRY : geometryType option = None
  method get_gEOMETRY = _gEOMETRY
  method grab_gEOMETRY = match _gEOMETRY with None->raise (Field_empty "logicalType.gEOMETRY") | Some _x219 -> _x219
  method set_gEOMETRY _x219 = _gEOMETRY <- Some _x219
  method unset_gEOMETRY = _gEOMETRY <- None
  method reset_gEOMETRY = _gEOMETRY <- None

  val mutable _gEOGRAPHY : geographyType option = None
  method get_gEOGRAPHY = _gEOGRAPHY
  method grab_gEOGRAPHY = match _gEOGRAPHY with None->raise (Field_empty "logicalType.gEOGRAPHY") | Some _x220 -> _x220
  method set_gEOGRAPHY _x220 = _gEOGRAPHY <- Some _x220
  method unset_gEOGRAPHY = _gEOGRAPHY <- None
  method reset_gEOGRAPHY = _gEOGRAPHY <- None

  method copy =
      let _new = Oo.copy self in
      if _sTRING <> None then
        _new#set_sTRING self#grab_sTRING#copy;
      if _mAP <> None then
        _new#set_mAP self#grab_mAP#copy;
      if _lIST <> None then
        _new#set_lIST self#grab_lIST#copy;
      if _eNUM <> None then
        _new#set_eNUM self#grab_eNUM#copy;
      if _dECIMAL <> None then
        _new#set_dECIMAL self#grab_dECIMAL#copy;
      if _dATE <> None then
        _new#set_dATE self#grab_dATE#copy;
      if _tIME <> None then
        _new#set_tIME self#grab_tIME#copy;
      if _tIMESTAMP <> None then
        _new#set_tIMESTAMP self#grab_tIMESTAMP#copy;
      if _iNTEGER <> None then
        _new#set_iNTEGER self#grab_iNTEGER#copy;
      if _uNKNOWN <> None then
        _new#set_uNKNOWN self#grab_uNKNOWN#copy;
      if _jSON <> None then
        _new#set_jSON self#grab_jSON#copy;
      if _bSON <> None then
        _new#set_bSON self#grab_bSON#copy;
      if _uUID <> None then
        _new#set_uUID self#grab_uUID#copy;
      if _fLOAT16 <> None then
        _new#set_fLOAT16 self#grab_fLOAT16#copy;
      if _vARIANT <> None then
        _new#set_vARIANT self#grab_vARIANT#copy;
      if _gEOMETRY <> None then
        _new#set_gEOMETRY self#grab_gEOMETRY#copy;
      if _gEOGRAPHY <> None then
        _new#set_gEOGRAPHY self#grab_gEOGRAPHY#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "LogicalType";
    (match _sTRING with None -> () | Some _v -> 
      oprot#writeFieldBegin("STRING",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _mAP with None -> () | Some _v -> 
      oprot#writeFieldBegin("MAP",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _lIST with None -> () | Some _v -> 
      oprot#writeFieldBegin("LIST",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _eNUM with None -> () | Some _v -> 
      oprot#writeFieldBegin("ENUM",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _dECIMAL with None -> () | Some _v -> 
      oprot#writeFieldBegin("DECIMAL",Protocol.T_STRUCT,5);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _dATE with None -> () | Some _v -> 
      oprot#writeFieldBegin("DATE",Protocol.T_STRUCT,6);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _tIME with None -> () | Some _v -> 
      oprot#writeFieldBegin("TIME",Protocol.T_STRUCT,7);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _tIMESTAMP with None -> () | Some _v -> 
      oprot#writeFieldBegin("TIMESTAMP",Protocol.T_STRUCT,8);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _iNTEGER with None -> () | Some _v -> 
      oprot#writeFieldBegin("INTEGER",Protocol.T_STRUCT,10);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _uNKNOWN with None -> () | Some _v -> 
      oprot#writeFieldBegin("UNKNOWN",Protocol.T_STRUCT,11);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _jSON with None -> () | Some _v -> 
      oprot#writeFieldBegin("JSON",Protocol.T_STRUCT,12);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _bSON with None -> () | Some _v -> 
      oprot#writeFieldBegin("BSON",Protocol.T_STRUCT,13);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _uUID with None -> () | Some _v -> 
      oprot#writeFieldBegin("UUID",Protocol.T_STRUCT,14);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _fLOAT16 with None -> () | Some _v -> 
      oprot#writeFieldBegin("FLOAT16",Protocol.T_STRUCT,15);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _vARIANT with None -> () | Some _v -> 
      oprot#writeFieldBegin("VARIANT",Protocol.T_STRUCT,16);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _gEOMETRY with None -> () | Some _v -> 
      oprot#writeFieldBegin("GEOMETRY",Protocol.T_STRUCT,17);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _gEOGRAPHY with None -> () | Some _v -> 
      oprot#writeFieldBegin("GEOGRAPHY",Protocol.T_STRUCT,18);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_logicalType (iprot : Protocol.t) =
  let _str223 = new logicalType in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t224,_id225) = iprot#readFieldBegin in
        if _t224 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id225 with 
          | 1 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_sTRING (read_stringType iprot)
            else
              iprot#skip _t224)
          | 2 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_mAP (read_mapType iprot)
            else
              iprot#skip _t224)
          | 3 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_lIST (read_listType iprot)
            else
              iprot#skip _t224)
          | 4 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_eNUM (read_enumType iprot)
            else
              iprot#skip _t224)
          | 5 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_dECIMAL (read_decimalType iprot)
            else
              iprot#skip _t224)
          | 6 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_dATE (read_dateType iprot)
            else
              iprot#skip _t224)
          | 7 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_tIME (read_timeType iprot)
            else
              iprot#skip _t224)
          | 8 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_tIMESTAMP (read_timestampType iprot)
            else
              iprot#skip _t224)
          | 10 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_iNTEGER (read_intType iprot)
            else
              iprot#skip _t224)
          | 11 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_uNKNOWN (read_nullType iprot)
            else
              iprot#skip _t224)
          | 12 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_jSON (read_jsonType iprot)
            else
              iprot#skip _t224)
          | 13 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_bSON (read_bsonType iprot)
            else
              iprot#skip _t224)
          | 14 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_uUID (read_uUIDType iprot)
            else
              iprot#skip _t224)
          | 15 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_fLOAT16 (read_float16Type iprot)
            else
              iprot#skip _t224)
          | 16 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_vARIANT (read_variantType iprot)
            else
              iprot#skip _t224)
          | 17 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_gEOMETRY (read_geometryType iprot)
            else
              iprot#skip _t224)
          | 18 -> (if _t224 = Protocol.T_STRUCT then
              _str223#set_gEOGRAPHY (read_geographyType iprot)
            else
              iprot#skip _t224)
          | _ -> iprot#skip _t224);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str223

class schemaElement =
object (self)
  val mutable _type : Type.t option = None
  method get_type = _type
  method grab_type = match _type with None->raise (Field_empty "schemaElement.type") | Some _x227 -> _x227
  method set_type _x227 = _type <- Some _x227
  method unset_type = _type <- None
  method reset_type = _type <- None

  val mutable _type_length : Int32.t option = None
  method get_type_length = _type_length
  method grab_type_length = match _type_length with None->raise (Field_empty "schemaElement.type_length") | Some _x228 -> _x228
  method set_type_length _x228 = _type_length <- Some _x228
  method unset_type_length = _type_length <- None
  method reset_type_length = _type_length <- None

  val mutable _repetition_type : FieldRepetitionType.t option = None
  method get_repetition_type = _repetition_type
  method grab_repetition_type = match _repetition_type with None->raise (Field_empty "schemaElement.repetition_type") | Some _x229 -> _x229
  method set_repetition_type _x229 = _repetition_type <- Some _x229
  method unset_repetition_type = _repetition_type <- None
  method reset_repetition_type = _repetition_type <- None

  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "schemaElement.name") | Some _x230 -> _x230
  method set_name _x230 = _name <- Some _x230
  method unset_name = _name <- None
  method reset_name = _name <- None

  val mutable _num_children : Int32.t option = None
  method get_num_children = _num_children
  method grab_num_children = match _num_children with None->raise (Field_empty "schemaElement.num_children") | Some _x231 -> _x231
  method set_num_children _x231 = _num_children <- Some _x231
  method unset_num_children = _num_children <- None
  method reset_num_children = _num_children <- None

  val mutable _converted_type : ConvertedType.t option = None
  method get_converted_type = _converted_type
  method grab_converted_type = match _converted_type with None->raise (Field_empty "schemaElement.converted_type") | Some _x232 -> _x232
  method set_converted_type _x232 = _converted_type <- Some _x232
  method unset_converted_type = _converted_type <- None
  method reset_converted_type = _converted_type <- None

  val mutable _scale : Int32.t option = None
  method get_scale = _scale
  method grab_scale = match _scale with None->raise (Field_empty "schemaElement.scale") | Some _x233 -> _x233
  method set_scale _x233 = _scale <- Some _x233
  method unset_scale = _scale <- None
  method reset_scale = _scale <- None

  val mutable _precision : Int32.t option = None
  method get_precision = _precision
  method grab_precision = match _precision with None->raise (Field_empty "schemaElement.precision") | Some _x234 -> _x234
  method set_precision _x234 = _precision <- Some _x234
  method unset_precision = _precision <- None
  method reset_precision = _precision <- None

  val mutable _field_id : Int32.t option = None
  method get_field_id = _field_id
  method grab_field_id = match _field_id with None->raise (Field_empty "schemaElement.field_id") | Some _x235 -> _x235
  method set_field_id _x235 = _field_id <- Some _x235
  method unset_field_id = _field_id <- None
  method reset_field_id = _field_id <- None

  val mutable _logicalType : logicalType option = None
  method get_logicalType = _logicalType
  method grab_logicalType = match _logicalType with None->raise (Field_empty "schemaElement.logicalType") | Some _x236 -> _x236
  method set_logicalType _x236 = _logicalType <- Some _x236
  method unset_logicalType = _logicalType <- None
  method reset_logicalType = _logicalType <- None

  method copy =
      let _new = Oo.copy self in
      if _logicalType <> None then
        _new#set_logicalType self#grab_logicalType#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SchemaElement";
    (match _type with None -> () | Some _v -> 
      oprot#writeFieldBegin("type",Protocol.T_I32,1);
      oprot#writeI32(Type.to_i _v);
      oprot#writeFieldEnd
    );
    (match _type_length with None -> () | Some _v -> 
      oprot#writeFieldBegin("type_length",Protocol.T_I32,2);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _repetition_type with None -> () | Some _v -> 
      oprot#writeFieldBegin("repetition_type",Protocol.T_I32,3);
      oprot#writeI32(FieldRepetitionType.to_i _v);
      oprot#writeFieldEnd
    );
    (match _name with 
    | None -> raise (Field_empty "schemaElement._name")
    | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _num_children with None -> () | Some _v -> 
      oprot#writeFieldBegin("num_children",Protocol.T_I32,5);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _converted_type with None -> () | Some _v -> 
      oprot#writeFieldBegin("converted_type",Protocol.T_I32,6);
      oprot#writeI32(ConvertedType.to_i _v);
      oprot#writeFieldEnd
    );
    (match _scale with None -> () | Some _v -> 
      oprot#writeFieldBegin("scale",Protocol.T_I32,7);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _precision with None -> () | Some _v -> 
      oprot#writeFieldBegin("precision",Protocol.T_I32,8);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _field_id with None -> () | Some _v -> 
      oprot#writeFieldBegin("field_id",Protocol.T_I32,9);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _logicalType with None -> () | Some _v -> 
      oprot#writeFieldBegin("logicalType",Protocol.T_STRUCT,10);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_schemaElement (iprot : Protocol.t) =
  let _str239 = new schemaElement in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t240,_id241) = iprot#readFieldBegin in
        if _t240 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id241 with 
          | 1 -> (if _t240 = Protocol.T_I32 then
              _str239#set_type (Type.of_i iprot#readI32)
            else
              iprot#skip _t240)
          | 2 -> (if _t240 = Protocol.T_I32 then
              _str239#set_type_length iprot#readI32
            else
              iprot#skip _t240)
          | 3 -> (if _t240 = Protocol.T_I32 then
              _str239#set_repetition_type (FieldRepetitionType.of_i iprot#readI32)
            else
              iprot#skip _t240)
          | 4 -> (if _t240 = Protocol.T_STRING then
              _str239#set_name iprot#readString
            else
              iprot#skip _t240)
          | 5 -> (if _t240 = Protocol.T_I32 then
              _str239#set_num_children iprot#readI32
            else
              iprot#skip _t240)
          | 6 -> (if _t240 = Protocol.T_I32 then
              _str239#set_converted_type (ConvertedType.of_i iprot#readI32)
            else
              iprot#skip _t240)
          | 7 -> (if _t240 = Protocol.T_I32 then
              _str239#set_scale iprot#readI32
            else
              iprot#skip _t240)
          | 8 -> (if _t240 = Protocol.T_I32 then
              _str239#set_precision iprot#readI32
            else
              iprot#skip _t240)
          | 9 -> (if _t240 = Protocol.T_I32 then
              _str239#set_field_id iprot#readI32
            else
              iprot#skip _t240)
          | 10 -> (if _t240 = Protocol.T_STRUCT then
              _str239#set_logicalType (read_logicalType iprot)
            else
              iprot#skip _t240)
          | _ -> iprot#skip _t240);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str239

class dataPageHeader =
object (self)
  val mutable _num_values : Int32.t option = None
  method get_num_values = _num_values
  method grab_num_values = match _num_values with None->raise (Field_empty "dataPageHeader.num_values") | Some _x243 -> _x243
  method set_num_values _x243 = _num_values <- Some _x243
  method unset_num_values = _num_values <- None
  method reset_num_values = _num_values <- None

  val mutable _encoding : Encoding.t option = None
  method get_encoding = _encoding
  method grab_encoding = match _encoding with None->raise (Field_empty "dataPageHeader.encoding") | Some _x244 -> _x244
  method set_encoding _x244 = _encoding <- Some _x244
  method unset_encoding = _encoding <- None
  method reset_encoding = _encoding <- None

  val mutable _definition_level_encoding : Encoding.t option = None
  method get_definition_level_encoding = _definition_level_encoding
  method grab_definition_level_encoding = match _definition_level_encoding with None->raise (Field_empty "dataPageHeader.definition_level_encoding") | Some _x245 -> _x245
  method set_definition_level_encoding _x245 = _definition_level_encoding <- Some _x245
  method unset_definition_level_encoding = _definition_level_encoding <- None
  method reset_definition_level_encoding = _definition_level_encoding <- None

  val mutable _repetition_level_encoding : Encoding.t option = None
  method get_repetition_level_encoding = _repetition_level_encoding
  method grab_repetition_level_encoding = match _repetition_level_encoding with None->raise (Field_empty "dataPageHeader.repetition_level_encoding") | Some _x246 -> _x246
  method set_repetition_level_encoding _x246 = _repetition_level_encoding <- Some _x246
  method unset_repetition_level_encoding = _repetition_level_encoding <- None
  method reset_repetition_level_encoding = _repetition_level_encoding <- None

  val mutable _statistics : statistics option = None
  method get_statistics = _statistics
  method grab_statistics = match _statistics with None->raise (Field_empty "dataPageHeader.statistics") | Some _x247 -> _x247
  method set_statistics _x247 = _statistics <- Some _x247
  method unset_statistics = _statistics <- None
  method reset_statistics = _statistics <- None

  method copy =
      let _new = Oo.copy self in
      if _statistics <> None then
        _new#set_statistics self#grab_statistics#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "DataPageHeader";
    (match _num_values with 
    | None -> raise (Field_empty "dataPageHeader._num_values")
    | Some _v -> 
      oprot#writeFieldBegin("num_values",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _encoding with 
    | None -> raise (Field_empty "dataPageHeader._encoding")
    | Some _v -> 
      oprot#writeFieldBegin("encoding",Protocol.T_I32,2);
      oprot#writeI32(Encoding.to_i _v);
      oprot#writeFieldEnd
    );
    (match _definition_level_encoding with 
    | None -> raise (Field_empty "dataPageHeader._definition_level_encoding")
    | Some _v -> 
      oprot#writeFieldBegin("definition_level_encoding",Protocol.T_I32,3);
      oprot#writeI32(Encoding.to_i _v);
      oprot#writeFieldEnd
    );
    (match _repetition_level_encoding with 
    | None -> raise (Field_empty "dataPageHeader._repetition_level_encoding")
    | Some _v -> 
      oprot#writeFieldBegin("repetition_level_encoding",Protocol.T_I32,4);
      oprot#writeI32(Encoding.to_i _v);
      oprot#writeFieldEnd
    );
    (match _statistics with None -> () | Some _v -> 
      oprot#writeFieldBegin("statistics",Protocol.T_STRUCT,5);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_dataPageHeader (iprot : Protocol.t) =
  let _str250 = new dataPageHeader in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t251,_id252) = iprot#readFieldBegin in
        if _t251 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id252 with 
          | 1 -> (if _t251 = Protocol.T_I32 then
              _str250#set_num_values iprot#readI32
            else
              iprot#skip _t251)
          | 2 -> (if _t251 = Protocol.T_I32 then
              _str250#set_encoding (Encoding.of_i iprot#readI32)
            else
              iprot#skip _t251)
          | 3 -> (if _t251 = Protocol.T_I32 then
              _str250#set_definition_level_encoding (Encoding.of_i iprot#readI32)
            else
              iprot#skip _t251)
          | 4 -> (if _t251 = Protocol.T_I32 then
              _str250#set_repetition_level_encoding (Encoding.of_i iprot#readI32)
            else
              iprot#skip _t251)
          | 5 -> (if _t251 = Protocol.T_STRUCT then
              _str250#set_statistics (read_statistics iprot)
            else
              iprot#skip _t251)
          | _ -> iprot#skip _t251);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str250

class indexPageHeader =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "IndexPageHeader";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_indexPageHeader (iprot : Protocol.t) =
  let _str256 = new indexPageHeader in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t257,_id258) = iprot#readFieldBegin in
        if _t257 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id258 with 
          | _ -> iprot#skip _t257);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str256

class dictionaryPageHeader =
object (self)
  val mutable _num_values : Int32.t option = None
  method get_num_values = _num_values
  method grab_num_values = match _num_values with None->raise (Field_empty "dictionaryPageHeader.num_values") | Some _x260 -> _x260
  method set_num_values _x260 = _num_values <- Some _x260
  method unset_num_values = _num_values <- None
  method reset_num_values = _num_values <- None

  val mutable _encoding : Encoding.t option = None
  method get_encoding = _encoding
  method grab_encoding = match _encoding with None->raise (Field_empty "dictionaryPageHeader.encoding") | Some _x261 -> _x261
  method set_encoding _x261 = _encoding <- Some _x261
  method unset_encoding = _encoding <- None
  method reset_encoding = _encoding <- None

  val mutable _is_sorted : bool option = None
  method get_is_sorted = _is_sorted
  method grab_is_sorted = match _is_sorted with None->raise (Field_empty "dictionaryPageHeader.is_sorted") | Some _x262 -> _x262
  method set_is_sorted _x262 = _is_sorted <- Some _x262
  method unset_is_sorted = _is_sorted <- None
  method reset_is_sorted = _is_sorted <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "DictionaryPageHeader";
    (match _num_values with 
    | None -> raise (Field_empty "dictionaryPageHeader._num_values")
    | Some _v -> 
      oprot#writeFieldBegin("num_values",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _encoding with 
    | None -> raise (Field_empty "dictionaryPageHeader._encoding")
    | Some _v -> 
      oprot#writeFieldBegin("encoding",Protocol.T_I32,2);
      oprot#writeI32(Encoding.to_i _v);
      oprot#writeFieldEnd
    );
    (match _is_sorted with None -> () | Some _v -> 
      oprot#writeFieldBegin("is_sorted",Protocol.T_BOOL,3);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_dictionaryPageHeader (iprot : Protocol.t) =
  let _str265 = new dictionaryPageHeader in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t266,_id267) = iprot#readFieldBegin in
        if _t266 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id267 with 
          | 1 -> (if _t266 = Protocol.T_I32 then
              _str265#set_num_values iprot#readI32
            else
              iprot#skip _t266)
          | 2 -> (if _t266 = Protocol.T_I32 then
              _str265#set_encoding (Encoding.of_i iprot#readI32)
            else
              iprot#skip _t266)
          | 3 -> (if _t266 = Protocol.T_BOOL then
              _str265#set_is_sorted iprot#readBool
            else
              iprot#skip _t266)
          | _ -> iprot#skip _t266);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str265

class dataPageHeaderV2 =
object (self)
  val mutable _num_values : Int32.t option = None
  method get_num_values = _num_values
  method grab_num_values = match _num_values with None->raise (Field_empty "dataPageHeaderV2.num_values") | Some _x269 -> _x269
  method set_num_values _x269 = _num_values <- Some _x269
  method unset_num_values = _num_values <- None
  method reset_num_values = _num_values <- None

  val mutable _num_nulls : Int32.t option = None
  method get_num_nulls = _num_nulls
  method grab_num_nulls = match _num_nulls with None->raise (Field_empty "dataPageHeaderV2.num_nulls") | Some _x270 -> _x270
  method set_num_nulls _x270 = _num_nulls <- Some _x270
  method unset_num_nulls = _num_nulls <- None
  method reset_num_nulls = _num_nulls <- None

  val mutable _num_rows : Int32.t option = None
  method get_num_rows = _num_rows
  method grab_num_rows = match _num_rows with None->raise (Field_empty "dataPageHeaderV2.num_rows") | Some _x271 -> _x271
  method set_num_rows _x271 = _num_rows <- Some _x271
  method unset_num_rows = _num_rows <- None
  method reset_num_rows = _num_rows <- None

  val mutable _encoding : Encoding.t option = None
  method get_encoding = _encoding
  method grab_encoding = match _encoding with None->raise (Field_empty "dataPageHeaderV2.encoding") | Some _x272 -> _x272
  method set_encoding _x272 = _encoding <- Some _x272
  method unset_encoding = _encoding <- None
  method reset_encoding = _encoding <- None

  val mutable _definition_levels_byte_length : Int32.t option = None
  method get_definition_levels_byte_length = _definition_levels_byte_length
  method grab_definition_levels_byte_length = match _definition_levels_byte_length with None->raise (Field_empty "dataPageHeaderV2.definition_levels_byte_length") | Some _x273 -> _x273
  method set_definition_levels_byte_length _x273 = _definition_levels_byte_length <- Some _x273
  method unset_definition_levels_byte_length = _definition_levels_byte_length <- None
  method reset_definition_levels_byte_length = _definition_levels_byte_length <- None

  val mutable _repetition_levels_byte_length : Int32.t option = None
  method get_repetition_levels_byte_length = _repetition_levels_byte_length
  method grab_repetition_levels_byte_length = match _repetition_levels_byte_length with None->raise (Field_empty "dataPageHeaderV2.repetition_levels_byte_length") | Some _x274 -> _x274
  method set_repetition_levels_byte_length _x274 = _repetition_levels_byte_length <- Some _x274
  method unset_repetition_levels_byte_length = _repetition_levels_byte_length <- None
  method reset_repetition_levels_byte_length = _repetition_levels_byte_length <- None

  val mutable _is_compressed : bool = true
  method get_is_compressed = Some _is_compressed
  method grab_is_compressed = _is_compressed
  method set_is_compressed _x275 = _is_compressed <- _x275
  method reset_is_compressed = _is_compressed <- true

  val mutable _statistics : statistics option = None
  method get_statistics = _statistics
  method grab_statistics = match _statistics with None->raise (Field_empty "dataPageHeaderV2.statistics") | Some _x276 -> _x276
  method set_statistics _x276 = _statistics <- Some _x276
  method unset_statistics = _statistics <- None
  method reset_statistics = _statistics <- None

  method copy =
      let _new = Oo.copy self in
      if _statistics <> None then
        _new#set_statistics self#grab_statistics#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "DataPageHeaderV2";
    (match _num_values with 
    | None -> raise (Field_empty "dataPageHeaderV2._num_values")
    | Some _v -> 
      oprot#writeFieldBegin("num_values",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _num_nulls with 
    | None -> raise (Field_empty "dataPageHeaderV2._num_nulls")
    | Some _v -> 
      oprot#writeFieldBegin("num_nulls",Protocol.T_I32,2);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _num_rows with 
    | None -> raise (Field_empty "dataPageHeaderV2._num_rows")
    | Some _v -> 
      oprot#writeFieldBegin("num_rows",Protocol.T_I32,3);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _encoding with 
    | None -> raise (Field_empty "dataPageHeaderV2._encoding")
    | Some _v -> 
      oprot#writeFieldBegin("encoding",Protocol.T_I32,4);
      oprot#writeI32(Encoding.to_i _v);
      oprot#writeFieldEnd
    );
    (match _definition_levels_byte_length with 
    | None -> raise (Field_empty "dataPageHeaderV2._definition_levels_byte_length")
    | Some _v -> 
      oprot#writeFieldBegin("definition_levels_byte_length",Protocol.T_I32,5);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _repetition_levels_byte_length with 
    | None -> raise (Field_empty "dataPageHeaderV2._repetition_levels_byte_length")
    | Some _v -> 
      oprot#writeFieldBegin("repetition_levels_byte_length",Protocol.T_I32,6);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _is_compressed with true -> () | _v -> 
      oprot#writeFieldBegin("is_compressed",Protocol.T_BOOL,7);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    (match _statistics with None -> () | Some _v -> 
      oprot#writeFieldBegin("statistics",Protocol.T_STRUCT,8);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_dataPageHeaderV2 (iprot : Protocol.t) =
  let _str279 = new dataPageHeaderV2 in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t280,_id281) = iprot#readFieldBegin in
        if _t280 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id281 with 
          | 1 -> (if _t280 = Protocol.T_I32 then
              _str279#set_num_values iprot#readI32
            else
              iprot#skip _t280)
          | 2 -> (if _t280 = Protocol.T_I32 then
              _str279#set_num_nulls iprot#readI32
            else
              iprot#skip _t280)
          | 3 -> (if _t280 = Protocol.T_I32 then
              _str279#set_num_rows iprot#readI32
            else
              iprot#skip _t280)
          | 4 -> (if _t280 = Protocol.T_I32 then
              _str279#set_encoding (Encoding.of_i iprot#readI32)
            else
              iprot#skip _t280)
          | 5 -> (if _t280 = Protocol.T_I32 then
              _str279#set_definition_levels_byte_length iprot#readI32
            else
              iprot#skip _t280)
          | 6 -> (if _t280 = Protocol.T_I32 then
              _str279#set_repetition_levels_byte_length iprot#readI32
            else
              iprot#skip _t280)
          | 7 -> (if _t280 = Protocol.T_BOOL then
              _str279#set_is_compressed iprot#readBool
            else
              iprot#skip _t280)
          | 8 -> (if _t280 = Protocol.T_STRUCT then
              _str279#set_statistics (read_statistics iprot)
            else
              iprot#skip _t280)
          | _ -> iprot#skip _t280);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str279

class splitBlockAlgorithm =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SplitBlockAlgorithm";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_splitBlockAlgorithm (iprot : Protocol.t) =
  let _str285 = new splitBlockAlgorithm in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t286,_id287) = iprot#readFieldBegin in
        if _t286 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id287 with 
          | _ -> iprot#skip _t286);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str285

class bloomFilterAlgorithm =
object (self)
  val mutable _bLOCK : splitBlockAlgorithm option = None
  method get_bLOCK = _bLOCK
  method grab_bLOCK = match _bLOCK with None->raise (Field_empty "bloomFilterAlgorithm.bLOCK") | Some _x289 -> _x289
  method set_bLOCK _x289 = _bLOCK <- Some _x289
  method unset_bLOCK = _bLOCK <- None
  method reset_bLOCK = _bLOCK <- None

  method copy =
      let _new = Oo.copy self in
      if _bLOCK <> None then
        _new#set_bLOCK self#grab_bLOCK#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "BloomFilterAlgorithm";
    (match _bLOCK with None -> () | Some _v -> 
      oprot#writeFieldBegin("BLOCK",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_bloomFilterAlgorithm (iprot : Protocol.t) =
  let _str292 = new bloomFilterAlgorithm in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t293,_id294) = iprot#readFieldBegin in
        if _t293 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id294 with 
          | 1 -> (if _t293 = Protocol.T_STRUCT then
              _str292#set_bLOCK (read_splitBlockAlgorithm iprot)
            else
              iprot#skip _t293)
          | _ -> iprot#skip _t293);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str292

class xxHash =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "XxHash";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_xxHash (iprot : Protocol.t) =
  let _str298 = new xxHash in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t299,_id300) = iprot#readFieldBegin in
        if _t299 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id300 with 
          | _ -> iprot#skip _t299);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str298

class bloomFilterHash =
object (self)
  val mutable _xXHASH : xxHash option = None
  method get_xXHASH = _xXHASH
  method grab_xXHASH = match _xXHASH with None->raise (Field_empty "bloomFilterHash.xXHASH") | Some _x302 -> _x302
  method set_xXHASH _x302 = _xXHASH <- Some _x302
  method unset_xXHASH = _xXHASH <- None
  method reset_xXHASH = _xXHASH <- None

  method copy =
      let _new = Oo.copy self in
      if _xXHASH <> None then
        _new#set_xXHASH self#grab_xXHASH#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "BloomFilterHash";
    (match _xXHASH with None -> () | Some _v -> 
      oprot#writeFieldBegin("XXHASH",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_bloomFilterHash (iprot : Protocol.t) =
  let _str305 = new bloomFilterHash in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t306,_id307) = iprot#readFieldBegin in
        if _t306 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id307 with 
          | 1 -> (if _t306 = Protocol.T_STRUCT then
              _str305#set_xXHASH (read_xxHash iprot)
            else
              iprot#skip _t306)
          | _ -> iprot#skip _t306);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str305

class uncompressed =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Uncompressed";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_uncompressed (iprot : Protocol.t) =
  let _str311 = new uncompressed in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t312,_id313) = iprot#readFieldBegin in
        if _t312 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id313 with 
          | _ -> iprot#skip _t312);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str311

class bloomFilterCompression =
object (self)
  val mutable _uNCOMPRESSED : uncompressed option = None
  method get_uNCOMPRESSED = _uNCOMPRESSED
  method grab_uNCOMPRESSED = match _uNCOMPRESSED with None->raise (Field_empty "bloomFilterCompression.uNCOMPRESSED") | Some _x315 -> _x315
  method set_uNCOMPRESSED _x315 = _uNCOMPRESSED <- Some _x315
  method unset_uNCOMPRESSED = _uNCOMPRESSED <- None
  method reset_uNCOMPRESSED = _uNCOMPRESSED <- None

  method copy =
      let _new = Oo.copy self in
      if _uNCOMPRESSED <> None then
        _new#set_uNCOMPRESSED self#grab_uNCOMPRESSED#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "BloomFilterCompression";
    (match _uNCOMPRESSED with None -> () | Some _v -> 
      oprot#writeFieldBegin("UNCOMPRESSED",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_bloomFilterCompression (iprot : Protocol.t) =
  let _str318 = new bloomFilterCompression in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t319,_id320) = iprot#readFieldBegin in
        if _t319 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id320 with 
          | 1 -> (if _t319 = Protocol.T_STRUCT then
              _str318#set_uNCOMPRESSED (read_uncompressed iprot)
            else
              iprot#skip _t319)
          | _ -> iprot#skip _t319);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str318

class bloomFilterHeader =
object (self)
  val mutable _numBytes : Int32.t option = None
  method get_numBytes = _numBytes
  method grab_numBytes = match _numBytes with None->raise (Field_empty "bloomFilterHeader.numBytes") | Some _x322 -> _x322
  method set_numBytes _x322 = _numBytes <- Some _x322
  method unset_numBytes = _numBytes <- None
  method reset_numBytes = _numBytes <- None

  val mutable _algorithm : bloomFilterAlgorithm option = None
  method get_algorithm = _algorithm
  method grab_algorithm = match _algorithm with None->raise (Field_empty "bloomFilterHeader.algorithm") | Some _x323 -> _x323
  method set_algorithm _x323 = _algorithm <- Some _x323
  method unset_algorithm = _algorithm <- None
  method reset_algorithm = _algorithm <- None

  val mutable _hash : bloomFilterHash option = None
  method get_hash = _hash
  method grab_hash = match _hash with None->raise (Field_empty "bloomFilterHeader.hash") | Some _x324 -> _x324
  method set_hash _x324 = _hash <- Some _x324
  method unset_hash = _hash <- None
  method reset_hash = _hash <- None

  val mutable _compression : bloomFilterCompression option = None
  method get_compression = _compression
  method grab_compression = match _compression with None->raise (Field_empty "bloomFilterHeader.compression") | Some _x325 -> _x325
  method set_compression _x325 = _compression <- Some _x325
  method unset_compression = _compression <- None
  method reset_compression = _compression <- None

  method copy =
      let _new = Oo.copy self in
      if _algorithm <> None then
        _new#set_algorithm self#grab_algorithm#copy;
      if _hash <> None then
        _new#set_hash self#grab_hash#copy;
      if _compression <> None then
        _new#set_compression self#grab_compression#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "BloomFilterHeader";
    (match _numBytes with 
    | None -> raise (Field_empty "bloomFilterHeader._numBytes")
    | Some _v -> 
      oprot#writeFieldBegin("numBytes",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _algorithm with 
    | None -> raise (Field_empty "bloomFilterHeader._algorithm")
    | Some _v -> 
      oprot#writeFieldBegin("algorithm",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _hash with 
    | None -> raise (Field_empty "bloomFilterHeader._hash")
    | Some _v -> 
      oprot#writeFieldBegin("hash",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _compression with 
    | None -> raise (Field_empty "bloomFilterHeader._compression")
    | Some _v -> 
      oprot#writeFieldBegin("compression",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_bloomFilterHeader (iprot : Protocol.t) =
  let _str328 = new bloomFilterHeader in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t329,_id330) = iprot#readFieldBegin in
        if _t329 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id330 with 
          | 1 -> (if _t329 = Protocol.T_I32 then
              _str328#set_numBytes iprot#readI32
            else
              iprot#skip _t329)
          | 2 -> (if _t329 = Protocol.T_STRUCT then
              _str328#set_algorithm (read_bloomFilterAlgorithm iprot)
            else
              iprot#skip _t329)
          | 3 -> (if _t329 = Protocol.T_STRUCT then
              _str328#set_hash (read_bloomFilterHash iprot)
            else
              iprot#skip _t329)
          | 4 -> (if _t329 = Protocol.T_STRUCT then
              _str328#set_compression (read_bloomFilterCompression iprot)
            else
              iprot#skip _t329)
          | _ -> iprot#skip _t329);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str328

class pageHeader =
object (self)
  val mutable _type : PageType.t option = None
  method get_type = _type
  method grab_type = match _type with None->raise (Field_empty "pageHeader.type") | Some _x332 -> _x332
  method set_type _x332 = _type <- Some _x332
  method unset_type = _type <- None
  method reset_type = _type <- None

  val mutable _uncompressed_page_size : Int32.t option = None
  method get_uncompressed_page_size = _uncompressed_page_size
  method grab_uncompressed_page_size = match _uncompressed_page_size with None->raise (Field_empty "pageHeader.uncompressed_page_size") | Some _x333 -> _x333
  method set_uncompressed_page_size _x333 = _uncompressed_page_size <- Some _x333
  method unset_uncompressed_page_size = _uncompressed_page_size <- None
  method reset_uncompressed_page_size = _uncompressed_page_size <- None

  val mutable _compressed_page_size : Int32.t option = None
  method get_compressed_page_size = _compressed_page_size
  method grab_compressed_page_size = match _compressed_page_size with None->raise (Field_empty "pageHeader.compressed_page_size") | Some _x334 -> _x334
  method set_compressed_page_size _x334 = _compressed_page_size <- Some _x334
  method unset_compressed_page_size = _compressed_page_size <- None
  method reset_compressed_page_size = _compressed_page_size <- None

  val mutable _crc : Int32.t option = None
  method get_crc = _crc
  method grab_crc = match _crc with None->raise (Field_empty "pageHeader.crc") | Some _x335 -> _x335
  method set_crc _x335 = _crc <- Some _x335
  method unset_crc = _crc <- None
  method reset_crc = _crc <- None

  val mutable _data_page_header : dataPageHeader option = None
  method get_data_page_header = _data_page_header
  method grab_data_page_header = match _data_page_header with None->raise (Field_empty "pageHeader.data_page_header") | Some _x336 -> _x336
  method set_data_page_header _x336 = _data_page_header <- Some _x336
  method unset_data_page_header = _data_page_header <- None
  method reset_data_page_header = _data_page_header <- None

  val mutable _index_page_header : indexPageHeader option = None
  method get_index_page_header = _index_page_header
  method grab_index_page_header = match _index_page_header with None->raise (Field_empty "pageHeader.index_page_header") | Some _x337 -> _x337
  method set_index_page_header _x337 = _index_page_header <- Some _x337
  method unset_index_page_header = _index_page_header <- None
  method reset_index_page_header = _index_page_header <- None

  val mutable _dictionary_page_header : dictionaryPageHeader option = None
  method get_dictionary_page_header = _dictionary_page_header
  method grab_dictionary_page_header = match _dictionary_page_header with None->raise (Field_empty "pageHeader.dictionary_page_header") | Some _x338 -> _x338
  method set_dictionary_page_header _x338 = _dictionary_page_header <- Some _x338
  method unset_dictionary_page_header = _dictionary_page_header <- None
  method reset_dictionary_page_header = _dictionary_page_header <- None

  val mutable _data_page_header_v2 : dataPageHeaderV2 option = None
  method get_data_page_header_v2 = _data_page_header_v2
  method grab_data_page_header_v2 = match _data_page_header_v2 with None->raise (Field_empty "pageHeader.data_page_header_v2") | Some _x339 -> _x339
  method set_data_page_header_v2 _x339 = _data_page_header_v2 <- Some _x339
  method unset_data_page_header_v2 = _data_page_header_v2 <- None
  method reset_data_page_header_v2 = _data_page_header_v2 <- None

  method copy =
      let _new = Oo.copy self in
      if _data_page_header <> None then
        _new#set_data_page_header self#grab_data_page_header#copy;
      if _index_page_header <> None then
        _new#set_index_page_header self#grab_index_page_header#copy;
      if _dictionary_page_header <> None then
        _new#set_dictionary_page_header self#grab_dictionary_page_header#copy;
      if _data_page_header_v2 <> None then
        _new#set_data_page_header_v2 self#grab_data_page_header_v2#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "PageHeader";
    (match _type with 
    | None -> raise (Field_empty "pageHeader._type")
    | Some _v -> 
      oprot#writeFieldBegin("type",Protocol.T_I32,1);
      oprot#writeI32(PageType.to_i _v);
      oprot#writeFieldEnd
    );
    (match _uncompressed_page_size with 
    | None -> raise (Field_empty "pageHeader._uncompressed_page_size")
    | Some _v -> 
      oprot#writeFieldBegin("uncompressed_page_size",Protocol.T_I32,2);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _compressed_page_size with 
    | None -> raise (Field_empty "pageHeader._compressed_page_size")
    | Some _v -> 
      oprot#writeFieldBegin("compressed_page_size",Protocol.T_I32,3);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _crc with None -> () | Some _v -> 
      oprot#writeFieldBegin("crc",Protocol.T_I32,4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _data_page_header with None -> () | Some _v -> 
      oprot#writeFieldBegin("data_page_header",Protocol.T_STRUCT,5);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _index_page_header with None -> () | Some _v -> 
      oprot#writeFieldBegin("index_page_header",Protocol.T_STRUCT,6);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _dictionary_page_header with None -> () | Some _v -> 
      oprot#writeFieldBegin("dictionary_page_header",Protocol.T_STRUCT,7);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _data_page_header_v2 with None -> () | Some _v -> 
      oprot#writeFieldBegin("data_page_header_v2",Protocol.T_STRUCT,8);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_pageHeader (iprot : Protocol.t) =
  let _str342 = new pageHeader in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t343,_id344) = iprot#readFieldBegin in
        if _t343 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id344 with 
          | 1 -> (if _t343 = Protocol.T_I32 then
              _str342#set_type (PageType.of_i iprot#readI32)
            else
              iprot#skip _t343)
          | 2 -> (if _t343 = Protocol.T_I32 then
              _str342#set_uncompressed_page_size iprot#readI32
            else
              iprot#skip _t343)
          | 3 -> (if _t343 = Protocol.T_I32 then
              _str342#set_compressed_page_size iprot#readI32
            else
              iprot#skip _t343)
          | 4 -> (if _t343 = Protocol.T_I32 then
              _str342#set_crc iprot#readI32
            else
              iprot#skip _t343)
          | 5 -> (if _t343 = Protocol.T_STRUCT then
              _str342#set_data_page_header (read_dataPageHeader iprot)
            else
              iprot#skip _t343)
          | 6 -> (if _t343 = Protocol.T_STRUCT then
              _str342#set_index_page_header (read_indexPageHeader iprot)
            else
              iprot#skip _t343)
          | 7 -> (if _t343 = Protocol.T_STRUCT then
              _str342#set_dictionary_page_header (read_dictionaryPageHeader iprot)
            else
              iprot#skip _t343)
          | 8 -> (if _t343 = Protocol.T_STRUCT then
              _str342#set_data_page_header_v2 (read_dataPageHeaderV2 iprot)
            else
              iprot#skip _t343)
          | _ -> iprot#skip _t343);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str342

class keyValue =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "keyValue.key") | Some _x346 -> _x346
  method set_key _x346 = _key <- Some _x346
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _value : string option = None
  method get_value = _value
  method grab_value = match _value with None->raise (Field_empty "keyValue.value") | Some _x347 -> _x347
  method set_value _x347 = _value <- Some _x347
  method unset_value = _value <- None
  method reset_value = _value <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "KeyValue";
    (match _key with 
    | None -> raise (Field_empty "keyValue._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _value with None -> () | Some _v -> 
      oprot#writeFieldBegin("value",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_keyValue (iprot : Protocol.t) =
  let _str350 = new keyValue in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t351,_id352) = iprot#readFieldBegin in
        if _t351 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id352 with 
          | 1 -> (if _t351 = Protocol.T_STRING then
              _str350#set_key iprot#readString
            else
              iprot#skip _t351)
          | 2 -> (if _t351 = Protocol.T_STRING then
              _str350#set_value iprot#readString
            else
              iprot#skip _t351)
          | _ -> iprot#skip _t351);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str350

class sortingColumn =
object (self)
  val mutable _column_idx : Int32.t option = None
  method get_column_idx = _column_idx
  method grab_column_idx = match _column_idx with None->raise (Field_empty "sortingColumn.column_idx") | Some _x354 -> _x354
  method set_column_idx _x354 = _column_idx <- Some _x354
  method unset_column_idx = _column_idx <- None
  method reset_column_idx = _column_idx <- None

  val mutable _descending : bool option = None
  method get_descending = _descending
  method grab_descending = match _descending with None->raise (Field_empty "sortingColumn.descending") | Some _x355 -> _x355
  method set_descending _x355 = _descending <- Some _x355
  method unset_descending = _descending <- None
  method reset_descending = _descending <- None

  val mutable _nulls_first : bool option = None
  method get_nulls_first = _nulls_first
  method grab_nulls_first = match _nulls_first with None->raise (Field_empty "sortingColumn.nulls_first") | Some _x356 -> _x356
  method set_nulls_first _x356 = _nulls_first <- Some _x356
  method unset_nulls_first = _nulls_first <- None
  method reset_nulls_first = _nulls_first <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SortingColumn";
    (match _column_idx with 
    | None -> raise (Field_empty "sortingColumn._column_idx")
    | Some _v -> 
      oprot#writeFieldBegin("column_idx",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _descending with 
    | None -> raise (Field_empty "sortingColumn._descending")
    | Some _v -> 
      oprot#writeFieldBegin("descending",Protocol.T_BOOL,2);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    (match _nulls_first with 
    | None -> raise (Field_empty "sortingColumn._nulls_first")
    | Some _v -> 
      oprot#writeFieldBegin("nulls_first",Protocol.T_BOOL,3);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_sortingColumn (iprot : Protocol.t) =
  let _str359 = new sortingColumn in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t360,_id361) = iprot#readFieldBegin in
        if _t360 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id361 with 
          | 1 -> (if _t360 = Protocol.T_I32 then
              _str359#set_column_idx iprot#readI32
            else
              iprot#skip _t360)
          | 2 -> (if _t360 = Protocol.T_BOOL then
              _str359#set_descending iprot#readBool
            else
              iprot#skip _t360)
          | 3 -> (if _t360 = Protocol.T_BOOL then
              _str359#set_nulls_first iprot#readBool
            else
              iprot#skip _t360)
          | _ -> iprot#skip _t360);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str359

class pageEncodingStats =
object (self)
  val mutable _page_type : PageType.t option = None
  method get_page_type = _page_type
  method grab_page_type = match _page_type with None->raise (Field_empty "pageEncodingStats.page_type") | Some _x363 -> _x363
  method set_page_type _x363 = _page_type <- Some _x363
  method unset_page_type = _page_type <- None
  method reset_page_type = _page_type <- None

  val mutable _encoding : Encoding.t option = None
  method get_encoding = _encoding
  method grab_encoding = match _encoding with None->raise (Field_empty "pageEncodingStats.encoding") | Some _x364 -> _x364
  method set_encoding _x364 = _encoding <- Some _x364
  method unset_encoding = _encoding <- None
  method reset_encoding = _encoding <- None

  val mutable _count : Int32.t option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "pageEncodingStats.count") | Some _x365 -> _x365
  method set_count _x365 = _count <- Some _x365
  method unset_count = _count <- None
  method reset_count = _count <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "PageEncodingStats";
    (match _page_type with 
    | None -> raise (Field_empty "pageEncodingStats._page_type")
    | Some _v -> 
      oprot#writeFieldBegin("page_type",Protocol.T_I32,1);
      oprot#writeI32(PageType.to_i _v);
      oprot#writeFieldEnd
    );
    (match _encoding with 
    | None -> raise (Field_empty "pageEncodingStats._encoding")
    | Some _v -> 
      oprot#writeFieldBegin("encoding",Protocol.T_I32,2);
      oprot#writeI32(Encoding.to_i _v);
      oprot#writeFieldEnd
    );
    (match _count with 
    | None -> raise (Field_empty "pageEncodingStats._count")
    | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,3);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_pageEncodingStats (iprot : Protocol.t) =
  let _str368 = new pageEncodingStats in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t369,_id370) = iprot#readFieldBegin in
        if _t369 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id370 with 
          | 1 -> (if _t369 = Protocol.T_I32 then
              _str368#set_page_type (PageType.of_i iprot#readI32)
            else
              iprot#skip _t369)
          | 2 -> (if _t369 = Protocol.T_I32 then
              _str368#set_encoding (Encoding.of_i iprot#readI32)
            else
              iprot#skip _t369)
          | 3 -> (if _t369 = Protocol.T_I32 then
              _str368#set_count iprot#readI32
            else
              iprot#skip _t369)
          | _ -> iprot#skip _t369);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str368

class columnMetaData =
object (self)
  val mutable _type : Type.t option = None
  method get_type = _type
  method grab_type = match _type with None->raise (Field_empty "columnMetaData.type") | Some _x372 -> _x372
  method set_type _x372 = _type <- Some _x372
  method unset_type = _type <- None
  method reset_type = _type <- None

  val mutable _encodings : Encoding.t list option = None
  method get_encodings = _encodings
  method grab_encodings = match _encodings with None->raise (Field_empty "columnMetaData.encodings") | Some _x373 -> _x373
  method set_encodings _x373 = _encodings <- Some _x373
  method unset_encodings = _encodings <- None
  method reset_encodings = _encodings <- None

  val mutable _path_in_schema : string list option = None
  method get_path_in_schema = _path_in_schema
  method grab_path_in_schema = match _path_in_schema with None->raise (Field_empty "columnMetaData.path_in_schema") | Some _x374 -> _x374
  method set_path_in_schema _x374 = _path_in_schema <- Some _x374
  method unset_path_in_schema = _path_in_schema <- None
  method reset_path_in_schema = _path_in_schema <- None

  val mutable _codec : CompressionCodec.t option = None
  method get_codec = _codec
  method grab_codec = match _codec with None->raise (Field_empty "columnMetaData.codec") | Some _x375 -> _x375
  method set_codec _x375 = _codec <- Some _x375
  method unset_codec = _codec <- None
  method reset_codec = _codec <- None

  val mutable _num_values : Int64.t option = None
  method get_num_values = _num_values
  method grab_num_values = match _num_values with None->raise (Field_empty "columnMetaData.num_values") | Some _x376 -> _x376
  method set_num_values _x376 = _num_values <- Some _x376
  method unset_num_values = _num_values <- None
  method reset_num_values = _num_values <- None

  val mutable _total_uncompressed_size : Int64.t option = None
  method get_total_uncompressed_size = _total_uncompressed_size
  method grab_total_uncompressed_size = match _total_uncompressed_size with None->raise (Field_empty "columnMetaData.total_uncompressed_size") | Some _x377 -> _x377
  method set_total_uncompressed_size _x377 = _total_uncompressed_size <- Some _x377
  method unset_total_uncompressed_size = _total_uncompressed_size <- None
  method reset_total_uncompressed_size = _total_uncompressed_size <- None

  val mutable _total_compressed_size : Int64.t option = None
  method get_total_compressed_size = _total_compressed_size
  method grab_total_compressed_size = match _total_compressed_size with None->raise (Field_empty "columnMetaData.total_compressed_size") | Some _x378 -> _x378
  method set_total_compressed_size _x378 = _total_compressed_size <- Some _x378
  method unset_total_compressed_size = _total_compressed_size <- None
  method reset_total_compressed_size = _total_compressed_size <- None

  val mutable _key_value_metadata : keyValue list option = None
  method get_key_value_metadata = _key_value_metadata
  method grab_key_value_metadata = match _key_value_metadata with None->raise (Field_empty "columnMetaData.key_value_metadata") | Some _x379 -> _x379
  method set_key_value_metadata _x379 = _key_value_metadata <- Some _x379
  method unset_key_value_metadata = _key_value_metadata <- None
  method reset_key_value_metadata = _key_value_metadata <- None

  val mutable _data_page_offset : Int64.t option = None
  method get_data_page_offset = _data_page_offset
  method grab_data_page_offset = match _data_page_offset with None->raise (Field_empty "columnMetaData.data_page_offset") | Some _x380 -> _x380
  method set_data_page_offset _x380 = _data_page_offset <- Some _x380
  method unset_data_page_offset = _data_page_offset <- None
  method reset_data_page_offset = _data_page_offset <- None

  val mutable _index_page_offset : Int64.t option = None
  method get_index_page_offset = _index_page_offset
  method grab_index_page_offset = match _index_page_offset with None->raise (Field_empty "columnMetaData.index_page_offset") | Some _x381 -> _x381
  method set_index_page_offset _x381 = _index_page_offset <- Some _x381
  method unset_index_page_offset = _index_page_offset <- None
  method reset_index_page_offset = _index_page_offset <- None

  val mutable _dictionary_page_offset : Int64.t option = None
  method get_dictionary_page_offset = _dictionary_page_offset
  method grab_dictionary_page_offset = match _dictionary_page_offset with None->raise (Field_empty "columnMetaData.dictionary_page_offset") | Some _x382 -> _x382
  method set_dictionary_page_offset _x382 = _dictionary_page_offset <- Some _x382
  method unset_dictionary_page_offset = _dictionary_page_offset <- None
  method reset_dictionary_page_offset = _dictionary_page_offset <- None

  val mutable _statistics : statistics option = None
  method get_statistics = _statistics
  method grab_statistics = match _statistics with None->raise (Field_empty "columnMetaData.statistics") | Some _x383 -> _x383
  method set_statistics _x383 = _statistics <- Some _x383
  method unset_statistics = _statistics <- None
  method reset_statistics = _statistics <- None

  val mutable _encoding_stats : pageEncodingStats list option = None
  method get_encoding_stats = _encoding_stats
  method grab_encoding_stats = match _encoding_stats with None->raise (Field_empty "columnMetaData.encoding_stats") | Some _x384 -> _x384
  method set_encoding_stats _x384 = _encoding_stats <- Some _x384
  method unset_encoding_stats = _encoding_stats <- None
  method reset_encoding_stats = _encoding_stats <- None

  val mutable _bloom_filter_offset : Int64.t option = None
  method get_bloom_filter_offset = _bloom_filter_offset
  method grab_bloom_filter_offset = match _bloom_filter_offset with None->raise (Field_empty "columnMetaData.bloom_filter_offset") | Some _x385 -> _x385
  method set_bloom_filter_offset _x385 = _bloom_filter_offset <- Some _x385
  method unset_bloom_filter_offset = _bloom_filter_offset <- None
  method reset_bloom_filter_offset = _bloom_filter_offset <- None

  val mutable _bloom_filter_length : Int32.t option = None
  method get_bloom_filter_length = _bloom_filter_length
  method grab_bloom_filter_length = match _bloom_filter_length with None->raise (Field_empty "columnMetaData.bloom_filter_length") | Some _x386 -> _x386
  method set_bloom_filter_length _x386 = _bloom_filter_length <- Some _x386
  method unset_bloom_filter_length = _bloom_filter_length <- None
  method reset_bloom_filter_length = _bloom_filter_length <- None

  val mutable _size_statistics : sizeStatistics option = None
  method get_size_statistics = _size_statistics
  method grab_size_statistics = match _size_statistics with None->raise (Field_empty "columnMetaData.size_statistics") | Some _x387 -> _x387
  method set_size_statistics _x387 = _size_statistics <- Some _x387
  method unset_size_statistics = _size_statistics <- None
  method reset_size_statistics = _size_statistics <- None

  val mutable _geospatial_statistics : geospatialStatistics option = None
  method get_geospatial_statistics = _geospatial_statistics
  method grab_geospatial_statistics = match _geospatial_statistics with None->raise (Field_empty "columnMetaData.geospatial_statistics") | Some _x388 -> _x388
  method set_geospatial_statistics _x388 = _geospatial_statistics <- Some _x388
  method unset_geospatial_statistics = _geospatial_statistics <- None
  method reset_geospatial_statistics = _geospatial_statistics <- None

  method copy =
      let _new = Oo.copy self in
      if _key_value_metadata <> None then
        _new#set_key_value_metadata (List.map (fun x -> x#copy) self#grab_key_value_metadata);
      if _statistics <> None then
        _new#set_statistics self#grab_statistics#copy;
      if _encoding_stats <> None then
        _new#set_encoding_stats (List.map (fun x -> x#copy) self#grab_encoding_stats);
      if _size_statistics <> None then
        _new#set_size_statistics self#grab_size_statistics#copy;
      if _geospatial_statistics <> None then
        _new#set_geospatial_statistics self#grab_geospatial_statistics#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnMetaData";
    (match _type with 
    | None -> raise (Field_empty "columnMetaData._type")
    | Some _v -> 
      oprot#writeFieldBegin("type",Protocol.T_I32,1);
      oprot#writeI32(Type.to_i _v);
      oprot#writeFieldEnd
    );
    (match _encodings with 
    | None -> raise (Field_empty "columnMetaData._encodings")
    | Some _v -> 
      oprot#writeFieldBegin("encodings",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_I32,List.length _v);
      List.iter (fun _iter391 ->         oprot#writeI32(Encoding.to_i _iter391);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _path_in_schema with 
    | None -> raise (Field_empty "columnMetaData._path_in_schema")
    | Some _v -> 
      oprot#writeFieldBegin("path_in_schema",Protocol.T_LIST,3);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter392 ->         oprot#writeString(_iter392);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _codec with 
    | None -> raise (Field_empty "columnMetaData._codec")
    | Some _v -> 
      oprot#writeFieldBegin("codec",Protocol.T_I32,4);
      oprot#writeI32(CompressionCodec.to_i _v);
      oprot#writeFieldEnd
    );
    (match _num_values with 
    | None -> raise (Field_empty "columnMetaData._num_values")
    | Some _v -> 
      oprot#writeFieldBegin("num_values",Protocol.T_I64,5);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _total_uncompressed_size with 
    | None -> raise (Field_empty "columnMetaData._total_uncompressed_size")
    | Some _v -> 
      oprot#writeFieldBegin("total_uncompressed_size",Protocol.T_I64,6);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _total_compressed_size with 
    | None -> raise (Field_empty "columnMetaData._total_compressed_size")
    | Some _v -> 
      oprot#writeFieldBegin("total_compressed_size",Protocol.T_I64,7);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _key_value_metadata with None -> () | Some _v -> 
      oprot#writeFieldBegin("key_value_metadata",Protocol.T_LIST,8);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter393 ->         _iter393#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _data_page_offset with 
    | None -> raise (Field_empty "columnMetaData._data_page_offset")
    | Some _v -> 
      oprot#writeFieldBegin("data_page_offset",Protocol.T_I64,9);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _index_page_offset with None -> () | Some _v -> 
      oprot#writeFieldBegin("index_page_offset",Protocol.T_I64,10);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _dictionary_page_offset with None -> () | Some _v -> 
      oprot#writeFieldBegin("dictionary_page_offset",Protocol.T_I64,11);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _statistics with None -> () | Some _v -> 
      oprot#writeFieldBegin("statistics",Protocol.T_STRUCT,12);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _encoding_stats with None -> () | Some _v -> 
      oprot#writeFieldBegin("encoding_stats",Protocol.T_LIST,13);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter394 ->         _iter394#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _bloom_filter_offset with None -> () | Some _v -> 
      oprot#writeFieldBegin("bloom_filter_offset",Protocol.T_I64,14);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _bloom_filter_length with None -> () | Some _v -> 
      oprot#writeFieldBegin("bloom_filter_length",Protocol.T_I32,15);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _size_statistics with None -> () | Some _v -> 
      oprot#writeFieldBegin("size_statistics",Protocol.T_STRUCT,16);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _geospatial_statistics with None -> () | Some _v -> 
      oprot#writeFieldBegin("geospatial_statistics",Protocol.T_STRUCT,17);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnMetaData (iprot : Protocol.t) =
  let _str395 = new columnMetaData in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t396,_id397) = iprot#readFieldBegin in
        if _t396 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id397 with 
          | 1 -> (if _t396 = Protocol.T_I32 then
              _str395#set_type (Type.of_i iprot#readI32)
            else
              iprot#skip _t396)
          | 2 -> (if _t396 = Protocol.T_LIST then
              _str395#set_encodings 
                (let (_etype401,_size398) = iprot#readListBegin in
                  let _con402 = (Array.to_list (Array.init _size398 (fun _ -> (Encoding.of_i iprot#readI32)))) in
                    iprot#readListEnd; _con402)
            else
              iprot#skip _t396)
          | 3 -> (if _t396 = Protocol.T_LIST then
              _str395#set_path_in_schema 
                (let (_etype406,_size403) = iprot#readListBegin in
                  let _con407 = (Array.to_list (Array.init _size403 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con407)
            else
              iprot#skip _t396)
          | 4 -> (if _t396 = Protocol.T_I32 then
              _str395#set_codec (CompressionCodec.of_i iprot#readI32)
            else
              iprot#skip _t396)
          | 5 -> (if _t396 = Protocol.T_I64 then
              _str395#set_num_values iprot#readI64
            else
              iprot#skip _t396)
          | 6 -> (if _t396 = Protocol.T_I64 then
              _str395#set_total_uncompressed_size iprot#readI64
            else
              iprot#skip _t396)
          | 7 -> (if _t396 = Protocol.T_I64 then
              _str395#set_total_compressed_size iprot#readI64
            else
              iprot#skip _t396)
          | 8 -> (if _t396 = Protocol.T_LIST then
              _str395#set_key_value_metadata 
                (let (_etype411,_size408) = iprot#readListBegin in
                  let _con412 = (Array.to_list (Array.init _size408 (fun _ -> (read_keyValue iprot)))) in
                    iprot#readListEnd; _con412)
            else
              iprot#skip _t396)
          | 9 -> (if _t396 = Protocol.T_I64 then
              _str395#set_data_page_offset iprot#readI64
            else
              iprot#skip _t396)
          | 10 -> (if _t396 = Protocol.T_I64 then
              _str395#set_index_page_offset iprot#readI64
            else
              iprot#skip _t396)
          | 11 -> (if _t396 = Protocol.T_I64 then
              _str395#set_dictionary_page_offset iprot#readI64
            else
              iprot#skip _t396)
          | 12 -> (if _t396 = Protocol.T_STRUCT then
              _str395#set_statistics (read_statistics iprot)
            else
              iprot#skip _t396)
          | 13 -> (if _t396 = Protocol.T_LIST then
              _str395#set_encoding_stats 
                (let (_etype416,_size413) = iprot#readListBegin in
                  let _con417 = (Array.to_list (Array.init _size413 (fun _ -> (read_pageEncodingStats iprot)))) in
                    iprot#readListEnd; _con417)
            else
              iprot#skip _t396)
          | 14 -> (if _t396 = Protocol.T_I64 then
              _str395#set_bloom_filter_offset iprot#readI64
            else
              iprot#skip _t396)
          | 15 -> (if _t396 = Protocol.T_I32 then
              _str395#set_bloom_filter_length iprot#readI32
            else
              iprot#skip _t396)
          | 16 -> (if _t396 = Protocol.T_STRUCT then
              _str395#set_size_statistics (read_sizeStatistics iprot)
            else
              iprot#skip _t396)
          | 17 -> (if _t396 = Protocol.T_STRUCT then
              _str395#set_geospatial_statistics (read_geospatialStatistics iprot)
            else
              iprot#skip _t396)
          | _ -> iprot#skip _t396);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str395

class encryptionWithFooterKey =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "EncryptionWithFooterKey";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_encryptionWithFooterKey (iprot : Protocol.t) =
  let _str421 = new encryptionWithFooterKey in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t422,_id423) = iprot#readFieldBegin in
        if _t422 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id423 with 
          | _ -> iprot#skip _t422);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str421

class encryptionWithColumnKey =
object (self)
  val mutable _path_in_schema : string list option = None
  method get_path_in_schema = _path_in_schema
  method grab_path_in_schema = match _path_in_schema with None->raise (Field_empty "encryptionWithColumnKey.path_in_schema") | Some _x425 -> _x425
  method set_path_in_schema _x425 = _path_in_schema <- Some _x425
  method unset_path_in_schema = _path_in_schema <- None
  method reset_path_in_schema = _path_in_schema <- None

  val mutable _key_metadata : string option = None
  method get_key_metadata = _key_metadata
  method grab_key_metadata = match _key_metadata with None->raise (Field_empty "encryptionWithColumnKey.key_metadata") | Some _x426 -> _x426
  method set_key_metadata _x426 = _key_metadata <- Some _x426
  method unset_key_metadata = _key_metadata <- None
  method reset_key_metadata = _key_metadata <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "EncryptionWithColumnKey";
    (match _path_in_schema with 
    | None -> raise (Field_empty "encryptionWithColumnKey._path_in_schema")
    | Some _v -> 
      oprot#writeFieldBegin("path_in_schema",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter429 ->         oprot#writeString(_iter429);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _key_metadata with None -> () | Some _v -> 
      oprot#writeFieldBegin("key_metadata",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_encryptionWithColumnKey (iprot : Protocol.t) =
  let _str430 = new encryptionWithColumnKey in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t431,_id432) = iprot#readFieldBegin in
        if _t431 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id432 with 
          | 1 -> (if _t431 = Protocol.T_LIST then
              _str430#set_path_in_schema 
                (let (_etype436,_size433) = iprot#readListBegin in
                  let _con437 = (Array.to_list (Array.init _size433 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con437)
            else
              iprot#skip _t431)
          | 2 -> (if _t431 = Protocol.T_STRING then
              _str430#set_key_metadata iprot#readString
            else
              iprot#skip _t431)
          | _ -> iprot#skip _t431);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str430

class columnCryptoMetaData =
object (self)
  val mutable _eNCRYPTION_WITH_FOOTER_KEY : encryptionWithFooterKey option = None
  method get_eNCRYPTION_WITH_FOOTER_KEY = _eNCRYPTION_WITH_FOOTER_KEY
  method grab_eNCRYPTION_WITH_FOOTER_KEY = match _eNCRYPTION_WITH_FOOTER_KEY with None->raise (Field_empty "columnCryptoMetaData.eNCRYPTION_WITH_FOOTER_KEY") | Some _x439 -> _x439
  method set_eNCRYPTION_WITH_FOOTER_KEY _x439 = _eNCRYPTION_WITH_FOOTER_KEY <- Some _x439
  method unset_eNCRYPTION_WITH_FOOTER_KEY = _eNCRYPTION_WITH_FOOTER_KEY <- None
  method reset_eNCRYPTION_WITH_FOOTER_KEY = _eNCRYPTION_WITH_FOOTER_KEY <- None

  val mutable _eNCRYPTION_WITH_COLUMN_KEY : encryptionWithColumnKey option = None
  method get_eNCRYPTION_WITH_COLUMN_KEY = _eNCRYPTION_WITH_COLUMN_KEY
  method grab_eNCRYPTION_WITH_COLUMN_KEY = match _eNCRYPTION_WITH_COLUMN_KEY with None->raise (Field_empty "columnCryptoMetaData.eNCRYPTION_WITH_COLUMN_KEY") | Some _x440 -> _x440
  method set_eNCRYPTION_WITH_COLUMN_KEY _x440 = _eNCRYPTION_WITH_COLUMN_KEY <- Some _x440
  method unset_eNCRYPTION_WITH_COLUMN_KEY = _eNCRYPTION_WITH_COLUMN_KEY <- None
  method reset_eNCRYPTION_WITH_COLUMN_KEY = _eNCRYPTION_WITH_COLUMN_KEY <- None

  method copy =
      let _new = Oo.copy self in
      if _eNCRYPTION_WITH_FOOTER_KEY <> None then
        _new#set_eNCRYPTION_WITH_FOOTER_KEY self#grab_eNCRYPTION_WITH_FOOTER_KEY#copy;
      if _eNCRYPTION_WITH_COLUMN_KEY <> None then
        _new#set_eNCRYPTION_WITH_COLUMN_KEY self#grab_eNCRYPTION_WITH_COLUMN_KEY#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnCryptoMetaData";
    (match _eNCRYPTION_WITH_FOOTER_KEY with None -> () | Some _v -> 
      oprot#writeFieldBegin("ENCRYPTION_WITH_FOOTER_KEY",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _eNCRYPTION_WITH_COLUMN_KEY with None -> () | Some _v -> 
      oprot#writeFieldBegin("ENCRYPTION_WITH_COLUMN_KEY",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnCryptoMetaData (iprot : Protocol.t) =
  let _str443 = new columnCryptoMetaData in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t444,_id445) = iprot#readFieldBegin in
        if _t444 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id445 with 
          | 1 -> (if _t444 = Protocol.T_STRUCT then
              _str443#set_eNCRYPTION_WITH_FOOTER_KEY (read_encryptionWithFooterKey iprot)
            else
              iprot#skip _t444)
          | 2 -> (if _t444 = Protocol.T_STRUCT then
              _str443#set_eNCRYPTION_WITH_COLUMN_KEY (read_encryptionWithColumnKey iprot)
            else
              iprot#skip _t444)
          | _ -> iprot#skip _t444);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str443

class columnChunk =
object (self)
  val mutable _file_path : string option = None
  method get_file_path = _file_path
  method grab_file_path = match _file_path with None->raise (Field_empty "columnChunk.file_path") | Some _x447 -> _x447
  method set_file_path _x447 = _file_path <- Some _x447
  method unset_file_path = _file_path <- None
  method reset_file_path = _file_path <- None

  val mutable _file_offset : Int64.t = 0L
  method get_file_offset = Some _file_offset
  method grab_file_offset = _file_offset
  method set_file_offset _x448 = _file_offset <- _x448
  method reset_file_offset = _file_offset <- 0L

  val mutable _meta_data : columnMetaData option = None
  method get_meta_data = _meta_data
  method grab_meta_data = match _meta_data with None->raise (Field_empty "columnChunk.meta_data") | Some _x449 -> _x449
  method set_meta_data _x449 = _meta_data <- Some _x449
  method unset_meta_data = _meta_data <- None
  method reset_meta_data = _meta_data <- None

  val mutable _offset_index_offset : Int64.t option = None
  method get_offset_index_offset = _offset_index_offset
  method grab_offset_index_offset = match _offset_index_offset with None->raise (Field_empty "columnChunk.offset_index_offset") | Some _x450 -> _x450
  method set_offset_index_offset _x450 = _offset_index_offset <- Some _x450
  method unset_offset_index_offset = _offset_index_offset <- None
  method reset_offset_index_offset = _offset_index_offset <- None

  val mutable _offset_index_length : Int32.t option = None
  method get_offset_index_length = _offset_index_length
  method grab_offset_index_length = match _offset_index_length with None->raise (Field_empty "columnChunk.offset_index_length") | Some _x451 -> _x451
  method set_offset_index_length _x451 = _offset_index_length <- Some _x451
  method unset_offset_index_length = _offset_index_length <- None
  method reset_offset_index_length = _offset_index_length <- None

  val mutable _column_index_offset : Int64.t option = None
  method get_column_index_offset = _column_index_offset
  method grab_column_index_offset = match _column_index_offset with None->raise (Field_empty "columnChunk.column_index_offset") | Some _x452 -> _x452
  method set_column_index_offset _x452 = _column_index_offset <- Some _x452
  method unset_column_index_offset = _column_index_offset <- None
  method reset_column_index_offset = _column_index_offset <- None

  val mutable _column_index_length : Int32.t option = None
  method get_column_index_length = _column_index_length
  method grab_column_index_length = match _column_index_length with None->raise (Field_empty "columnChunk.column_index_length") | Some _x453 -> _x453
  method set_column_index_length _x453 = _column_index_length <- Some _x453
  method unset_column_index_length = _column_index_length <- None
  method reset_column_index_length = _column_index_length <- None

  val mutable _crypto_metadata : columnCryptoMetaData option = None
  method get_crypto_metadata = _crypto_metadata
  method grab_crypto_metadata = match _crypto_metadata with None->raise (Field_empty "columnChunk.crypto_metadata") | Some _x454 -> _x454
  method set_crypto_metadata _x454 = _crypto_metadata <- Some _x454
  method unset_crypto_metadata = _crypto_metadata <- None
  method reset_crypto_metadata = _crypto_metadata <- None

  val mutable _encrypted_column_metadata : string option = None
  method get_encrypted_column_metadata = _encrypted_column_metadata
  method grab_encrypted_column_metadata = match _encrypted_column_metadata with None->raise (Field_empty "columnChunk.encrypted_column_metadata") | Some _x455 -> _x455
  method set_encrypted_column_metadata _x455 = _encrypted_column_metadata <- Some _x455
  method unset_encrypted_column_metadata = _encrypted_column_metadata <- None
  method reset_encrypted_column_metadata = _encrypted_column_metadata <- None

  method copy =
      let _new = Oo.copy self in
      if _meta_data <> None then
        _new#set_meta_data self#grab_meta_data#copy;
      if _crypto_metadata <> None then
        _new#set_crypto_metadata self#grab_crypto_metadata#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnChunk";
    (match _file_path with None -> () | Some _v -> 
      oprot#writeFieldBegin("file_path",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("file_offset",Protocol.T_I64,2);
      oprot#writeI64(_file_offset);
      oprot#writeFieldEnd
    );
    (match _meta_data with None -> () | Some _v -> 
      oprot#writeFieldBegin("meta_data",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _offset_index_offset with None -> () | Some _v -> 
      oprot#writeFieldBegin("offset_index_offset",Protocol.T_I64,4);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _offset_index_length with None -> () | Some _v -> 
      oprot#writeFieldBegin("offset_index_length",Protocol.T_I32,5);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _column_index_offset with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_index_offset",Protocol.T_I64,6);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _column_index_length with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_index_length",Protocol.T_I32,7);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _crypto_metadata with None -> () | Some _v -> 
      oprot#writeFieldBegin("crypto_metadata",Protocol.T_STRUCT,8);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _encrypted_column_metadata with None -> () | Some _v -> 
      oprot#writeFieldBegin("encrypted_column_metadata",Protocol.T_STRING,9);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnChunk (iprot : Protocol.t) =
  let _str458 = new columnChunk in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t459,_id460) = iprot#readFieldBegin in
        if _t459 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id460 with 
          | 1 -> (if _t459 = Protocol.T_STRING then
              _str458#set_file_path iprot#readString
            else
              iprot#skip _t459)
          | 2 -> (if _t459 = Protocol.T_I64 then
              _str458#set_file_offset iprot#readI64
            else
              iprot#skip _t459)
          | 3 -> (if _t459 = Protocol.T_STRUCT then
              _str458#set_meta_data (read_columnMetaData iprot)
            else
              iprot#skip _t459)
          | 4 -> (if _t459 = Protocol.T_I64 then
              _str458#set_offset_index_offset iprot#readI64
            else
              iprot#skip _t459)
          | 5 -> (if _t459 = Protocol.T_I32 then
              _str458#set_offset_index_length iprot#readI32
            else
              iprot#skip _t459)
          | 6 -> (if _t459 = Protocol.T_I64 then
              _str458#set_column_index_offset iprot#readI64
            else
              iprot#skip _t459)
          | 7 -> (if _t459 = Protocol.T_I32 then
              _str458#set_column_index_length iprot#readI32
            else
              iprot#skip _t459)
          | 8 -> (if _t459 = Protocol.T_STRUCT then
              _str458#set_crypto_metadata (read_columnCryptoMetaData iprot)
            else
              iprot#skip _t459)
          | 9 -> (if _t459 = Protocol.T_STRING then
              _str458#set_encrypted_column_metadata iprot#readString
            else
              iprot#skip _t459)
          | _ -> iprot#skip _t459);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str458

class rowGroup =
object (self)
  val mutable _columns : columnChunk list option = None
  method get_columns = _columns
  method grab_columns = match _columns with None->raise (Field_empty "rowGroup.columns") | Some _x462 -> _x462
  method set_columns _x462 = _columns <- Some _x462
  method unset_columns = _columns <- None
  method reset_columns = _columns <- None

  val mutable _total_byte_size : Int64.t option = None
  method get_total_byte_size = _total_byte_size
  method grab_total_byte_size = match _total_byte_size with None->raise (Field_empty "rowGroup.total_byte_size") | Some _x463 -> _x463
  method set_total_byte_size _x463 = _total_byte_size <- Some _x463
  method unset_total_byte_size = _total_byte_size <- None
  method reset_total_byte_size = _total_byte_size <- None

  val mutable _num_rows : Int64.t option = None
  method get_num_rows = _num_rows
  method grab_num_rows = match _num_rows with None->raise (Field_empty "rowGroup.num_rows") | Some _x464 -> _x464
  method set_num_rows _x464 = _num_rows <- Some _x464
  method unset_num_rows = _num_rows <- None
  method reset_num_rows = _num_rows <- None

  val mutable _sorting_columns : sortingColumn list option = None
  method get_sorting_columns = _sorting_columns
  method grab_sorting_columns = match _sorting_columns with None->raise (Field_empty "rowGroup.sorting_columns") | Some _x465 -> _x465
  method set_sorting_columns _x465 = _sorting_columns <- Some _x465
  method unset_sorting_columns = _sorting_columns <- None
  method reset_sorting_columns = _sorting_columns <- None

  val mutable _file_offset : Int64.t option = None
  method get_file_offset = _file_offset
  method grab_file_offset = match _file_offset with None->raise (Field_empty "rowGroup.file_offset") | Some _x466 -> _x466
  method set_file_offset _x466 = _file_offset <- Some _x466
  method unset_file_offset = _file_offset <- None
  method reset_file_offset = _file_offset <- None

  val mutable _total_compressed_size : Int64.t option = None
  method get_total_compressed_size = _total_compressed_size
  method grab_total_compressed_size = match _total_compressed_size with None->raise (Field_empty "rowGroup.total_compressed_size") | Some _x467 -> _x467
  method set_total_compressed_size _x467 = _total_compressed_size <- Some _x467
  method unset_total_compressed_size = _total_compressed_size <- None
  method reset_total_compressed_size = _total_compressed_size <- None

  val mutable _ordinal : int option = None
  method get_ordinal = _ordinal
  method grab_ordinal = match _ordinal with None->raise (Field_empty "rowGroup.ordinal") | Some _x468 -> _x468
  method set_ordinal _x468 = _ordinal <- Some _x468
  method unset_ordinal = _ordinal <- None
  method reset_ordinal = _ordinal <- None

  method copy =
      let _new = Oo.copy self in
      if _columns <> None then
        _new#set_columns (List.map (fun x -> x#copy) self#grab_columns);
      if _sorting_columns <> None then
        _new#set_sorting_columns (List.map (fun x -> x#copy) self#grab_sorting_columns);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "RowGroup";
    (match _columns with 
    | None -> raise (Field_empty "rowGroup._columns")
    | Some _v -> 
      oprot#writeFieldBegin("columns",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter471 ->         _iter471#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _total_byte_size with 
    | None -> raise (Field_empty "rowGroup._total_byte_size")
    | Some _v -> 
      oprot#writeFieldBegin("total_byte_size",Protocol.T_I64,2);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _num_rows with 
    | None -> raise (Field_empty "rowGroup._num_rows")
    | Some _v -> 
      oprot#writeFieldBegin("num_rows",Protocol.T_I64,3);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _sorting_columns with None -> () | Some _v -> 
      oprot#writeFieldBegin("sorting_columns",Protocol.T_LIST,4);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter472 ->         _iter472#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _file_offset with None -> () | Some _v -> 
      oprot#writeFieldBegin("file_offset",Protocol.T_I64,5);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _total_compressed_size with None -> () | Some _v -> 
      oprot#writeFieldBegin("total_compressed_size",Protocol.T_I64,6);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _ordinal with None -> () | Some _v -> 
      oprot#writeFieldBegin("ordinal",Protocol.T_I16,7);
      oprot#writeI16(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_rowGroup (iprot : Protocol.t) =
  let _str473 = new rowGroup in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t474,_id475) = iprot#readFieldBegin in
        if _t474 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id475 with 
          | 1 -> (if _t474 = Protocol.T_LIST then
              _str473#set_columns 
                (let (_etype479,_size476) = iprot#readListBegin in
                  let _con480 = (Array.to_list (Array.init _size476 (fun _ -> (read_columnChunk iprot)))) in
                    iprot#readListEnd; _con480)
            else
              iprot#skip _t474)
          | 2 -> (if _t474 = Protocol.T_I64 then
              _str473#set_total_byte_size iprot#readI64
            else
              iprot#skip _t474)
          | 3 -> (if _t474 = Protocol.T_I64 then
              _str473#set_num_rows iprot#readI64
            else
              iprot#skip _t474)
          | 4 -> (if _t474 = Protocol.T_LIST then
              _str473#set_sorting_columns 
                (let (_etype484,_size481) = iprot#readListBegin in
                  let _con485 = (Array.to_list (Array.init _size481 (fun _ -> (read_sortingColumn iprot)))) in
                    iprot#readListEnd; _con485)
            else
              iprot#skip _t474)
          | 5 -> (if _t474 = Protocol.T_I64 then
              _str473#set_file_offset iprot#readI64
            else
              iprot#skip _t474)
          | 6 -> (if _t474 = Protocol.T_I64 then
              _str473#set_total_compressed_size iprot#readI64
            else
              iprot#skip _t474)
          | 7 -> (if _t474 = Protocol.T_I16 then
              _str473#set_ordinal iprot#readI16
            else
              iprot#skip _t474)
          | _ -> iprot#skip _t474);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str473

class typeDefinedOrder =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "TypeDefinedOrder";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_typeDefinedOrder (iprot : Protocol.t) =
  let _str489 = new typeDefinedOrder in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t490,_id491) = iprot#readFieldBegin in
        if _t490 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id491 with 
          | _ -> iprot#skip _t490);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str489

class columnOrder =
object (self)
  val mutable _tYPE_ORDER : typeDefinedOrder option = None
  method get_tYPE_ORDER = _tYPE_ORDER
  method grab_tYPE_ORDER = match _tYPE_ORDER with None->raise (Field_empty "columnOrder.tYPE_ORDER") | Some _x493 -> _x493
  method set_tYPE_ORDER _x493 = _tYPE_ORDER <- Some _x493
  method unset_tYPE_ORDER = _tYPE_ORDER <- None
  method reset_tYPE_ORDER = _tYPE_ORDER <- None

  method copy =
      let _new = Oo.copy self in
      if _tYPE_ORDER <> None then
        _new#set_tYPE_ORDER self#grab_tYPE_ORDER#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnOrder";
    (match _tYPE_ORDER with None -> () | Some _v -> 
      oprot#writeFieldBegin("TYPE_ORDER",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnOrder (iprot : Protocol.t) =
  let _str496 = new columnOrder in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t497,_id498) = iprot#readFieldBegin in
        if _t497 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id498 with 
          | 1 -> (if _t497 = Protocol.T_STRUCT then
              _str496#set_tYPE_ORDER (read_typeDefinedOrder iprot)
            else
              iprot#skip _t497)
          | _ -> iprot#skip _t497);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str496

class pageLocation =
object (self)
  val mutable _offset : Int64.t option = None
  method get_offset = _offset
  method grab_offset = match _offset with None->raise (Field_empty "pageLocation.offset") | Some _x500 -> _x500
  method set_offset _x500 = _offset <- Some _x500
  method unset_offset = _offset <- None
  method reset_offset = _offset <- None

  val mutable _compressed_page_size : Int32.t option = None
  method get_compressed_page_size = _compressed_page_size
  method grab_compressed_page_size = match _compressed_page_size with None->raise (Field_empty "pageLocation.compressed_page_size") | Some _x501 -> _x501
  method set_compressed_page_size _x501 = _compressed_page_size <- Some _x501
  method unset_compressed_page_size = _compressed_page_size <- None
  method reset_compressed_page_size = _compressed_page_size <- None

  val mutable _first_row_index : Int64.t option = None
  method get_first_row_index = _first_row_index
  method grab_first_row_index = match _first_row_index with None->raise (Field_empty "pageLocation.first_row_index") | Some _x502 -> _x502
  method set_first_row_index _x502 = _first_row_index <- Some _x502
  method unset_first_row_index = _first_row_index <- None
  method reset_first_row_index = _first_row_index <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "PageLocation";
    (match _offset with 
    | None -> raise (Field_empty "pageLocation._offset")
    | Some _v -> 
      oprot#writeFieldBegin("offset",Protocol.T_I64,1);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _compressed_page_size with 
    | None -> raise (Field_empty "pageLocation._compressed_page_size")
    | Some _v -> 
      oprot#writeFieldBegin("compressed_page_size",Protocol.T_I32,2);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _first_row_index with 
    | None -> raise (Field_empty "pageLocation._first_row_index")
    | Some _v -> 
      oprot#writeFieldBegin("first_row_index",Protocol.T_I64,3);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_pageLocation (iprot : Protocol.t) =
  let _str505 = new pageLocation in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t506,_id507) = iprot#readFieldBegin in
        if _t506 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id507 with 
          | 1 -> (if _t506 = Protocol.T_I64 then
              _str505#set_offset iprot#readI64
            else
              iprot#skip _t506)
          | 2 -> (if _t506 = Protocol.T_I32 then
              _str505#set_compressed_page_size iprot#readI32
            else
              iprot#skip _t506)
          | 3 -> (if _t506 = Protocol.T_I64 then
              _str505#set_first_row_index iprot#readI64
            else
              iprot#skip _t506)
          | _ -> iprot#skip _t506);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str505

class offsetIndex =
object (self)
  val mutable _page_locations : pageLocation list option = None
  method get_page_locations = _page_locations
  method grab_page_locations = match _page_locations with None->raise (Field_empty "offsetIndex.page_locations") | Some _x509 -> _x509
  method set_page_locations _x509 = _page_locations <- Some _x509
  method unset_page_locations = _page_locations <- None
  method reset_page_locations = _page_locations <- None

  val mutable _unencoded_byte_array_data_bytes : Int64.t list option = None
  method get_unencoded_byte_array_data_bytes = _unencoded_byte_array_data_bytes
  method grab_unencoded_byte_array_data_bytes = match _unencoded_byte_array_data_bytes with None->raise (Field_empty "offsetIndex.unencoded_byte_array_data_bytes") | Some _x510 -> _x510
  method set_unencoded_byte_array_data_bytes _x510 = _unencoded_byte_array_data_bytes <- Some _x510
  method unset_unencoded_byte_array_data_bytes = _unencoded_byte_array_data_bytes <- None
  method reset_unencoded_byte_array_data_bytes = _unencoded_byte_array_data_bytes <- None

  method copy =
      let _new = Oo.copy self in
      if _page_locations <> None then
        _new#set_page_locations (List.map (fun x -> x#copy) self#grab_page_locations);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "OffsetIndex";
    (match _page_locations with 
    | None -> raise (Field_empty "offsetIndex._page_locations")
    | Some _v -> 
      oprot#writeFieldBegin("page_locations",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter513 ->         _iter513#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _unencoded_byte_array_data_bytes with None -> () | Some _v -> 
      oprot#writeFieldBegin("unencoded_byte_array_data_bytes",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_I64,List.length _v);
      List.iter (fun _iter514 ->         oprot#writeI64(_iter514);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_offsetIndex (iprot : Protocol.t) =
  let _str515 = new offsetIndex in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t516,_id517) = iprot#readFieldBegin in
        if _t516 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id517 with 
          | 1 -> (if _t516 = Protocol.T_LIST then
              _str515#set_page_locations 
                (let (_etype521,_size518) = iprot#readListBegin in
                  let _con522 = (Array.to_list (Array.init _size518 (fun _ -> (read_pageLocation iprot)))) in
                    iprot#readListEnd; _con522)
            else
              iprot#skip _t516)
          | 2 -> (if _t516 = Protocol.T_LIST then
              _str515#set_unencoded_byte_array_data_bytes 
                (let (_etype526,_size523) = iprot#readListBegin in
                  let _con527 = (Array.to_list (Array.init _size523 (fun _ -> iprot#readI64))) in
                    iprot#readListEnd; _con527)
            else
              iprot#skip _t516)
          | _ -> iprot#skip _t516);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str515

class columnIndex =
object (self)
  val mutable _null_pages : bool list option = None
  method get_null_pages = _null_pages
  method grab_null_pages = match _null_pages with None->raise (Field_empty "columnIndex.null_pages") | Some _x529 -> _x529
  method set_null_pages _x529 = _null_pages <- Some _x529
  method unset_null_pages = _null_pages <- None
  method reset_null_pages = _null_pages <- None

  val mutable _min_values : string list option = None
  method get_min_values = _min_values
  method grab_min_values = match _min_values with None->raise (Field_empty "columnIndex.min_values") | Some _x530 -> _x530
  method set_min_values _x530 = _min_values <- Some _x530
  method unset_min_values = _min_values <- None
  method reset_min_values = _min_values <- None

  val mutable _max_values : string list option = None
  method get_max_values = _max_values
  method grab_max_values = match _max_values with None->raise (Field_empty "columnIndex.max_values") | Some _x531 -> _x531
  method set_max_values _x531 = _max_values <- Some _x531
  method unset_max_values = _max_values <- None
  method reset_max_values = _max_values <- None

  val mutable _boundary_order : BoundaryOrder.t option = None
  method get_boundary_order = _boundary_order
  method grab_boundary_order = match _boundary_order with None->raise (Field_empty "columnIndex.boundary_order") | Some _x532 -> _x532
  method set_boundary_order _x532 = _boundary_order <- Some _x532
  method unset_boundary_order = _boundary_order <- None
  method reset_boundary_order = _boundary_order <- None

  val mutable _null_counts : Int64.t list option = None
  method get_null_counts = _null_counts
  method grab_null_counts = match _null_counts with None->raise (Field_empty "columnIndex.null_counts") | Some _x533 -> _x533
  method set_null_counts _x533 = _null_counts <- Some _x533
  method unset_null_counts = _null_counts <- None
  method reset_null_counts = _null_counts <- None

  val mutable _repetition_level_histograms : Int64.t list option = None
  method get_repetition_level_histograms = _repetition_level_histograms
  method grab_repetition_level_histograms = match _repetition_level_histograms with None->raise (Field_empty "columnIndex.repetition_level_histograms") | Some _x534 -> _x534
  method set_repetition_level_histograms _x534 = _repetition_level_histograms <- Some _x534
  method unset_repetition_level_histograms = _repetition_level_histograms <- None
  method reset_repetition_level_histograms = _repetition_level_histograms <- None

  val mutable _definition_level_histograms : Int64.t list option = None
  method get_definition_level_histograms = _definition_level_histograms
  method grab_definition_level_histograms = match _definition_level_histograms with None->raise (Field_empty "columnIndex.definition_level_histograms") | Some _x535 -> _x535
  method set_definition_level_histograms _x535 = _definition_level_histograms <- Some _x535
  method unset_definition_level_histograms = _definition_level_histograms <- None
  method reset_definition_level_histograms = _definition_level_histograms <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnIndex";
    (match _null_pages with 
    | None -> raise (Field_empty "columnIndex._null_pages")
    | Some _v -> 
      oprot#writeFieldBegin("null_pages",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_BOOL,List.length _v);
      List.iter (fun _iter538 ->         oprot#writeBool(_iter538);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _min_values with 
    | None -> raise (Field_empty "columnIndex._min_values")
    | Some _v -> 
      oprot#writeFieldBegin("min_values",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter539 ->         oprot#writeString(_iter539);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _max_values with 
    | None -> raise (Field_empty "columnIndex._max_values")
    | Some _v -> 
      oprot#writeFieldBegin("max_values",Protocol.T_LIST,3);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter540 ->         oprot#writeString(_iter540);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _boundary_order with 
    | None -> raise (Field_empty "columnIndex._boundary_order")
    | Some _v -> 
      oprot#writeFieldBegin("boundary_order",Protocol.T_I32,4);
      oprot#writeI32(BoundaryOrder.to_i _v);
      oprot#writeFieldEnd
    );
    (match _null_counts with None -> () | Some _v -> 
      oprot#writeFieldBegin("null_counts",Protocol.T_LIST,5);
      oprot#writeListBegin(Protocol.T_I64,List.length _v);
      List.iter (fun _iter541 ->         oprot#writeI64(_iter541);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _repetition_level_histograms with None -> () | Some _v -> 
      oprot#writeFieldBegin("repetition_level_histograms",Protocol.T_LIST,6);
      oprot#writeListBegin(Protocol.T_I64,List.length _v);
      List.iter (fun _iter542 ->         oprot#writeI64(_iter542);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _definition_level_histograms with None -> () | Some _v -> 
      oprot#writeFieldBegin("definition_level_histograms",Protocol.T_LIST,7);
      oprot#writeListBegin(Protocol.T_I64,List.length _v);
      List.iter (fun _iter543 ->         oprot#writeI64(_iter543);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnIndex (iprot : Protocol.t) =
  let _str544 = new columnIndex in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t545,_id546) = iprot#readFieldBegin in
        if _t545 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id546 with 
          | 1 -> (if _t545 = Protocol.T_LIST then
              _str544#set_null_pages 
                (let (_etype550,_size547) = iprot#readListBegin in
                  let _con551 = (Array.to_list (Array.init _size547 (fun _ -> iprot#readBool))) in
                    iprot#readListEnd; _con551)
            else
              iprot#skip _t545)
          | 2 -> (if _t545 = Protocol.T_LIST then
              _str544#set_min_values 
                (let (_etype555,_size552) = iprot#readListBegin in
                  let _con556 = (Array.to_list (Array.init _size552 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con556)
            else
              iprot#skip _t545)
          | 3 -> (if _t545 = Protocol.T_LIST then
              _str544#set_max_values 
                (let (_etype560,_size557) = iprot#readListBegin in
                  let _con561 = (Array.to_list (Array.init _size557 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con561)
            else
              iprot#skip _t545)
          | 4 -> (if _t545 = Protocol.T_I32 then
              _str544#set_boundary_order (BoundaryOrder.of_i iprot#readI32)
            else
              iprot#skip _t545)
          | 5 -> (if _t545 = Protocol.T_LIST then
              _str544#set_null_counts 
                (let (_etype565,_size562) = iprot#readListBegin in
                  let _con566 = (Array.to_list (Array.init _size562 (fun _ -> iprot#readI64))) in
                    iprot#readListEnd; _con566)
            else
              iprot#skip _t545)
          | 6 -> (if _t545 = Protocol.T_LIST then
              _str544#set_repetition_level_histograms 
                (let (_etype570,_size567) = iprot#readListBegin in
                  let _con571 = (Array.to_list (Array.init _size567 (fun _ -> iprot#readI64))) in
                    iprot#readListEnd; _con571)
            else
              iprot#skip _t545)
          | 7 -> (if _t545 = Protocol.T_LIST then
              _str544#set_definition_level_histograms 
                (let (_etype575,_size572) = iprot#readListBegin in
                  let _con576 = (Array.to_list (Array.init _size572 (fun _ -> iprot#readI64))) in
                    iprot#readListEnd; _con576)
            else
              iprot#skip _t545)
          | _ -> iprot#skip _t545);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str544

class aesGcmV1 =
object (self)
  val mutable _aad_prefix : string option = None
  method get_aad_prefix = _aad_prefix
  method grab_aad_prefix = match _aad_prefix with None->raise (Field_empty "aesGcmV1.aad_prefix") | Some _x578 -> _x578
  method set_aad_prefix _x578 = _aad_prefix <- Some _x578
  method unset_aad_prefix = _aad_prefix <- None
  method reset_aad_prefix = _aad_prefix <- None

  val mutable _aad_file_unique : string option = None
  method get_aad_file_unique = _aad_file_unique
  method grab_aad_file_unique = match _aad_file_unique with None->raise (Field_empty "aesGcmV1.aad_file_unique") | Some _x579 -> _x579
  method set_aad_file_unique _x579 = _aad_file_unique <- Some _x579
  method unset_aad_file_unique = _aad_file_unique <- None
  method reset_aad_file_unique = _aad_file_unique <- None

  val mutable _supply_aad_prefix : bool option = None
  method get_supply_aad_prefix = _supply_aad_prefix
  method grab_supply_aad_prefix = match _supply_aad_prefix with None->raise (Field_empty "aesGcmV1.supply_aad_prefix") | Some _x580 -> _x580
  method set_supply_aad_prefix _x580 = _supply_aad_prefix <- Some _x580
  method unset_supply_aad_prefix = _supply_aad_prefix <- None
  method reset_supply_aad_prefix = _supply_aad_prefix <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "AesGcmV1";
    (match _aad_prefix with None -> () | Some _v -> 
      oprot#writeFieldBegin("aad_prefix",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _aad_file_unique with None -> () | Some _v -> 
      oprot#writeFieldBegin("aad_file_unique",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _supply_aad_prefix with None -> () | Some _v -> 
      oprot#writeFieldBegin("supply_aad_prefix",Protocol.T_BOOL,3);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_aesGcmV1 (iprot : Protocol.t) =
  let _str583 = new aesGcmV1 in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t584,_id585) = iprot#readFieldBegin in
        if _t584 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id585 with 
          | 1 -> (if _t584 = Protocol.T_STRING then
              _str583#set_aad_prefix iprot#readString
            else
              iprot#skip _t584)
          | 2 -> (if _t584 = Protocol.T_STRING then
              _str583#set_aad_file_unique iprot#readString
            else
              iprot#skip _t584)
          | 3 -> (if _t584 = Protocol.T_BOOL then
              _str583#set_supply_aad_prefix iprot#readBool
            else
              iprot#skip _t584)
          | _ -> iprot#skip _t584);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str583

class aesGcmCtrV1 =
object (self)
  val mutable _aad_prefix : string option = None
  method get_aad_prefix = _aad_prefix
  method grab_aad_prefix = match _aad_prefix with None->raise (Field_empty "aesGcmCtrV1.aad_prefix") | Some _x587 -> _x587
  method set_aad_prefix _x587 = _aad_prefix <- Some _x587
  method unset_aad_prefix = _aad_prefix <- None
  method reset_aad_prefix = _aad_prefix <- None

  val mutable _aad_file_unique : string option = None
  method get_aad_file_unique = _aad_file_unique
  method grab_aad_file_unique = match _aad_file_unique with None->raise (Field_empty "aesGcmCtrV1.aad_file_unique") | Some _x588 -> _x588
  method set_aad_file_unique _x588 = _aad_file_unique <- Some _x588
  method unset_aad_file_unique = _aad_file_unique <- None
  method reset_aad_file_unique = _aad_file_unique <- None

  val mutable _supply_aad_prefix : bool option = None
  method get_supply_aad_prefix = _supply_aad_prefix
  method grab_supply_aad_prefix = match _supply_aad_prefix with None->raise (Field_empty "aesGcmCtrV1.supply_aad_prefix") | Some _x589 -> _x589
  method set_supply_aad_prefix _x589 = _supply_aad_prefix <- Some _x589
  method unset_supply_aad_prefix = _supply_aad_prefix <- None
  method reset_supply_aad_prefix = _supply_aad_prefix <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "AesGcmCtrV1";
    (match _aad_prefix with None -> () | Some _v -> 
      oprot#writeFieldBegin("aad_prefix",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _aad_file_unique with None -> () | Some _v -> 
      oprot#writeFieldBegin("aad_file_unique",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _supply_aad_prefix with None -> () | Some _v -> 
      oprot#writeFieldBegin("supply_aad_prefix",Protocol.T_BOOL,3);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_aesGcmCtrV1 (iprot : Protocol.t) =
  let _str592 = new aesGcmCtrV1 in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t593,_id594) = iprot#readFieldBegin in
        if _t593 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id594 with 
          | 1 -> (if _t593 = Protocol.T_STRING then
              _str592#set_aad_prefix iprot#readString
            else
              iprot#skip _t593)
          | 2 -> (if _t593 = Protocol.T_STRING then
              _str592#set_aad_file_unique iprot#readString
            else
              iprot#skip _t593)
          | 3 -> (if _t593 = Protocol.T_BOOL then
              _str592#set_supply_aad_prefix iprot#readBool
            else
              iprot#skip _t593)
          | _ -> iprot#skip _t593);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str592

class encryptionAlgorithm =
object (self)
  val mutable _aES_GCM_V1 : aesGcmV1 option = None
  method get_aES_GCM_V1 = _aES_GCM_V1
  method grab_aES_GCM_V1 = match _aES_GCM_V1 with None->raise (Field_empty "encryptionAlgorithm.aES_GCM_V1") | Some _x596 -> _x596
  method set_aES_GCM_V1 _x596 = _aES_GCM_V1 <- Some _x596
  method unset_aES_GCM_V1 = _aES_GCM_V1 <- None
  method reset_aES_GCM_V1 = _aES_GCM_V1 <- None

  val mutable _aES_GCM_CTR_V1 : aesGcmCtrV1 option = None
  method get_aES_GCM_CTR_V1 = _aES_GCM_CTR_V1
  method grab_aES_GCM_CTR_V1 = match _aES_GCM_CTR_V1 with None->raise (Field_empty "encryptionAlgorithm.aES_GCM_CTR_V1") | Some _x597 -> _x597
  method set_aES_GCM_CTR_V1 _x597 = _aES_GCM_CTR_V1 <- Some _x597
  method unset_aES_GCM_CTR_V1 = _aES_GCM_CTR_V1 <- None
  method reset_aES_GCM_CTR_V1 = _aES_GCM_CTR_V1 <- None

  method copy =
      let _new = Oo.copy self in
      if _aES_GCM_V1 <> None then
        _new#set_aES_GCM_V1 self#grab_aES_GCM_V1#copy;
      if _aES_GCM_CTR_V1 <> None then
        _new#set_aES_GCM_CTR_V1 self#grab_aES_GCM_CTR_V1#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "EncryptionAlgorithm";
    (match _aES_GCM_V1 with None -> () | Some _v -> 
      oprot#writeFieldBegin("AES_GCM_V1",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _aES_GCM_CTR_V1 with None -> () | Some _v -> 
      oprot#writeFieldBegin("AES_GCM_CTR_V1",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_encryptionAlgorithm (iprot : Protocol.t) =
  let _str600 = new encryptionAlgorithm in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t601,_id602) = iprot#readFieldBegin in
        if _t601 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id602 with 
          | 1 -> (if _t601 = Protocol.T_STRUCT then
              _str600#set_aES_GCM_V1 (read_aesGcmV1 iprot)
            else
              iprot#skip _t601)
          | 2 -> (if _t601 = Protocol.T_STRUCT then
              _str600#set_aES_GCM_CTR_V1 (read_aesGcmCtrV1 iprot)
            else
              iprot#skip _t601)
          | _ -> iprot#skip _t601);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str600

class fileMetaData =
object (self)
  val mutable _version : Int32.t option = None
  method get_version = _version
  method grab_version = match _version with None->raise (Field_empty "fileMetaData.version") | Some _x604 -> _x604
  method set_version _x604 = _version <- Some _x604
  method unset_version = _version <- None
  method reset_version = _version <- None

  val mutable _schema : schemaElement list option = None
  method get_schema = _schema
  method grab_schema = match _schema with None->raise (Field_empty "fileMetaData.schema") | Some _x605 -> _x605
  method set_schema _x605 = _schema <- Some _x605
  method unset_schema = _schema <- None
  method reset_schema = _schema <- None

  val mutable _num_rows : Int64.t option = None
  method get_num_rows = _num_rows
  method grab_num_rows = match _num_rows with None->raise (Field_empty "fileMetaData.num_rows") | Some _x606 -> _x606
  method set_num_rows _x606 = _num_rows <- Some _x606
  method unset_num_rows = _num_rows <- None
  method reset_num_rows = _num_rows <- None

  val mutable _row_groups : rowGroup list option = None
  method get_row_groups = _row_groups
  method grab_row_groups = match _row_groups with None->raise (Field_empty "fileMetaData.row_groups") | Some _x607 -> _x607
  method set_row_groups _x607 = _row_groups <- Some _x607
  method unset_row_groups = _row_groups <- None
  method reset_row_groups = _row_groups <- None

  val mutable _key_value_metadata : keyValue list option = None
  method get_key_value_metadata = _key_value_metadata
  method grab_key_value_metadata = match _key_value_metadata with None->raise (Field_empty "fileMetaData.key_value_metadata") | Some _x608 -> _x608
  method set_key_value_metadata _x608 = _key_value_metadata <- Some _x608
  method unset_key_value_metadata = _key_value_metadata <- None
  method reset_key_value_metadata = _key_value_metadata <- None

  val mutable _created_by : string option = None
  method get_created_by = _created_by
  method grab_created_by = match _created_by with None->raise (Field_empty "fileMetaData.created_by") | Some _x609 -> _x609
  method set_created_by _x609 = _created_by <- Some _x609
  method unset_created_by = _created_by <- None
  method reset_created_by = _created_by <- None

  val mutable _column_orders : columnOrder list option = None
  method get_column_orders = _column_orders
  method grab_column_orders = match _column_orders with None->raise (Field_empty "fileMetaData.column_orders") | Some _x610 -> _x610
  method set_column_orders _x610 = _column_orders <- Some _x610
  method unset_column_orders = _column_orders <- None
  method reset_column_orders = _column_orders <- None

  val mutable _encryption_algorithm : encryptionAlgorithm option = None
  method get_encryption_algorithm = _encryption_algorithm
  method grab_encryption_algorithm = match _encryption_algorithm with None->raise (Field_empty "fileMetaData.encryption_algorithm") | Some _x611 -> _x611
  method set_encryption_algorithm _x611 = _encryption_algorithm <- Some _x611
  method unset_encryption_algorithm = _encryption_algorithm <- None
  method reset_encryption_algorithm = _encryption_algorithm <- None

  val mutable _footer_signing_key_metadata : string option = None
  method get_footer_signing_key_metadata = _footer_signing_key_metadata
  method grab_footer_signing_key_metadata = match _footer_signing_key_metadata with None->raise (Field_empty "fileMetaData.footer_signing_key_metadata") | Some _x612 -> _x612
  method set_footer_signing_key_metadata _x612 = _footer_signing_key_metadata <- Some _x612
  method unset_footer_signing_key_metadata = _footer_signing_key_metadata <- None
  method reset_footer_signing_key_metadata = _footer_signing_key_metadata <- None

  method copy =
      let _new = Oo.copy self in
      if _schema <> None then
        _new#set_schema (List.map (fun x -> x#copy) self#grab_schema);
      if _row_groups <> None then
        _new#set_row_groups (List.map (fun x -> x#copy) self#grab_row_groups);
      if _key_value_metadata <> None then
        _new#set_key_value_metadata (List.map (fun x -> x#copy) self#grab_key_value_metadata);
      if _column_orders <> None then
        _new#set_column_orders (List.map (fun x -> x#copy) self#grab_column_orders);
      if _encryption_algorithm <> None then
        _new#set_encryption_algorithm self#grab_encryption_algorithm#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "FileMetaData";
    (match _version with 
    | None -> raise (Field_empty "fileMetaData._version")
    | Some _v -> 
      oprot#writeFieldBegin("version",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _schema with 
    | None -> raise (Field_empty "fileMetaData._schema")
    | Some _v -> 
      oprot#writeFieldBegin("schema",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter615 ->         _iter615#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _num_rows with 
    | None -> raise (Field_empty "fileMetaData._num_rows")
    | Some _v -> 
      oprot#writeFieldBegin("num_rows",Protocol.T_I64,3);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _row_groups with 
    | None -> raise (Field_empty "fileMetaData._row_groups")
    | Some _v -> 
      oprot#writeFieldBegin("row_groups",Protocol.T_LIST,4);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter616 ->         _iter616#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _key_value_metadata with None -> () | Some _v -> 
      oprot#writeFieldBegin("key_value_metadata",Protocol.T_LIST,5);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter617 ->         _iter617#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _created_by with None -> () | Some _v -> 
      oprot#writeFieldBegin("created_by",Protocol.T_STRING,6);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_orders with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_orders",Protocol.T_LIST,7);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter618 ->         _iter618#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _encryption_algorithm with None -> () | Some _v -> 
      oprot#writeFieldBegin("encryption_algorithm",Protocol.T_STRUCT,8);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _footer_signing_key_metadata with None -> () | Some _v -> 
      oprot#writeFieldBegin("footer_signing_key_metadata",Protocol.T_STRING,9);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_fileMetaData (iprot : Protocol.t) =
  let _str619 = new fileMetaData in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t620,_id621) = iprot#readFieldBegin in
        if _t620 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id621 with 
          | 1 -> (if _t620 = Protocol.T_I32 then
              _str619#set_version iprot#readI32
            else
              iprot#skip _t620)
          | 2 -> (if _t620 = Protocol.T_LIST then
              _str619#set_schema 
                (let (_etype625,_size622) = iprot#readListBegin in
                  let _con626 = (Array.to_list (Array.init _size622 (fun _ -> (read_schemaElement iprot)))) in
                    iprot#readListEnd; _con626)
            else
              iprot#skip _t620)
          | 3 -> (if _t620 = Protocol.T_I64 then
              _str619#set_num_rows iprot#readI64
            else
              iprot#skip _t620)
          | 4 -> (if _t620 = Protocol.T_LIST then
              _str619#set_row_groups 
                (let (_etype630,_size627) = iprot#readListBegin in
                  let _con631 = (Array.to_list (Array.init _size627 (fun _ -> (read_rowGroup iprot)))) in
                    iprot#readListEnd; _con631)
            else
              iprot#skip _t620)
          | 5 -> (if _t620 = Protocol.T_LIST then
              _str619#set_key_value_metadata 
                (let (_etype635,_size632) = iprot#readListBegin in
                  let _con636 = (Array.to_list (Array.init _size632 (fun _ -> (read_keyValue iprot)))) in
                    iprot#readListEnd; _con636)
            else
              iprot#skip _t620)
          | 6 -> (if _t620 = Protocol.T_STRING then
              _str619#set_created_by iprot#readString
            else
              iprot#skip _t620)
          | 7 -> (if _t620 = Protocol.T_LIST then
              _str619#set_column_orders 
                (let (_etype640,_size637) = iprot#readListBegin in
                  let _con641 = (Array.to_list (Array.init _size637 (fun _ -> (read_columnOrder iprot)))) in
                    iprot#readListEnd; _con641)
            else
              iprot#skip _t620)
          | 8 -> (if _t620 = Protocol.T_STRUCT then
              _str619#set_encryption_algorithm (read_encryptionAlgorithm iprot)
            else
              iprot#skip _t620)
          | 9 -> (if _t620 = Protocol.T_STRING then
              _str619#set_footer_signing_key_metadata iprot#readString
            else
              iprot#skip _t620)
          | _ -> iprot#skip _t620);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str619

class fileCryptoMetaData =
object (self)
  val mutable _encryption_algorithm : encryptionAlgorithm option = None
  method get_encryption_algorithm = _encryption_algorithm
  method grab_encryption_algorithm = match _encryption_algorithm with None->raise (Field_empty "fileCryptoMetaData.encryption_algorithm") | Some _x643 -> _x643
  method set_encryption_algorithm _x643 = _encryption_algorithm <- Some _x643
  method unset_encryption_algorithm = _encryption_algorithm <- None
  method reset_encryption_algorithm = _encryption_algorithm <- None

  val mutable _key_metadata : string option = None
  method get_key_metadata = _key_metadata
  method grab_key_metadata = match _key_metadata with None->raise (Field_empty "fileCryptoMetaData.key_metadata") | Some _x644 -> _x644
  method set_key_metadata _x644 = _key_metadata <- Some _x644
  method unset_key_metadata = _key_metadata <- None
  method reset_key_metadata = _key_metadata <- None

  method copy =
      let _new = Oo.copy self in
      if _encryption_algorithm <> None then
        _new#set_encryption_algorithm self#grab_encryption_algorithm#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "FileCryptoMetaData";
    (match _encryption_algorithm with 
    | None -> raise (Field_empty "fileCryptoMetaData._encryption_algorithm")
    | Some _v -> 
      oprot#writeFieldBegin("encryption_algorithm",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _key_metadata with None -> () | Some _v -> 
      oprot#writeFieldBegin("key_metadata",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_fileCryptoMetaData (iprot : Protocol.t) =
  let _str647 = new fileCryptoMetaData in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t648,_id649) = iprot#readFieldBegin in
        if _t648 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id649 with 
          | 1 -> (if _t648 = Protocol.T_STRUCT then
              _str647#set_encryption_algorithm (read_encryptionAlgorithm iprot)
            else
              iprot#skip _t648)
          | 2 -> (if _t648 = Protocol.T_STRING then
              _str647#set_key_metadata iprot#readString
            else
              iprot#skip _t648)
          | _ -> iprot#skip _t648);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str647

