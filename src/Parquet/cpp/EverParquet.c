/* 
  This file was generated by KaRaMeL <https://github.com/FStarLang/karamel>
  KaRaMeL invocation: /home/tahina/everest/karamel/krml -skip-compilation -bundle Parquet.Pulse.Toplevel+Parquet.Pulse.Toplevel0=*[rename=EverParquet] -no-prefix Parquet.Pulse.Toplevel -no-prefix Parquet.Pulse.Toplevel0 -skip-makefiles -tmpdir cpp/ _output/FStar_Attributes.krml _output/FStar_NormSteps.krml _output/FStar_Pervasives_Native.krml _output/FStar_Pervasives.krml _output/FStar_Prelude.krml _output/FStar_Mul.krml _output/FStar_Ghost.krml _output/FStar_IndefiniteDescription.krml _output/FStar_Squash.krml _output/FStar_Classical.krml _output/FStar_Classical_Sugar.krml _output/FStar_List_Tot_Base.krml _output/FStar_StrongExcludedMiddle.krml _output/FStar_List_Tot_Properties.krml _output/FStar_List_Tot.krml _output/FStar_Seq_Base.krml _output/FStar_Preorder.krml _output/FStar_Sealed.krml _output/FStar_Range.krml _output/FStar_Calc.krml _output/FStar_Seq_Properties.krml _output/FStar_Seq.krml _output/FStar_Math_Lib.krml _output/FStar_Math_Lemmas.krml _output/FStar_BitVector.krml _output/FStar_UInt.krml _output/FStar_UInt32.krml _output/FStar_Int.krml _output/FStar_Int16.krml _output/FStar_ErasedLogic.krml _output/FStar_UInt64.krml _output/FStar_PCM.krml _output/FStar_UInt8.krml _output/FStar_Endianness.krml _output/LowParse_Norm.krml _output/FStar_Monotonic_Pure.krml _output/FStar_Float.krml _output/FStar_Char.krml _output/FStar_Pprint.krml _output/FStar_Errors_Msg.krml _output/FStar_Sealed_Inhabited.krml _output/FStar_Reflection_Types.krml _output/FStar_Syntax_Syntax.krml _output/FStar_Reflection_V2_Data.krml _output/FStar_VConfig.krml _output/FStar_Order.krml _output/FStar_Reflection_V2_Builtins.krml _output/FStar_Issue.krml _output/FStar_Tactics_Common.krml _output/FStar_Tactics_Types.krml _output/FStar_Tactics_Result.krml _output/FStar_Tactics_Unseal.krml _output/FStar_TypeChecker_Core.krml _output/FStar_Tactics_Types_Reflection.krml _output/FStar_Tactics_V2_Builtins.krml _output/FStar_PropositionalExtensionality.krml _output/FStar_Reflection_V1_Data.krml _output/FStar_Reflection_V1_Builtins.krml _output/FStar_Tactics_V1_Builtins.krml _output/LowParse_Bytes.krml _output/LowParse_Spec_Base.krml _output/LowParse_Spec_Combinators.krml _output/LowParse_Spec_FLData.krml _output/Parquet_Spec_Jump.krml _output/FStar_Real.krml _output/FStar_Exn.krml _output/FStar_FunctionalExtensionality.krml _output/FStar_Set.krml _output/FStar_Monotonic_Witnessed.krml _output/FStar_PredicateExtensionality.krml _output/FStar_TSet.krml _output/FStar_Monotonic_Heap.krml _output/FStar_Heap.krml _output/FStar_ST.krml _output/FStar_All.krml _output/FStar_List.krml _output/FStar_Int64.krml _output/FStar_Int32.krml _output/FStar_Int8.krml _output/Parquet_Spec_Toplevel_Types.krml _output/FStar_UInt16.krml _output/FStar_Int_Cast.krml _output/LowParse_Math.krml _output/LowParse_Spec_Seq.krml _output/LowParse_Spec_Int.krml _output/LowParse_Spec_BoundedInt.krml _output/LowParse_Spec_Sorted.krml _output/LowParse_Spec_SeqBytes_Base.krml _output/LowParse_Spec_DER.krml _output/LowParse_Spec_BCVLI.krml _output/LowParse_Spec_AllIntegers.krml _output/LowParse_Spec_VLData.krml _output/LowParse_Spec_SeqBytes.krml _output/LowParse_Spec_RtoLPair.krml _output/LowParse_Spec_RtoLDepPair.krml _output/Parquet_Spec_Toplevel.krml _output/FStar_GhostSet.krml _output/FStar_ExtractAs.krml _output/Pulse_Class_PtsTo.krml _output/FStar_String.krml _output/FStar_Printf.krml _output/FStar_SizeT.krml _output/FStar_Map.krml _output/FStar_Universe.krml _output/Pulse_Lib_Slice.krml _output/Pulse_Lib_Slice_Util.krml _output/LowParse_Pulse_Base.krml _output/LowParse_Pulse_FLData.krml _output/CDDL_Spec_Bijection.krml _output/LowParse_Endianness.krml _output/LowParse_Spec_Endianness.krml _output/LowParse_Pulse_Endianness.krml _output/LowParse_Pulse_SeqBytes.krml _output/LowParse_Pulse_Combinators.krml _output/Parquet_Pulse_Jump.krml _output/LowParse_Spec_Endianness_Instances.krml _output/LowParse_Pulse_Int.krml _output/CDDL_Pulse_Types_Base.krml _output/Parquet_Pulse_Vec.krml _output/Parquet_Pulse_Toplevel.krml _output/Parquet_Pulse_Rel.krml _output/Parquet_Pulse_Toplevel0.krml _output/Parquet_Spec_Toplevel_Old.krml _output/Parquet_Spec_Validator.krml _output/Parquet_Tot_Validator.krml
  F* version: <unknown>
  KaRaMeL version: 35479191
 */

#include "EverParquet.h"

typedef FStar_Pervasives_Native_option__int8_t variant_type;

typedef FStar_Pervasives_Native_option__Prims_string geometry_type;

bool uu___is_ENCRYPTION_WITH_FOOTER_KEY(column_crypto_meta_data projectee)
{
  if (projectee.tag == ENCRYPTION_WITH_FOOTER_KEY)
    return true;
  else
    return false;
}

bool uu___is_ENCRYPTION_WITH_COLUMN_KEY(column_crypto_meta_data projectee)
{
  if (projectee.tag == ENCRYPTION_WITH_COLUMN_KEY)
    return true;
  else
    return false;
}

bool
impl_validate_all(
  uint32_t len,
  Pulse_Lib_Slice_slice__uint8_t y,
  Pulse_Lib_Slice_slice__uint8_t x
)
{
  KRML_MAYBE_UNUSED_VAR(len);
  file_meta_data f = read_footer(y);
  return impl_validate_all0(f, x);
}

static size_t len__uint8_t(Pulse_Lib_Slice_slice__uint8_t s)
{
  return s.len;
}

typedef struct __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t_s
{
  Pulse_Lib_Slice_slice__uint8_t fst;
  Pulse_Lib_Slice_slice__uint8_t snd;
}
__Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t;

static __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
split__uint8_t(Pulse_Lib_Slice_slice__uint8_t s, size_t i)
{
  uint8_t *elt_ = s.elt + i;
  Pulse_Lib_Slice_slice__uint8_t s1 = { .elt = s.elt, .len = i };
  Pulse_Lib_Slice_slice__uint8_t s2 = { .elt = elt_, .len = s.len - i };
  return
    ((__Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t){ .fst = s1, .snd = s2 });
}

static uint8_t op_Array_Access__uint8_t(Pulse_Lib_Slice_slice__uint8_t a, size_t i)
{
  return a.elt[i];
}

typedef struct
__Pulse_Lib_Slice_slice_uint8_t__Pulse_Lib_Slice_slice_uint8_t___Pulse_Lib_Slice_slice_uint8_t__s
{
  Pulse_Lib_Slice_slice__uint8_t fst;
  __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t snd;
}
__Pulse_Lib_Slice_slice_uint8_t__Pulse_Lib_Slice_slice_uint8_t___Pulse_Lib_Slice_slice_uint8_t_;

bool validate_parquet(Pulse_Lib_Slice_slice__uint8_t input, size_t *poffset)
{
  size_t input_len = len__uint8_t(input);
  size_t offset1 = *poffset;
  if (input_len - offset1 < (size_t)4U)
    return false;
  else
  {
    size_t off = input_len - (size_t)4U;
    size_t poff = off;
    size_t offset20 = poff;
    size_t offset30 = poff;
    bool is_valid0;
    if (len__uint8_t(input) - offset30 < (size_t)4U)
      is_valid0 = false;
    else
    {
      poff = offset30 + (size_t)4U;
      is_valid0 = true;
    }
    bool is_valid2;
    if (is_valid0)
    {
      size_t off1 = poff;
      __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
      s_ = split__uint8_t(input, offset20);
      Pulse_Lib_Slice_slice__uint8_t s10 = s_.fst;
      Pulse_Lib_Slice_slice__uint8_t s20 = s_.snd;
      __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
      _letpattern = { .fst = s10, .snd = s20 };
      Pulse_Lib_Slice_slice__uint8_t input1 = _letpattern.fst;
      Pulse_Lib_Slice_slice__uint8_t input23 = _letpattern.snd;
      size_t consumed = off1 - offset20;
      __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
      _letpattern1 = split__uint8_t(input23, consumed);
      Pulse_Lib_Slice_slice__uint8_t s1 = _letpattern1.fst;
      Pulse_Lib_Slice_slice__uint8_t s2 = _letpattern1.snd;
      __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
      _letpattern10 = { .fst = s1, .snd = s2 };
      Pulse_Lib_Slice_slice__uint8_t left = _letpattern10.fst;
      Pulse_Lib_Slice_slice__uint8_t right = _letpattern10.snd;
      __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
      _letpattern11 = { .fst = left, .snd = right };
      Pulse_Lib_Slice_slice__uint8_t input2 = _letpattern11.fst;
      Pulse_Lib_Slice_slice__uint8_t input3 = _letpattern11.snd;
      __Pulse_Lib_Slice_slice_uint8_t__Pulse_Lib_Slice_slice_uint8_t___Pulse_Lib_Slice_slice_uint8_t_
      _letpattern0 = { .fst = input1, .snd = { .fst = input2, .snd = input3 } };
      Pulse_Lib_Slice_slice__uint8_t x = _letpattern0.snd.fst;
      is_valid2 = validate_is_PAR1(x);
    }
    else
      is_valid2 = false;
    if (is_valid2)
    {
      __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t s_ = split__uint8_t(input, off);
      Pulse_Lib_Slice_slice__uint8_t s10 = s_.fst;
      Pulse_Lib_Slice_slice__uint8_t s20 = s_.snd;
      __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
      _letpattern = { .fst = s10, .snd = s20 };
      Pulse_Lib_Slice_slice__uint8_t l = _letpattern.fst;
      size_t input_len1 = len__uint8_t(l);
      size_t offset2 = *poffset;
      bool is_valid10;
      if (input_len1 - offset2 < (size_t)4U)
        is_valid10 = false;
      else
      {
        size_t off1 = input_len1 - (size_t)4U;
        size_t poff1 = off1;
        size_t offset30 = poff1;
        bool is_valid21;
        if (len__uint8_t(l) - offset30 < (size_t)4U)
          is_valid21 = false;
        else
        {
          poff1 = offset30 + (size_t)4U;
          is_valid21 = true;
        }
        if (is_valid21)
        {
          size_t off_ = poff1;
          __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
          s_ = split__uint8_t(l, off1);
          Pulse_Lib_Slice_slice__uint8_t s10 = s_.fst;
          Pulse_Lib_Slice_slice__uint8_t s20 = s_.snd;
          __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
          _letpattern1 = { .fst = s10, .snd = s20 };
          Pulse_Lib_Slice_slice__uint8_t input10 = _letpattern1.fst;
          Pulse_Lib_Slice_slice__uint8_t input230 = _letpattern1.snd;
          size_t consumed0 = off_ - off1;
          __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
          _letpattern2 = split__uint8_t(input230, consumed0);
          Pulse_Lib_Slice_slice__uint8_t s11 = _letpattern2.fst;
          Pulse_Lib_Slice_slice__uint8_t s21 = _letpattern2.snd;
          __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
          _letpattern20 = { .fst = s11, .snd = s21 };
          Pulse_Lib_Slice_slice__uint8_t left0 = _letpattern20.fst;
          Pulse_Lib_Slice_slice__uint8_t right0 = _letpattern20.snd;
          __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
          _letpattern21 = { .fst = left0, .snd = right0 };
          Pulse_Lib_Slice_slice__uint8_t input20 = _letpattern21.fst;
          Pulse_Lib_Slice_slice__uint8_t input30 = _letpattern21.snd;
          __Pulse_Lib_Slice_slice_uint8_t__Pulse_Lib_Slice_slice_uint8_t___Pulse_Lib_Slice_slice_uint8_t_
          _letpattern10 = { .fst = input10, .snd = { .fst = input20, .snd = input30 } };
          Pulse_Lib_Slice_slice__uint8_t input_ = _letpattern10.snd.fst;
          size_t pos_ = (size_t)1U;
          uint8_t first = op_Array_Access__uint8_t(input_, (size_t)0U);
          size_t pos_1 = pos_ + (size_t)1U;
          uint8_t first1 = op_Array_Access__uint8_t(input_, pos_);
          size_t pos_2 = pos_1 + (size_t)1U;
          uint8_t first2 = op_Array_Access__uint8_t(input_, pos_1);
          uint8_t first3 = op_Array_Access__uint8_t(input_, pos_2);
          uint32_t n = (uint32_t)first3;
          uint32_t bfirst0 = (uint32_t)first2;
          uint32_t n0 = bfirst0 + n * 256U;
          uint32_t bfirst1 = (uint32_t)first1;
          uint32_t n1 = bfirst1 + n0 * 256U;
          uint32_t bfirst = (uint32_t)first;
          uint32_t x = bfirst + n1 * 256U;
          uint32_t x0 = x;
          __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
          s_0 = split__uint8_t(l, off1);
          Pulse_Lib_Slice_slice__uint8_t s12 = s_0.fst;
          Pulse_Lib_Slice_slice__uint8_t s22 = s_0.snd;
          __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
          _letpattern11 = { .fst = s12, .snd = s22 };
          Pulse_Lib_Slice_slice__uint8_t l1 = _letpattern11.fst;
          size_t input_len2 = len__uint8_t(l1);
          size_t offset3 = *poffset;
          bool is_valid11;
          if (input_len2 - offset3 < (size_t)x0)
            is_valid11 = false;
          else
          {
            size_t off2 = input_len2 - (size_t)x0;
            size_t poff2 = off2;
            size_t off30 = poff2;
            bool is_valid22;
            if (len__uint8_t(l1) - off30 < (size_t)x0)
              is_valid22 = false;
            else
            {
              size_t off_len = off30 + (size_t)x0;
              __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
              s_ = split__uint8_t(l1, off_len);
              Pulse_Lib_Slice_slice__uint8_t s1 = s_.fst;
              Pulse_Lib_Slice_slice__uint8_t s2 = s_.snd;
              __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
              _letpattern2 = { .fst = s1, .snd = s2 };
              Pulse_Lib_Slice_slice__uint8_t inl = _letpattern2.fst;
              bool res = validate_footer(inl, &poff2);
              size_t off_1 = poff2;
              is_valid22 = res && off_1 == off_len;
            }
            if (is_valid22)
            {
              size_t off_1 = poff2;
              __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
              s_ = split__uint8_t(l1, off2);
              Pulse_Lib_Slice_slice__uint8_t s10 = s_.fst;
              Pulse_Lib_Slice_slice__uint8_t s20 = s_.snd;
              __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
              _letpattern2 = { .fst = s10, .snd = s20 };
              Pulse_Lib_Slice_slice__uint8_t input10 = _letpattern2.fst;
              Pulse_Lib_Slice_slice__uint8_t input230 = _letpattern2.snd;
              size_t consumed0 = off_1 - off2;
              __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
              _letpattern3 = split__uint8_t(input230, consumed0);
              Pulse_Lib_Slice_slice__uint8_t s11 = _letpattern3.fst;
              Pulse_Lib_Slice_slice__uint8_t s21 = _letpattern3.snd;
              __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
              _letpattern30 = { .fst = s11, .snd = s21 };
              Pulse_Lib_Slice_slice__uint8_t left0 = _letpattern30.fst;
              Pulse_Lib_Slice_slice__uint8_t right0 = _letpattern30.snd;
              __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
              _letpattern31 = { .fst = left0, .snd = right0 };
              Pulse_Lib_Slice_slice__uint8_t input20 = _letpattern31.fst;
              Pulse_Lib_Slice_slice__uint8_t input30 = _letpattern31.snd;
              __Pulse_Lib_Slice_slice_uint8_t__Pulse_Lib_Slice_slice_uint8_t___Pulse_Lib_Slice_slice_uint8_t_
              _letpattern20 = { .fst = input10, .snd = { .fst = input20, .snd = input30 } };
              Pulse_Lib_Slice_slice__uint8_t y = _letpattern20.snd.fst;
              Pulse_Lib_Slice_slice__uint8_t l2 = _letpattern20.fst;
              size_t offset4 = *poffset;
              *poffset = len__uint8_t(l2);
              bool is_valid = true;
              bool is_valid1;
              if (is_valid)
              {
                size_t off3 = *poffset;
                __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
                s_ = split__uint8_t(l2, offset4);
                Pulse_Lib_Slice_slice__uint8_t s10 = s_.fst;
                Pulse_Lib_Slice_slice__uint8_t s20 = s_.snd;
                __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
                _letpattern3 = { .fst = s10, .snd = s20 };
                Pulse_Lib_Slice_slice__uint8_t input1 = _letpattern3.fst;
                Pulse_Lib_Slice_slice__uint8_t input23 = _letpattern3.snd;
                size_t consumed = off3 - offset4;
                __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
                _letpattern4 = split__uint8_t(input23, consumed);
                Pulse_Lib_Slice_slice__uint8_t s1 = _letpattern4.fst;
                Pulse_Lib_Slice_slice__uint8_t s2 = _letpattern4.snd;
                __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
                _letpattern40 = { .fst = s1, .snd = s2 };
                Pulse_Lib_Slice_slice__uint8_t left = _letpattern40.fst;
                Pulse_Lib_Slice_slice__uint8_t right = _letpattern40.snd;
                __Pulse_Lib_Slice_slice_uint8_t_Pulse_Lib_Slice_slice_uint8_t
                _letpattern41 = { .fst = left, .snd = right };
                Pulse_Lib_Slice_slice__uint8_t input2 = _letpattern41.fst;
                Pulse_Lib_Slice_slice__uint8_t input3 = _letpattern41.snd;
                __Pulse_Lib_Slice_slice_uint8_t__Pulse_Lib_Slice_slice_uint8_t___Pulse_Lib_Slice_slice_uint8_t_
                _letpattern30 = { .fst = input1, .snd = { .fst = input2, .snd = input3 } };
                Pulse_Lib_Slice_slice__uint8_t x1 = _letpattern30.snd.fst;
                is_valid1 = impl_validate_all(x0, y, x1);
              }
              else
                is_valid1 = false;
              *poffset = input_len2;
              is_valid11 = is_valid1;
            }
            else
              is_valid11 = false;
          }
          *poffset = input_len1;
          is_valid10 = is_valid11;
        }
        else
          is_valid10 = false;
      }
      *poffset = input_len;
      return is_valid10;
    }
    else
      return false;
  }
}

