/**
 * Autogenerated by Thrift Compiler (0.22.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "parquet_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_Type(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case TYPE_BOOLEAN:return "TYPE_BOOLEAN";
  case TYPE_INT32:return "TYPE_INT32";
  case TYPE_INT64:return "TYPE_INT64";
  case TYPE_INT96:return "TYPE_INT96";
  case TYPE_FLOAT:return "TYPE_FLOAT";
  case TYPE_DOUBLE:return "TYPE_DOUBLE";
  case TYPE_BYTE_ARRAY:return "TYPE_BYTE_ARRAY";
  case TYPE_FIXED_LEN_BYTE_ARRAY:return "TYPE_FIXED_LEN_BYTE_ARRAY";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ConvertedType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case CONVERTED_TYPE_UTF8:return "CONVERTED_TYPE_UTF8";
  case CONVERTED_TYPE_MAP:return "CONVERTED_TYPE_MAP";
  case CONVERTED_TYPE_MAP_KEY_VALUE:return "CONVERTED_TYPE_MAP_KEY_VALUE";
  case CONVERTED_TYPE_LIST:return "CONVERTED_TYPE_LIST";
  case CONVERTED_TYPE_ENUM:return "CONVERTED_TYPE_ENUM";
  case CONVERTED_TYPE_DECIMAL:return "CONVERTED_TYPE_DECIMAL";
  case CONVERTED_TYPE_DATE:return "CONVERTED_TYPE_DATE";
  case CONVERTED_TYPE_TIME_MILLIS:return "CONVERTED_TYPE_TIME_MILLIS";
  case CONVERTED_TYPE_TIME_MICROS:return "CONVERTED_TYPE_TIME_MICROS";
  case CONVERTED_TYPE_TIMESTAMP_MILLIS:return "CONVERTED_TYPE_TIMESTAMP_MILLIS";
  case CONVERTED_TYPE_TIMESTAMP_MICROS:return "CONVERTED_TYPE_TIMESTAMP_MICROS";
  case CONVERTED_TYPE_UINT_8:return "CONVERTED_TYPE_UINT_8";
  case CONVERTED_TYPE_UINT_16:return "CONVERTED_TYPE_UINT_16";
  case CONVERTED_TYPE_UINT_32:return "CONVERTED_TYPE_UINT_32";
  case CONVERTED_TYPE_UINT_64:return "CONVERTED_TYPE_UINT_64";
  case CONVERTED_TYPE_INT_8:return "CONVERTED_TYPE_INT_8";
  case CONVERTED_TYPE_INT_16:return "CONVERTED_TYPE_INT_16";
  case CONVERTED_TYPE_INT_32:return "CONVERTED_TYPE_INT_32";
  case CONVERTED_TYPE_INT_64:return "CONVERTED_TYPE_INT_64";
  case CONVERTED_TYPE_JSON:return "CONVERTED_TYPE_JSON";
  case CONVERTED_TYPE_BSON:return "CONVERTED_TYPE_BSON";
  case CONVERTED_TYPE_INTERVAL:return "CONVERTED_TYPE_INTERVAL";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_FieldRepetitionType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case FIELD_REPETITION_TYPE_REQUIRED:return "FIELD_REPETITION_TYPE_REQUIRED";
  case FIELD_REPETITION_TYPE_OPTIONAL:return "FIELD_REPETITION_TYPE_OPTIONAL";
  case FIELD_REPETITION_TYPE_REPEATED:return "FIELD_REPETITION_TYPE_REPEATED";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_EdgeInterpolationAlgorithm(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case EDGE_INTERPOLATION_ALGORITHM_SPHERICAL:return "EDGE_INTERPOLATION_ALGORITHM_SPHERICAL";
  case EDGE_INTERPOLATION_ALGORITHM_VINCENTY:return "EDGE_INTERPOLATION_ALGORITHM_VINCENTY";
  case EDGE_INTERPOLATION_ALGORITHM_THOMAS:return "EDGE_INTERPOLATION_ALGORITHM_THOMAS";
  case EDGE_INTERPOLATION_ALGORITHM_ANDOYER:return "EDGE_INTERPOLATION_ALGORITHM_ANDOYER";
  case EDGE_INTERPOLATION_ALGORITHM_KARNEY:return "EDGE_INTERPOLATION_ALGORITHM_KARNEY";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Encoding(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case ENCODING_PLAIN:return "ENCODING_PLAIN";
  case ENCODING_PLAIN_DICTIONARY:return "ENCODING_PLAIN_DICTIONARY";
  case ENCODING_RLE:return "ENCODING_RLE";
  case ENCODING_BIT_PACKED:return "ENCODING_BIT_PACKED";
  case ENCODING_DELTA_BINARY_PACKED:return "ENCODING_DELTA_BINARY_PACKED";
  case ENCODING_DELTA_LENGTH_BYTE_ARRAY:return "ENCODING_DELTA_LENGTH_BYTE_ARRAY";
  case ENCODING_DELTA_BYTE_ARRAY:return "ENCODING_DELTA_BYTE_ARRAY";
  case ENCODING_RLE_DICTIONARY:return "ENCODING_RLE_DICTIONARY";
  case ENCODING_BYTE_STREAM_SPLIT:return "ENCODING_BYTE_STREAM_SPLIT";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_CompressionCodec(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case COMPRESSION_CODEC_UNCOMPRESSED:return "COMPRESSION_CODEC_UNCOMPRESSED";
  case COMPRESSION_CODEC_SNAPPY:return "COMPRESSION_CODEC_SNAPPY";
  case COMPRESSION_CODEC_GZIP:return "COMPRESSION_CODEC_GZIP";
  case COMPRESSION_CODEC_LZO:return "COMPRESSION_CODEC_LZO";
  case COMPRESSION_CODEC_BROTLI:return "COMPRESSION_CODEC_BROTLI";
  case COMPRESSION_CODEC_LZ4:return "COMPRESSION_CODEC_LZ4";
  case COMPRESSION_CODEC_ZSTD:return "COMPRESSION_CODEC_ZSTD";
  case COMPRESSION_CODEC_LZ4_RAW:return "COMPRESSION_CODEC_LZ4_RAW";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_PageType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case PAGE_TYPE_DATA_PAGE:return "PAGE_TYPE_DATA_PAGE";
  case PAGE_TYPE_INDEX_PAGE:return "PAGE_TYPE_INDEX_PAGE";
  case PAGE_TYPE_DICTIONARY_PAGE:return "PAGE_TYPE_DICTIONARY_PAGE";
  case PAGE_TYPE_DATA_PAGE_V2:return "PAGE_TYPE_DATA_PAGE_V2";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_BoundaryOrder(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case BOUNDARY_ORDER_UNORDERED:return "BOUNDARY_ORDER_UNORDERED";
  case BOUNDARY_ORDER_ASCENDING:return "BOUNDARY_ORDER_ASCENDING";
  case BOUNDARY_ORDER_DESCENDING:return "BOUNDARY_ORDER_DESCENDING";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _SizeStatisticsProperties
{
  PROP_SIZE_STATISTICS_0,
  PROP_SIZE_STATISTICS_UNENCODED_BYTE_ARRAY_DATA_BYTES,
  PROP_SIZE_STATISTICS_REPETITION_LEVEL_HISTOGRAM,
  PROP_SIZE_STATISTICS_DEFINITION_LEVEL_HISTOGRAM
};

/* reads a size_statistics object */
static gint32
size_statistics_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SizeStatistics * this_object = SIZE_STATISTICS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->unencoded_byte_array_data_bytes, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_unencoded_byte_array_data_bytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem0 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->repetition_level_histogram, _elem0, 1);
              g_free (_elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_repetition_level_histogram = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem1 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem1, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->definition_level_histogram, _elem1, 1);
              g_free (_elem1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_definition_level_histogram = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
size_statistics_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SizeStatistics * this_object = SIZE_STATISTICS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SizeStatistics", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_unencoded_byte_array_data_bytes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "unencoded_byte_array_data_bytes", T_I64, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->unencoded_byte_array_data_bytes, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_repetition_level_histogram == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "repetition_level_histogram", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i2;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->repetition_level_histogram ? this_object->repetition_level_histogram->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i2 = 0; i2 < (this_object->repetition_level_histogram ? this_object->repetition_level_histogram->len : 0); i2++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->repetition_level_histogram, gint64, i2)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_definition_level_histogram == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "definition_level_histogram", T_LIST, 3, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i3;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->definition_level_histogram ? this_object->definition_level_histogram->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i3 = 0; i3 < (this_object->definition_level_histogram ? this_object->definition_level_histogram->len : 0); i3++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->definition_level_histogram, gint64, i3)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
size_statistics_set_property (GObject *object,
                              guint property_id,
                              const GValue *value,
                              GParamSpec *pspec)
{
  SizeStatistics *self = SIZE_STATISTICS (object);

  switch (property_id)
  {
    case PROP_SIZE_STATISTICS_UNENCODED_BYTE_ARRAY_DATA_BYTES:
      self->unencoded_byte_array_data_bytes = g_value_get_int64 (value);
      self->__isset_unencoded_byte_array_data_bytes = TRUE;
      break;

    case PROP_SIZE_STATISTICS_REPETITION_LEVEL_HISTOGRAM:
      if (self->repetition_level_histogram != NULL)
        g_array_unref (self->repetition_level_histogram);
      self->repetition_level_histogram = g_value_dup_boxed (value);
      self->__isset_repetition_level_histogram = TRUE;
      break;

    case PROP_SIZE_STATISTICS_DEFINITION_LEVEL_HISTOGRAM:
      if (self->definition_level_histogram != NULL)
        g_array_unref (self->definition_level_histogram);
      self->definition_level_histogram = g_value_dup_boxed (value);
      self->__isset_definition_level_histogram = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
size_statistics_get_property (GObject *object,
                              guint property_id,
                              GValue *value,
                              GParamSpec *pspec)
{
  SizeStatistics *self = SIZE_STATISTICS (object);

  switch (property_id)
  {
    case PROP_SIZE_STATISTICS_UNENCODED_BYTE_ARRAY_DATA_BYTES:
      g_value_set_int64 (value, self->unencoded_byte_array_data_bytes);
      break;

    case PROP_SIZE_STATISTICS_REPETITION_LEVEL_HISTOGRAM:
      g_value_set_boxed (value, self->repetition_level_histogram);
      break;

    case PROP_SIZE_STATISTICS_DEFINITION_LEVEL_HISTOGRAM:
      g_value_set_boxed (value, self->definition_level_histogram);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
size_statistics_instance_init (SizeStatistics * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->unencoded_byte_array_data_bytes = 0;
  object->__isset_unencoded_byte_array_data_bytes = FALSE;
  object->repetition_level_histogram = g_array_new (0, 1, sizeof (gint64));
  object->__isset_repetition_level_histogram = FALSE;
  object->definition_level_histogram = g_array_new (0, 1, sizeof (gint64));
  object->__isset_definition_level_histogram = FALSE;
}

static void 
size_statistics_finalize (GObject *object)
{
  SizeStatistics *tobject = SIZE_STATISTICS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->repetition_level_histogram != NULL)
  {
    g_array_unref (tobject->repetition_level_histogram);
    tobject->repetition_level_histogram = NULL;
  }
  if (tobject->definition_level_histogram != NULL)
  {
    g_array_unref (tobject->definition_level_histogram);
    tobject->definition_level_histogram = NULL;
  }
}

static void
size_statistics_class_init (SizeStatisticsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = size_statistics_read;
  struct_class->write = size_statistics_write;

  gobject_class->finalize = size_statistics_finalize;
  gobject_class->get_property = size_statistics_get_property;
  gobject_class->set_property = size_statistics_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SIZE_STATISTICS_UNENCODED_BYTE_ARRAY_DATA_BYTES,
     g_param_spec_int64 ("unencoded_byte_array_data_bytes",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIZE_STATISTICS_REPETITION_LEVEL_HISTOGRAM,
     g_param_spec_boxed ("repetition_level_histogram",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SIZE_STATISTICS_DEFINITION_LEVEL_HISTOGRAM,
     g_param_spec_boxed ("definition_level_histogram",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
size_statistics_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SizeStatisticsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) size_statistics_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SizeStatistics),
      0, /* n_preallocs */
      (GInstanceInitFunc) size_statistics_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SizeStatisticsType",
                                   &type_info, 0);
  }

  return type;
}

enum _BoundingBoxProperties
{
  PROP_BOUNDING_BOX_0,
  PROP_BOUNDING_BOX_XMIN,
  PROP_BOUNDING_BOX_XMAX,
  PROP_BOUNDING_BOX_YMIN,
  PROP_BOUNDING_BOX_YMAX,
  PROP_BOUNDING_BOX_ZMIN,
  PROP_BOUNDING_BOX_ZMAX,
  PROP_BOUNDING_BOX_MMIN,
  PROP_BOUNDING_BOX_MMAX
};

/* reads a bounding_box object */
static gint32
bounding_box_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BoundingBox * this_object = BOUNDING_BOX(object);
  gboolean isset_xmin = FALSE;
  gboolean isset_xmax = FALSE;
  gboolean isset_ymin = FALSE;
  gboolean isset_ymax = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->xmin, error)) < 0)
            return -1;
          xfer += ret;
          isset_xmin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->xmax, error)) < 0)
            return -1;
          xfer += ret;
          isset_xmax = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->ymin, error)) < 0)
            return -1;
          xfer += ret;
          isset_ymin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->ymax, error)) < 0)
            return -1;
          xfer += ret;
          isset_ymax = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->zmin, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_zmin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->zmax, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_zmax = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->mmin, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mmin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->mmax, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mmax = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_xmin)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_xmax)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_ymin)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_ymax)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
bounding_box_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BoundingBox * this_object = BOUNDING_BOX(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BoundingBox", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "xmin", T_DOUBLE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->xmin, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "xmax", T_DOUBLE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->xmax, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ymin", T_DOUBLE, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->ymin, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ymax", T_DOUBLE, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->ymax, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_zmin == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "zmin", T_DOUBLE, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->zmin, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_zmax == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "zmax", T_DOUBLE, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->zmax, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_mmin == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "mmin", T_DOUBLE, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->mmin, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_mmax == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "mmax", T_DOUBLE, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->mmax, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bounding_box_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  BoundingBox *self = BOUNDING_BOX (object);

  switch (property_id)
  {
    case PROP_BOUNDING_BOX_XMIN:
      self->xmin = g_value_get_double (value);
      break;

    case PROP_BOUNDING_BOX_XMAX:
      self->xmax = g_value_get_double (value);
      break;

    case PROP_BOUNDING_BOX_YMIN:
      self->ymin = g_value_get_double (value);
      break;

    case PROP_BOUNDING_BOX_YMAX:
      self->ymax = g_value_get_double (value);
      break;

    case PROP_BOUNDING_BOX_ZMIN:
      self->zmin = g_value_get_double (value);
      self->__isset_zmin = TRUE;
      break;

    case PROP_BOUNDING_BOX_ZMAX:
      self->zmax = g_value_get_double (value);
      self->__isset_zmax = TRUE;
      break;

    case PROP_BOUNDING_BOX_MMIN:
      self->mmin = g_value_get_double (value);
      self->__isset_mmin = TRUE;
      break;

    case PROP_BOUNDING_BOX_MMAX:
      self->mmax = g_value_get_double (value);
      self->__isset_mmax = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bounding_box_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  BoundingBox *self = BOUNDING_BOX (object);

  switch (property_id)
  {
    case PROP_BOUNDING_BOX_XMIN:
      g_value_set_double (value, self->xmin);
      break;

    case PROP_BOUNDING_BOX_XMAX:
      g_value_set_double (value, self->xmax);
      break;

    case PROP_BOUNDING_BOX_YMIN:
      g_value_set_double (value, self->ymin);
      break;

    case PROP_BOUNDING_BOX_YMAX:
      g_value_set_double (value, self->ymax);
      break;

    case PROP_BOUNDING_BOX_ZMIN:
      g_value_set_double (value, self->zmin);
      break;

    case PROP_BOUNDING_BOX_ZMAX:
      g_value_set_double (value, self->zmax);
      break;

    case PROP_BOUNDING_BOX_MMIN:
      g_value_set_double (value, self->mmin);
      break;

    case PROP_BOUNDING_BOX_MMAX:
      g_value_set_double (value, self->mmax);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bounding_box_instance_init (BoundingBox * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->xmin = 0;
  object->xmax = 0;
  object->ymin = 0;
  object->ymax = 0;
  object->zmin = 0;
  object->__isset_zmin = FALSE;
  object->zmax = 0;
  object->__isset_zmax = FALSE;
  object->mmin = 0;
  object->__isset_mmin = FALSE;
  object->mmax = 0;
  object->__isset_mmax = FALSE;
}

static void 
bounding_box_finalize (GObject *object)
{
  BoundingBox *tobject = BOUNDING_BOX (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bounding_box_class_init (BoundingBoxClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bounding_box_read;
  struct_class->write = bounding_box_write;

  gobject_class->finalize = bounding_box_finalize;
  gobject_class->get_property = bounding_box_get_property;
  gobject_class->set_property = bounding_box_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BOUNDING_BOX_XMIN,
     g_param_spec_double ("xmin",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOUNDING_BOX_XMAX,
     g_param_spec_double ("xmax",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOUNDING_BOX_YMIN,
     g_param_spec_double ("ymin",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOUNDING_BOX_YMAX,
     g_param_spec_double ("ymax",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOUNDING_BOX_ZMIN,
     g_param_spec_double ("zmin",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOUNDING_BOX_ZMAX,
     g_param_spec_double ("zmax",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOUNDING_BOX_MMIN,
     g_param_spec_double ("mmin",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BOUNDING_BOX_MMAX,
     g_param_spec_double ("mmax",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));
}

GType
bounding_box_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BoundingBoxClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bounding_box_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BoundingBox),
      0, /* n_preallocs */
      (GInstanceInitFunc) bounding_box_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BoundingBoxType",
                                   &type_info, 0);
  }

  return type;
}

enum _GeospatialStatisticsProperties
{
  PROP_GEOSPATIAL_STATISTICS_0,
  PROP_GEOSPATIAL_STATISTICS_BBOX,
  PROP_GEOSPATIAL_STATISTICS_GEOSPATIAL_TYPES
};

/* reads a geospatial_statistics object */
static gint32
geospatial_statistics_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  GeospatialStatistics * this_object = GEOSPATIAL_STATISTICS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->bbox), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_bbox = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem4 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem4, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->geospatial_types, _elem4, 1);
              g_free (_elem4);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_geospatial_types = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
geospatial_statistics_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  GeospatialStatistics * this_object = GEOSPATIAL_STATISTICS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "GeospatialStatistics", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_bbox == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "bbox", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->bbox), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_geospatial_types == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "geospatial_types", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i5;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->geospatial_types ? this_object->geospatial_types->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i5 = 0; i5 < (this_object->geospatial_types ? this_object->geospatial_types->len : 0); i5++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->geospatial_types, gint32, i5)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
geospatial_statistics_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  GeospatialStatistics *self = GEOSPATIAL_STATISTICS (object);

  switch (property_id)
  {
    case PROP_GEOSPATIAL_STATISTICS_BBOX:
      if (self->bbox != NULL)
        g_object_unref (self->bbox);
      self->bbox = g_value_dup_object (value);
      self->__isset_bbox = TRUE;
      break;

    case PROP_GEOSPATIAL_STATISTICS_GEOSPATIAL_TYPES:
      if (self->geospatial_types != NULL)
        g_array_unref (self->geospatial_types);
      self->geospatial_types = g_value_dup_boxed (value);
      self->__isset_geospatial_types = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
geospatial_statistics_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  GeospatialStatistics *self = GEOSPATIAL_STATISTICS (object);

  switch (property_id)
  {
    case PROP_GEOSPATIAL_STATISTICS_BBOX:
      g_value_set_object (value, self->bbox);
      break;

    case PROP_GEOSPATIAL_STATISTICS_GEOSPATIAL_TYPES:
      g_value_set_boxed (value, self->geospatial_types);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
geospatial_statistics_instance_init (GeospatialStatistics * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->bbox = g_object_new (TYPE_BOUNDING_BOX, NULL);
  object->__isset_bbox = FALSE;
  object->geospatial_types = g_array_new (0, 1, sizeof (gint32));
  object->__isset_geospatial_types = FALSE;
}

static void 
geospatial_statistics_finalize (GObject *object)
{
  GeospatialStatistics *tobject = GEOSPATIAL_STATISTICS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->bbox != NULL)
  {
    g_object_unref(tobject->bbox);
    tobject->bbox = NULL;
  }
  if (tobject->geospatial_types != NULL)
  {
    g_array_unref (tobject->geospatial_types);
    tobject->geospatial_types = NULL;
  }
}

static void
geospatial_statistics_class_init (GeospatialStatisticsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = geospatial_statistics_read;
  struct_class->write = geospatial_statistics_write;

  gobject_class->finalize = geospatial_statistics_finalize;
  gobject_class->get_property = geospatial_statistics_get_property;
  gobject_class->set_property = geospatial_statistics_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_GEOSPATIAL_STATISTICS_BBOX,
     g_param_spec_object ("bbox",
                         NULL,
                         NULL,
                         TYPE_BOUNDING_BOX,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_GEOSPATIAL_STATISTICS_GEOSPATIAL_TYPES,
     g_param_spec_boxed ("geospatial_types",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
geospatial_statistics_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (GeospatialStatisticsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) geospatial_statistics_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (GeospatialStatistics),
      0, /* n_preallocs */
      (GInstanceInitFunc) geospatial_statistics_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "GeospatialStatisticsType",
                                   &type_info, 0);
  }

  return type;
}

enum _StatisticsProperties
{
  PROP_STATISTICS_0,
  PROP_STATISTICS_MAX,
  PROP_STATISTICS_MIN,
  PROP_STATISTICS_NULL_COUNT,
  PROP_STATISTICS_DISTINCT_COUNT,
  PROP_STATISTICS_MAX_VALUE,
  PROP_STATISTICS_MIN_VALUE,
  PROP_STATISTICS_IS_MAX_VALUE_EXACT,
  PROP_STATISTICS_IS_MIN_VALUE_EXACT
};

/* reads a statistics object */
static gint32
statistics_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Statistics * this_object = STATISTICS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->max != NULL)
          {
            g_free(this_object->max);
            this_object->max = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->max = g_byte_array_new();
          g_byte_array_append (this_object->max, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_max = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->min != NULL)
          {
            g_free(this_object->min);
            this_object->min = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->min = g_byte_array_new();
          g_byte_array_append (this_object->min, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_min = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->null_count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_null_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->distinct_count, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_distinct_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->max_value != NULL)
          {
            g_free(this_object->max_value);
            this_object->max_value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->max_value = g_byte_array_new();
          g_byte_array_append (this_object->max_value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_max_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->min_value != NULL)
          {
            g_free(this_object->min_value);
            this_object->min_value = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->min_value = g_byte_array_new();
          g_byte_array_append (this_object->min_value, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_min_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_max_value_exact, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_max_value_exact = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_min_value_exact, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_min_value_exact = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
statistics_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Statistics * this_object = STATISTICS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Statistics", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_max == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "max", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->max ? ((GByteArray *) this_object->max)->data : NULL, this_object->max ? ((GByteArray *) this_object->max)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_min == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "min", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->min ? ((GByteArray *) this_object->min)->data : NULL, this_object->min ? ((GByteArray *) this_object->min)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_null_count == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "null_count", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->null_count, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_distinct_count == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "distinct_count", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->distinct_count, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_max_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "max_value", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->max_value ? ((GByteArray *) this_object->max_value)->data : NULL, this_object->max_value ? ((GByteArray *) this_object->max_value)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_min_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "min_value", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->min_value ? ((GByteArray *) this_object->min_value)->data : NULL, this_object->min_value ? ((GByteArray *) this_object->min_value)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_is_max_value_exact == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "is_max_value_exact", T_BOOL, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->is_max_value_exact, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_is_min_value_exact == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "is_min_value_exact", T_BOOL, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->is_min_value_exact, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
statistics_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  Statistics *self = STATISTICS (object);

  switch (property_id)
  {
    case PROP_STATISTICS_MAX:
      if (self->max != NULL)
        g_byte_array_unref (self->max);
      self->max = g_value_dup_boxed (value);
      self->__isset_max = TRUE;
      break;

    case PROP_STATISTICS_MIN:
      if (self->min != NULL)
        g_byte_array_unref (self->min);
      self->min = g_value_dup_boxed (value);
      self->__isset_min = TRUE;
      break;

    case PROP_STATISTICS_NULL_COUNT:
      self->null_count = g_value_get_int64 (value);
      self->__isset_null_count = TRUE;
      break;

    case PROP_STATISTICS_DISTINCT_COUNT:
      self->distinct_count = g_value_get_int64 (value);
      self->__isset_distinct_count = TRUE;
      break;

    case PROP_STATISTICS_MAX_VALUE:
      if (self->max_value != NULL)
        g_byte_array_unref (self->max_value);
      self->max_value = g_value_dup_boxed (value);
      self->__isset_max_value = TRUE;
      break;

    case PROP_STATISTICS_MIN_VALUE:
      if (self->min_value != NULL)
        g_byte_array_unref (self->min_value);
      self->min_value = g_value_dup_boxed (value);
      self->__isset_min_value = TRUE;
      break;

    case PROP_STATISTICS_IS_MAX_VALUE_EXACT:
      self->is_max_value_exact = g_value_get_boolean (value);
      self->__isset_is_max_value_exact = TRUE;
      break;

    case PROP_STATISTICS_IS_MIN_VALUE_EXACT:
      self->is_min_value_exact = g_value_get_boolean (value);
      self->__isset_is_min_value_exact = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
statistics_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  Statistics *self = STATISTICS (object);

  switch (property_id)
  {
    case PROP_STATISTICS_MAX:
      g_value_set_boxed (value, self->max);
      break;

    case PROP_STATISTICS_MIN:
      g_value_set_boxed (value, self->min);
      break;

    case PROP_STATISTICS_NULL_COUNT:
      g_value_set_int64 (value, self->null_count);
      break;

    case PROP_STATISTICS_DISTINCT_COUNT:
      g_value_set_int64 (value, self->distinct_count);
      break;

    case PROP_STATISTICS_MAX_VALUE:
      g_value_set_boxed (value, self->max_value);
      break;

    case PROP_STATISTICS_MIN_VALUE:
      g_value_set_boxed (value, self->min_value);
      break;

    case PROP_STATISTICS_IS_MAX_VALUE_EXACT:
      g_value_set_boolean (value, self->is_max_value_exact);
      break;

    case PROP_STATISTICS_IS_MIN_VALUE_EXACT:
      g_value_set_boolean (value, self->is_min_value_exact);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
statistics_instance_init (Statistics * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->max = NULL;
  object->__isset_max = FALSE;
  object->min = NULL;
  object->__isset_min = FALSE;
  object->null_count = 0;
  object->__isset_null_count = FALSE;
  object->distinct_count = 0;
  object->__isset_distinct_count = FALSE;
  object->max_value = NULL;
  object->__isset_max_value = FALSE;
  object->min_value = NULL;
  object->__isset_min_value = FALSE;
  object->is_max_value_exact = 0;
  object->__isset_is_max_value_exact = FALSE;
  object->is_min_value_exact = 0;
  object->__isset_is_min_value_exact = FALSE;
}

static void 
statistics_finalize (GObject *object)
{
  Statistics *tobject = STATISTICS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->max != NULL)
  {
    thrift_string_free(tobject->max);
    tobject->max = NULL;
  }
  if (tobject->min != NULL)
  {
    thrift_string_free(tobject->min);
    tobject->min = NULL;
  }
  if (tobject->max_value != NULL)
  {
    thrift_string_free(tobject->max_value);
    tobject->max_value = NULL;
  }
  if (tobject->min_value != NULL)
  {
    thrift_string_free(tobject->min_value);
    tobject->min_value = NULL;
  }
}

static void
statistics_class_init (StatisticsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = statistics_read;
  struct_class->write = statistics_write;

  gobject_class->finalize = statistics_finalize;
  gobject_class->get_property = statistics_get_property;
  gobject_class->set_property = statistics_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_STATISTICS_MAX,
     g_param_spec_boxed ("max",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATISTICS_MIN,
     g_param_spec_boxed ("min",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATISTICS_NULL_COUNT,
     g_param_spec_int64 ("null_count",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATISTICS_DISTINCT_COUNT,
     g_param_spec_int64 ("distinct_count",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATISTICS_MAX_VALUE,
     g_param_spec_boxed ("max_value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATISTICS_MIN_VALUE,
     g_param_spec_boxed ("min_value",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATISTICS_IS_MAX_VALUE_EXACT,
     g_param_spec_boolean ("is_max_value_exact",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_STATISTICS_IS_MIN_VALUE_EXACT,
     g_param_spec_boolean ("is_min_value_exact",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
statistics_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (StatisticsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) statistics_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Statistics),
      0, /* n_preallocs */
      (GInstanceInitFunc) statistics_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "StatisticsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a string_type object */
static gint32
string_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  StringType * this_object = STRING_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
string_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  StringType * this_object = STRING_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "StringType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
string_type_instance_init (StringType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
string_type_finalize (GObject *object)
{
  StringType *tobject = STRING_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
string_type_class_init (StringTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = string_type_read;
  struct_class->write = string_type_write;

  gobject_class->finalize = string_type_finalize;
}

GType
string_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (StringTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) string_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (StringType),
      0, /* n_preallocs */
      (GInstanceInitFunc) string_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "StringTypeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a u_u_i_d_type object */
static gint32
u_u_i_d_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  UUIDType * this_object = U_U_I_D_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
u_u_i_d_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  UUIDType * this_object = U_U_I_D_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UUIDType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
u_u_i_d_type_instance_init (UUIDType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
u_u_i_d_type_finalize (GObject *object)
{
  UUIDType *tobject = U_U_I_D_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
u_u_i_d_type_class_init (UUIDTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = u_u_i_d_type_read;
  struct_class->write = u_u_i_d_type_write;

  gobject_class->finalize = u_u_i_d_type_finalize;
}

GType
u_u_i_d_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UUIDTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) u_u_i_d_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (UUIDType),
      0, /* n_preallocs */
      (GInstanceInitFunc) u_u_i_d_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UUIDTypeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a map_type object */
static gint32
map_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  MapType * this_object = MAP_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
map_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  MapType * this_object = MAP_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "MapType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
map_type_instance_init (MapType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
map_type_finalize (GObject *object)
{
  MapType *tobject = MAP_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
map_type_class_init (MapTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = map_type_read;
  struct_class->write = map_type_write;

  gobject_class->finalize = map_type_finalize;
}

GType
map_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (MapTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) map_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (MapType),
      0, /* n_preallocs */
      (GInstanceInitFunc) map_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "MapTypeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a list_type object */
static gint32
list_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ListType * this_object = LIST_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
list_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ListType * this_object = LIST_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ListType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
list_type_instance_init (ListType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
list_type_finalize (GObject *object)
{
  ListType *tobject = LIST_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
list_type_class_init (ListTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = list_type_read;
  struct_class->write = list_type_write;

  gobject_class->finalize = list_type_finalize;
}

GType
list_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ListTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) list_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ListType),
      0, /* n_preallocs */
      (GInstanceInitFunc) list_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ListTypeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a enum_type object */
static gint32
enum_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EnumType * this_object = ENUM_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
enum_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EnumType * this_object = ENUM_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EnumType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
enum_type_instance_init (EnumType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
enum_type_finalize (GObject *object)
{
  EnumType *tobject = ENUM_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
enum_type_class_init (EnumTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = enum_type_read;
  struct_class->write = enum_type_write;

  gobject_class->finalize = enum_type_finalize;
}

GType
enum_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EnumTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) enum_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EnumType),
      0, /* n_preallocs */
      (GInstanceInitFunc) enum_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EnumTypeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a date_type object */
static gint32
date_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DateType * this_object = DATE_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
date_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DateType * this_object = DATE_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DateType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
date_type_instance_init (DateType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
date_type_finalize (GObject *object)
{
  DateType *tobject = DATE_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
date_type_class_init (DateTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = date_type_read;
  struct_class->write = date_type_write;

  gobject_class->finalize = date_type_finalize;
}

GType
date_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DateTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) date_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DateType),
      0, /* n_preallocs */
      (GInstanceInitFunc) date_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DateTypeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a float16_type object */
static gint32
float16_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Float16Type * this_object = FLOAT16_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
float16_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Float16Type * this_object = FLOAT16_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Float16Type", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
float16_type_instance_init (Float16Type * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
float16_type_finalize (GObject *object)
{
  Float16Type *tobject = FLOAT16_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
float16_type_class_init (Float16TypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = float16_type_read;
  struct_class->write = float16_type_write;

  gobject_class->finalize = float16_type_finalize;
}

GType
float16_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (Float16TypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) float16_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Float16Type),
      0, /* n_preallocs */
      (GInstanceInitFunc) float16_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "Float16TypeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a null_type object */
static gint32
null_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NullType * this_object = NULL_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
null_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NullType * this_object = NULL_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NullType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
null_type_instance_init (NullType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
null_type_finalize (GObject *object)
{
  NullType *tobject = NULL_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
null_type_class_init (NullTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = null_type_read;
  struct_class->write = null_type_write;

  gobject_class->finalize = null_type_finalize;
}

GType
null_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NullTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) null_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NullType),
      0, /* n_preallocs */
      (GInstanceInitFunc) null_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NullTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _DecimalTypeProperties
{
  PROP_DECIMAL_TYPE_0,
  PROP_DECIMAL_TYPE_SCALE,
  PROP_DECIMAL_TYPE_PRECISION
};

/* reads a decimal_type object */
static gint32
decimal_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DecimalType * this_object = DECIMAL_TYPE(object);
  gboolean isset_scale = FALSE;
  gboolean isset_precision = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->scale, error)) < 0)
            return -1;
          xfer += ret;
          isset_scale = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->precision, error)) < 0)
            return -1;
          xfer += ret;
          isset_precision = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_scale)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_precision)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
decimal_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DecimalType * this_object = DECIMAL_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DecimalType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "scale", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->scale, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "precision", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->precision, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
decimal_type_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  DecimalType *self = DECIMAL_TYPE (object);

  switch (property_id)
  {
    case PROP_DECIMAL_TYPE_SCALE:
      self->scale = g_value_get_int (value);
      break;

    case PROP_DECIMAL_TYPE_PRECISION:
      self->precision = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
decimal_type_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  DecimalType *self = DECIMAL_TYPE (object);

  switch (property_id)
  {
    case PROP_DECIMAL_TYPE_SCALE:
      g_value_set_int (value, self->scale);
      break;

    case PROP_DECIMAL_TYPE_PRECISION:
      g_value_set_int (value, self->precision);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
decimal_type_instance_init (DecimalType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->scale = 0;
  object->precision = 0;
}

static void 
decimal_type_finalize (GObject *object)
{
  DecimalType *tobject = DECIMAL_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
decimal_type_class_init (DecimalTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = decimal_type_read;
  struct_class->write = decimal_type_write;

  gobject_class->finalize = decimal_type_finalize;
  gobject_class->get_property = decimal_type_get_property;
  gobject_class->set_property = decimal_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DECIMAL_TYPE_SCALE,
     g_param_spec_int ("scale",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DECIMAL_TYPE_PRECISION,
     g_param_spec_int ("precision",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
decimal_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DecimalTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) decimal_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DecimalType),
      0, /* n_preallocs */
      (GInstanceInitFunc) decimal_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DecimalTypeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a milli_seconds object */
static gint32
milli_seconds_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  MilliSeconds * this_object = MILLI_SECONDS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
milli_seconds_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  MilliSeconds * this_object = MILLI_SECONDS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "MilliSeconds", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
milli_seconds_instance_init (MilliSeconds * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
milli_seconds_finalize (GObject *object)
{
  MilliSeconds *tobject = MILLI_SECONDS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
milli_seconds_class_init (MilliSecondsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = milli_seconds_read;
  struct_class->write = milli_seconds_write;

  gobject_class->finalize = milli_seconds_finalize;
}

GType
milli_seconds_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (MilliSecondsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) milli_seconds_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (MilliSeconds),
      0, /* n_preallocs */
      (GInstanceInitFunc) milli_seconds_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "MilliSecondsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a micro_seconds object */
static gint32
micro_seconds_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  MicroSeconds * this_object = MICRO_SECONDS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
micro_seconds_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  MicroSeconds * this_object = MICRO_SECONDS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "MicroSeconds", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
micro_seconds_instance_init (MicroSeconds * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
micro_seconds_finalize (GObject *object)
{
  MicroSeconds *tobject = MICRO_SECONDS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
micro_seconds_class_init (MicroSecondsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = micro_seconds_read;
  struct_class->write = micro_seconds_write;

  gobject_class->finalize = micro_seconds_finalize;
}

GType
micro_seconds_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (MicroSecondsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) micro_seconds_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (MicroSeconds),
      0, /* n_preallocs */
      (GInstanceInitFunc) micro_seconds_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "MicroSecondsType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a nano_seconds object */
static gint32
nano_seconds_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  NanoSeconds * this_object = NANO_SECONDS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
nano_seconds_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  NanoSeconds * this_object = NANO_SECONDS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "NanoSeconds", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
nano_seconds_instance_init (NanoSeconds * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
nano_seconds_finalize (GObject *object)
{
  NanoSeconds *tobject = NANO_SECONDS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
nano_seconds_class_init (NanoSecondsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = nano_seconds_read;
  struct_class->write = nano_seconds_write;

  gobject_class->finalize = nano_seconds_finalize;
}

GType
nano_seconds_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NanoSecondsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) nano_seconds_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (NanoSeconds),
      0, /* n_preallocs */
      (GInstanceInitFunc) nano_seconds_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NanoSecondsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimeUnitProperties
{
  PROP_TIME_UNIT_0,
  PROP_TIME_UNIT_M_I_L_L_I_S,
  PROP_TIME_UNIT_M_I_C_R_O_S,
  PROP_TIME_UNIT_N_A_N_O_S
};

/* reads a time_unit object */
static gint32
time_unit_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimeUnit * this_object = TIME_UNIT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->MILLIS), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_MILLIS = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->MICROS), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_MICROS = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->NANOS), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_NANOS = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
time_unit_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimeUnit * this_object = TIME_UNIT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimeUnit", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_MILLIS == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "MILLIS", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->MILLIS), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_MICROS == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "MICROS", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->MICROS), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_NANOS == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "NANOS", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->NANOS), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
time_unit_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  TimeUnit *self = TIME_UNIT (object);

  switch (property_id)
  {
    case PROP_TIME_UNIT_M_I_L_L_I_S:
      if (self->MILLIS != NULL)
        g_object_unref (self->MILLIS);
      self->MILLIS = g_value_dup_object (value);
      self->__isset_MILLIS = TRUE;
      break;

    case PROP_TIME_UNIT_M_I_C_R_O_S:
      if (self->MICROS != NULL)
        g_object_unref (self->MICROS);
      self->MICROS = g_value_dup_object (value);
      self->__isset_MICROS = TRUE;
      break;

    case PROP_TIME_UNIT_N_A_N_O_S:
      if (self->NANOS != NULL)
        g_object_unref (self->NANOS);
      self->NANOS = g_value_dup_object (value);
      self->__isset_NANOS = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
time_unit_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  TimeUnit *self = TIME_UNIT (object);

  switch (property_id)
  {
    case PROP_TIME_UNIT_M_I_L_L_I_S:
      g_value_set_object (value, self->MILLIS);
      break;

    case PROP_TIME_UNIT_M_I_C_R_O_S:
      g_value_set_object (value, self->MICROS);
      break;

    case PROP_TIME_UNIT_N_A_N_O_S:
      g_value_set_object (value, self->NANOS);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
time_unit_instance_init (TimeUnit * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->MILLIS = g_object_new (TYPE_MILLI_SECONDS, NULL);
  object->__isset_MILLIS = FALSE;
  object->MICROS = g_object_new (TYPE_MICRO_SECONDS, NULL);
  object->__isset_MICROS = FALSE;
  object->NANOS = g_object_new (TYPE_NANO_SECONDS, NULL);
  object->__isset_NANOS = FALSE;
}

static void 
time_unit_finalize (GObject *object)
{
  TimeUnit *tobject = TIME_UNIT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->MILLIS != NULL)
  {
    g_object_unref(tobject->MILLIS);
    tobject->MILLIS = NULL;
  }
  if (tobject->MICROS != NULL)
  {
    g_object_unref(tobject->MICROS);
    tobject->MICROS = NULL;
  }
  if (tobject->NANOS != NULL)
  {
    g_object_unref(tobject->NANOS);
    tobject->NANOS = NULL;
  }
}

static void
time_unit_class_init (TimeUnitClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = time_unit_read;
  struct_class->write = time_unit_write;

  gobject_class->finalize = time_unit_finalize;
  gobject_class->get_property = time_unit_get_property;
  gobject_class->set_property = time_unit_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIME_UNIT_M_I_L_L_I_S,
     g_param_spec_object ("MILLIS",
                         NULL,
                         NULL,
                         TYPE_MILLI_SECONDS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIME_UNIT_M_I_C_R_O_S,
     g_param_spec_object ("MICROS",
                         NULL,
                         NULL,
                         TYPE_MICRO_SECONDS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIME_UNIT_N_A_N_O_S,
     g_param_spec_object ("NANOS",
                         NULL,
                         NULL,
                         TYPE_NANO_SECONDS,
                         G_PARAM_READWRITE));
}

GType
time_unit_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimeUnitClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) time_unit_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimeUnit),
      0, /* n_preallocs */
      (GInstanceInitFunc) time_unit_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimeUnitType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimestampTypeProperties
{
  PROP_TIMESTAMP_TYPE_0,
  PROP_TIMESTAMP_TYPE_IS_ADJUSTED_TO_U_T_C,
  PROP_TIMESTAMP_TYPE_UNIT
};

/* reads a timestamp_type object */
static gint32
timestamp_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimestampType * this_object = TIMESTAMP_TYPE(object);
  gboolean isset_isAdjustedToUTC = FALSE;
  gboolean isset_unit = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isAdjustedToUTC, error)) < 0)
            return -1;
          xfer += ret;
          isset_isAdjustedToUTC = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->unit), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_unit = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_isAdjustedToUTC)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_unit)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
timestamp_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimestampType * this_object = TIMESTAMP_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimestampType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isAdjustedToUTC", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isAdjustedToUTC, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "unit", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->unit), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
timestamp_type_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TimestampType *self = TIMESTAMP_TYPE (object);

  switch (property_id)
  {
    case PROP_TIMESTAMP_TYPE_IS_ADJUSTED_TO_U_T_C:
      self->isAdjustedToUTC = g_value_get_boolean (value);
      break;

    case PROP_TIMESTAMP_TYPE_UNIT:
      if (self->unit != NULL)
        g_object_unref (self->unit);
      self->unit = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
timestamp_type_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TimestampType *self = TIMESTAMP_TYPE (object);

  switch (property_id)
  {
    case PROP_TIMESTAMP_TYPE_IS_ADJUSTED_TO_U_T_C:
      g_value_set_boolean (value, self->isAdjustedToUTC);
      break;

    case PROP_TIMESTAMP_TYPE_UNIT:
      g_value_set_object (value, self->unit);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
timestamp_type_instance_init (TimestampType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->isAdjustedToUTC = 0;
  object->unit = g_object_new (TYPE_TIME_UNIT, NULL);
}

static void 
timestamp_type_finalize (GObject *object)
{
  TimestampType *tobject = TIMESTAMP_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->unit != NULL)
  {
    g_object_unref(tobject->unit);
    tobject->unit = NULL;
  }
}

static void
timestamp_type_class_init (TimestampTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = timestamp_type_read;
  struct_class->write = timestamp_type_write;

  gobject_class->finalize = timestamp_type_finalize;
  gobject_class->get_property = timestamp_type_get_property;
  gobject_class->set_property = timestamp_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIMESTAMP_TYPE_IS_ADJUSTED_TO_U_T_C,
     g_param_spec_boolean ("isAdjustedToUTC",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIMESTAMP_TYPE_UNIT,
     g_param_spec_object ("unit",
                         NULL,
                         NULL,
                         TYPE_TIME_UNIT,
                         G_PARAM_READWRITE));
}

GType
timestamp_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimestampTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) timestamp_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimestampType),
      0, /* n_preallocs */
      (GInstanceInitFunc) timestamp_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimestampTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _TimeTypeProperties
{
  PROP_TIME_TYPE_0,
  PROP_TIME_TYPE_IS_ADJUSTED_TO_U_T_C,
  PROP_TIME_TYPE_UNIT
};

/* reads a time_type object */
static gint32
time_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TimeType * this_object = TIME_TYPE(object);
  gboolean isset_isAdjustedToUTC = FALSE;
  gboolean isset_unit = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isAdjustedToUTC, error)) < 0)
            return -1;
          xfer += ret;
          isset_isAdjustedToUTC = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->unit), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_unit = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_isAdjustedToUTC)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_unit)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
time_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TimeType * this_object = TIME_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TimeType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isAdjustedToUTC", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isAdjustedToUTC, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "unit", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->unit), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
time_type_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  TimeType *self = TIME_TYPE (object);

  switch (property_id)
  {
    case PROP_TIME_TYPE_IS_ADJUSTED_TO_U_T_C:
      self->isAdjustedToUTC = g_value_get_boolean (value);
      break;

    case PROP_TIME_TYPE_UNIT:
      if (self->unit != NULL)
        g_object_unref (self->unit);
      self->unit = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
time_type_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  TimeType *self = TIME_TYPE (object);

  switch (property_id)
  {
    case PROP_TIME_TYPE_IS_ADJUSTED_TO_U_T_C:
      g_value_set_boolean (value, self->isAdjustedToUTC);
      break;

    case PROP_TIME_TYPE_UNIT:
      g_value_set_object (value, self->unit);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
time_type_instance_init (TimeType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->isAdjustedToUTC = 0;
  object->unit = g_object_new (TYPE_TIME_UNIT, NULL);
}

static void 
time_type_finalize (GObject *object)
{
  TimeType *tobject = TIME_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->unit != NULL)
  {
    g_object_unref(tobject->unit);
    tobject->unit = NULL;
  }
}

static void
time_type_class_init (TimeTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = time_type_read;
  struct_class->write = time_type_write;

  gobject_class->finalize = time_type_finalize;
  gobject_class->get_property = time_type_get_property;
  gobject_class->set_property = time_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TIME_TYPE_IS_ADJUSTED_TO_U_T_C,
     g_param_spec_boolean ("isAdjustedToUTC",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TIME_TYPE_UNIT,
     g_param_spec_object ("unit",
                         NULL,
                         NULL,
                         TYPE_TIME_UNIT,
                         G_PARAM_READWRITE));
}

GType
time_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TimeTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) time_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TimeType),
      0, /* n_preallocs */
      (GInstanceInitFunc) time_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TimeTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _IntTypeProperties
{
  PROP_INT_TYPE_0,
  PROP_INT_TYPE_BIT_WIDTH,
  PROP_INT_TYPE_IS_SIGNED
};

/* reads a int_type object */
static gint32
int_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IntType * this_object = INT_TYPE(object);
  gboolean isset_bitWidth = FALSE;
  gboolean isset_isSigned = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->bitWidth, error)) < 0)
            return -1;
          xfer += ret;
          isset_bitWidth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isSigned, error)) < 0)
            return -1;
          xfer += ret;
          isset_isSigned = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_bitWidth)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_isSigned)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
int_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IntType * this_object = INT_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IntType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "bitWidth", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->bitWidth, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isSigned", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isSigned, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
int_type_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  IntType *self = INT_TYPE (object);

  switch (property_id)
  {
    case PROP_INT_TYPE_BIT_WIDTH:
      self->bitWidth = g_value_get_int (value);
      break;

    case PROP_INT_TYPE_IS_SIGNED:
      self->isSigned = g_value_get_boolean (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
int_type_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  IntType *self = INT_TYPE (object);

  switch (property_id)
  {
    case PROP_INT_TYPE_BIT_WIDTH:
      g_value_set_int (value, self->bitWidth);
      break;

    case PROP_INT_TYPE_IS_SIGNED:
      g_value_set_boolean (value, self->isSigned);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
int_type_instance_init (IntType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->bitWidth = 0;
  object->isSigned = 0;
}

static void 
int_type_finalize (GObject *object)
{
  IntType *tobject = INT_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
int_type_class_init (IntTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = int_type_read;
  struct_class->write = int_type_write;

  gobject_class->finalize = int_type_finalize;
  gobject_class->get_property = int_type_get_property;
  gobject_class->set_property = int_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_INT_TYPE_BIT_WIDTH,
     g_param_spec_int ("bitWidth",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_INT_TYPE_IS_SIGNED,
     g_param_spec_boolean ("isSigned",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
int_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IntTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) int_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IntType),
      0, /* n_preallocs */
      (GInstanceInitFunc) int_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IntTypeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a json_type object */
static gint32
json_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  JsonType * this_object = JSON_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
json_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  JsonType * this_object = JSON_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "JsonType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
json_type_instance_init (JsonType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
json_type_finalize (GObject *object)
{
  JsonType *tobject = JSON_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
json_type_class_init (JsonTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = json_type_read;
  struct_class->write = json_type_write;

  gobject_class->finalize = json_type_finalize;
}

GType
json_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (JsonTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) json_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (JsonType),
      0, /* n_preallocs */
      (GInstanceInitFunc) json_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "JsonTypeType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a bson_type object */
static gint32
bson_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BsonType * this_object = BSON_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bson_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BsonType * this_object = BSON_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BsonType", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
bson_type_instance_init (BsonType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
bson_type_finalize (GObject *object)
{
  BsonType *tobject = BSON_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
bson_type_class_init (BsonTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bson_type_read;
  struct_class->write = bson_type_write;

  gobject_class->finalize = bson_type_finalize;
}

GType
bson_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BsonTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bson_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BsonType),
      0, /* n_preallocs */
      (GInstanceInitFunc) bson_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BsonTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _VariantTypeProperties
{
  PROP_VARIANT_TYPE_0,
  PROP_VARIANT_TYPE_SPECIFICATION_VERSION
};

/* reads a variant_type object */
static gint32
variant_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  VariantType * this_object = VARIANT_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->specification_version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_specification_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
variant_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  VariantType * this_object = VARIANT_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "VariantType", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_specification_version == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "specification_version", T_BYTE, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->specification_version, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
variant_type_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  VariantType *self = VARIANT_TYPE (object);

  switch (property_id)
  {
    case PROP_VARIANT_TYPE_SPECIFICATION_VERSION:
      self->specification_version = g_value_get_int (value);
      self->__isset_specification_version = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
variant_type_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  VariantType *self = VARIANT_TYPE (object);

  switch (property_id)
  {
    case PROP_VARIANT_TYPE_SPECIFICATION_VERSION:
      g_value_set_int (value, self->specification_version);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
variant_type_instance_init (VariantType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->specification_version = 0;
  object->__isset_specification_version = FALSE;
}

static void 
variant_type_finalize (GObject *object)
{
  VariantType *tobject = VARIANT_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
variant_type_class_init (VariantTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = variant_type_read;
  struct_class->write = variant_type_write;

  gobject_class->finalize = variant_type_finalize;
  gobject_class->get_property = variant_type_get_property;
  gobject_class->set_property = variant_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_VARIANT_TYPE_SPECIFICATION_VERSION,
     g_param_spec_int ("specification_version",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
variant_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (VariantTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) variant_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (VariantType),
      0, /* n_preallocs */
      (GInstanceInitFunc) variant_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "VariantTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _GeometryTypeProperties
{
  PROP_GEOMETRY_TYPE_0,
  PROP_GEOMETRY_TYPE_CRS
};

/* reads a geometry_type object */
static gint32
geometry_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  GeometryType * this_object = GEOMETRY_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->crs != NULL)
          {
            g_free(this_object->crs);
            this_object->crs = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->crs, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_crs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
geometry_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  GeometryType * this_object = GEOMETRY_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "GeometryType", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_crs == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "crs", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->crs, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
geometry_type_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  GeometryType *self = GEOMETRY_TYPE (object);

  switch (property_id)
  {
    case PROP_GEOMETRY_TYPE_CRS:
      if (self->crs != NULL)
        g_free (self->crs);
      self->crs = g_value_dup_string (value);
      self->__isset_crs = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
geometry_type_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  GeometryType *self = GEOMETRY_TYPE (object);

  switch (property_id)
  {
    case PROP_GEOMETRY_TYPE_CRS:
      g_value_set_string (value, self->crs);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
geometry_type_instance_init (GeometryType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->crs = NULL;
  object->__isset_crs = FALSE;
}

static void 
geometry_type_finalize (GObject *object)
{
  GeometryType *tobject = GEOMETRY_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->crs != NULL)
  {
    g_free(tobject->crs);
    tobject->crs = NULL;
  }
}

static void
geometry_type_class_init (GeometryTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = geometry_type_read;
  struct_class->write = geometry_type_write;

  gobject_class->finalize = geometry_type_finalize;
  gobject_class->get_property = geometry_type_get_property;
  gobject_class->set_property = geometry_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_GEOMETRY_TYPE_CRS,
     g_param_spec_string ("crs",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
geometry_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (GeometryTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) geometry_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (GeometryType),
      0, /* n_preallocs */
      (GInstanceInitFunc) geometry_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "GeometryTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _GeographyTypeProperties
{
  PROP_GEOGRAPHY_TYPE_0,
  PROP_GEOGRAPHY_TYPE_CRS,
  PROP_GEOGRAPHY_TYPE_ALGORITHM
};

/* reads a geography_type object */
static gint32
geography_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  GeographyType * this_object = GEOGRAPHY_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->crs != NULL)
          {
            g_free(this_object->crs);
            this_object->crs = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->crs, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_crs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast6;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->algorithm = (EdgeInterpolationAlgorithm)ecast6;
          this_object->__isset_algorithm = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
geography_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  GeographyType * this_object = GEOGRAPHY_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "GeographyType", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_crs == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "crs", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->crs, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_algorithm == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "algorithm", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->algorithm, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
geography_type_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  GeographyType *self = GEOGRAPHY_TYPE (object);

  switch (property_id)
  {
    case PROP_GEOGRAPHY_TYPE_CRS:
      if (self->crs != NULL)
        g_free (self->crs);
      self->crs = g_value_dup_string (value);
      self->__isset_crs = TRUE;
      break;

    case PROP_GEOGRAPHY_TYPE_ALGORITHM:
      self->algorithm = g_value_get_int (value);
      self->__isset_algorithm = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
geography_type_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  GeographyType *self = GEOGRAPHY_TYPE (object);

  switch (property_id)
  {
    case PROP_GEOGRAPHY_TYPE_CRS:
      g_value_set_string (value, self->crs);
      break;

    case PROP_GEOGRAPHY_TYPE_ALGORITHM:
      g_value_set_int (value, self->algorithm);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
geography_type_instance_init (GeographyType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->crs = NULL;
  object->__isset_crs = FALSE;
  object->__isset_algorithm = FALSE;
}

static void 
geography_type_finalize (GObject *object)
{
  GeographyType *tobject = GEOGRAPHY_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->crs != NULL)
  {
    g_free(tobject->crs);
    tobject->crs = NULL;
  }
}

static void
geography_type_class_init (GeographyTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = geography_type_read;
  struct_class->write = geography_type_write;

  gobject_class->finalize = geography_type_finalize;
  gobject_class->get_property = geography_type_get_property;
  gobject_class->set_property = geography_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_GEOGRAPHY_TYPE_CRS,
     g_param_spec_string ("crs",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_GEOGRAPHY_TYPE_ALGORITHM,
     g_param_spec_int ("algorithm",
                       NULL,
                       NULL,
                       0,
                       4,
                       0,
                       G_PARAM_READWRITE));
}

GType
geography_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (GeographyTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) geography_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (GeographyType),
      0, /* n_preallocs */
      (GInstanceInitFunc) geography_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "GeographyTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _LogicalTypeProperties
{
  PROP_LOGICAL_TYPE_0,
  PROP_LOGICAL_TYPE_S_T_R_I_N_G,
  PROP_LOGICAL_TYPE_M_A_P,
  PROP_LOGICAL_TYPE_L_I_S_T,
  PROP_LOGICAL_TYPE_E_N_U_M,
  PROP_LOGICAL_TYPE_D_E_C_I_M_A_L,
  PROP_LOGICAL_TYPE_D_A_T_E,
  PROP_LOGICAL_TYPE_T_I_M_E,
  PROP_LOGICAL_TYPE_T_I_M_E_S_T_A_M_P,
  PROP_LOGICAL_TYPE_I_N_T_E_G_E_R,
  PROP_LOGICAL_TYPE_U_N_K_N_O_W_N,
  PROP_LOGICAL_TYPE_J_S_O_N,
  PROP_LOGICAL_TYPE_B_S_O_N,
  PROP_LOGICAL_TYPE_U_U_I_D,
  PROP_LOGICAL_TYPE_F_L_O_A_T16,
  PROP_LOGICAL_TYPE_V_A_R_I_A_N_T,
  PROP_LOGICAL_TYPE_G_E_O_M_E_T_R_Y,
  PROP_LOGICAL_TYPE_G_E_O_G_R_A_P_H_Y
};

/* reads a logical_type object */
static gint32
logical_type_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LogicalType * this_object = LOGICAL_TYPE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->STRING), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_STRING = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->MAP), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_MAP = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->LIST), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_LIST = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ENUM), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ENUM = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->DECIMAL), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_DECIMAL = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->DATE), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_DATE = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->TIME), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_TIME = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->TIMESTAMP), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_TIMESTAMP = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->INTEGER), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_INTEGER = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->UNKNOWN), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_UNKNOWN = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->JSON), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_JSON = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->BSON), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_BSON = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->UUID), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_UUID = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->FLOAT16), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_FLOAT16 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->VARIANT), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_VARIANT = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->GEOMETRY), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_GEOMETRY = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 18:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->GEOGRAPHY), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_GEOGRAPHY = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
logical_type_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LogicalType * this_object = LOGICAL_TYPE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LogicalType", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_STRING == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "STRING", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->STRING), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_MAP == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "MAP", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->MAP), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_LIST == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "LIST", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->LIST), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ENUM == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ENUM", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ENUM), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_DECIMAL == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "DECIMAL", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->DECIMAL), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_DATE == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "DATE", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->DATE), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_TIME == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "TIME", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->TIME), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_TIMESTAMP == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "TIMESTAMP", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->TIMESTAMP), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_INTEGER == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "INTEGER", T_STRUCT, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->INTEGER), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_UNKNOWN == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "UNKNOWN", T_STRUCT, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->UNKNOWN), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_JSON == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "JSON", T_STRUCT, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->JSON), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_BSON == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "BSON", T_STRUCT, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->BSON), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_UUID == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "UUID", T_STRUCT, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->UUID), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_FLOAT16 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "FLOAT16", T_STRUCT, 15, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->FLOAT16), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_VARIANT == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "VARIANT", T_STRUCT, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->VARIANT), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_GEOMETRY == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "GEOMETRY", T_STRUCT, 17, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->GEOMETRY), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_GEOGRAPHY == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "GEOGRAPHY", T_STRUCT, 18, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->GEOGRAPHY), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
logical_type_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  LogicalType *self = LOGICAL_TYPE (object);

  switch (property_id)
  {
    case PROP_LOGICAL_TYPE_S_T_R_I_N_G:
      if (self->STRING != NULL)
        g_object_unref (self->STRING);
      self->STRING = g_value_dup_object (value);
      self->__isset_STRING = TRUE;
      break;

    case PROP_LOGICAL_TYPE_M_A_P:
      if (self->MAP != NULL)
        g_object_unref (self->MAP);
      self->MAP = g_value_dup_object (value);
      self->__isset_MAP = TRUE;
      break;

    case PROP_LOGICAL_TYPE_L_I_S_T:
      if (self->LIST != NULL)
        g_object_unref (self->LIST);
      self->LIST = g_value_dup_object (value);
      self->__isset_LIST = TRUE;
      break;

    case PROP_LOGICAL_TYPE_E_N_U_M:
      if (self->ENUM != NULL)
        g_object_unref (self->ENUM);
      self->ENUM = g_value_dup_object (value);
      self->__isset_ENUM = TRUE;
      break;

    case PROP_LOGICAL_TYPE_D_E_C_I_M_A_L:
      if (self->DECIMAL != NULL)
        g_object_unref (self->DECIMAL);
      self->DECIMAL = g_value_dup_object (value);
      self->__isset_DECIMAL = TRUE;
      break;

    case PROP_LOGICAL_TYPE_D_A_T_E:
      if (self->DATE != NULL)
        g_object_unref (self->DATE);
      self->DATE = g_value_dup_object (value);
      self->__isset_DATE = TRUE;
      break;

    case PROP_LOGICAL_TYPE_T_I_M_E:
      if (self->TIME != NULL)
        g_object_unref (self->TIME);
      self->TIME = g_value_dup_object (value);
      self->__isset_TIME = TRUE;
      break;

    case PROP_LOGICAL_TYPE_T_I_M_E_S_T_A_M_P:
      if (self->TIMESTAMP != NULL)
        g_object_unref (self->TIMESTAMP);
      self->TIMESTAMP = g_value_dup_object (value);
      self->__isset_TIMESTAMP = TRUE;
      break;

    case PROP_LOGICAL_TYPE_I_N_T_E_G_E_R:
      if (self->INTEGER != NULL)
        g_object_unref (self->INTEGER);
      self->INTEGER = g_value_dup_object (value);
      self->__isset_INTEGER = TRUE;
      break;

    case PROP_LOGICAL_TYPE_U_N_K_N_O_W_N:
      if (self->UNKNOWN != NULL)
        g_object_unref (self->UNKNOWN);
      self->UNKNOWN = g_value_dup_object (value);
      self->__isset_UNKNOWN = TRUE;
      break;

    case PROP_LOGICAL_TYPE_J_S_O_N:
      if (self->JSON != NULL)
        g_object_unref (self->JSON);
      self->JSON = g_value_dup_object (value);
      self->__isset_JSON = TRUE;
      break;

    case PROP_LOGICAL_TYPE_B_S_O_N:
      if (self->BSON != NULL)
        g_object_unref (self->BSON);
      self->BSON = g_value_dup_object (value);
      self->__isset_BSON = TRUE;
      break;

    case PROP_LOGICAL_TYPE_U_U_I_D:
      if (self->UUID != NULL)
        g_object_unref (self->UUID);
      self->UUID = g_value_dup_object (value);
      self->__isset_UUID = TRUE;
      break;

    case PROP_LOGICAL_TYPE_F_L_O_A_T16:
      if (self->FLOAT16 != NULL)
        g_object_unref (self->FLOAT16);
      self->FLOAT16 = g_value_dup_object (value);
      self->__isset_FLOAT16 = TRUE;
      break;

    case PROP_LOGICAL_TYPE_V_A_R_I_A_N_T:
      if (self->VARIANT != NULL)
        g_object_unref (self->VARIANT);
      self->VARIANT = g_value_dup_object (value);
      self->__isset_VARIANT = TRUE;
      break;

    case PROP_LOGICAL_TYPE_G_E_O_M_E_T_R_Y:
      if (self->GEOMETRY != NULL)
        g_object_unref (self->GEOMETRY);
      self->GEOMETRY = g_value_dup_object (value);
      self->__isset_GEOMETRY = TRUE;
      break;

    case PROP_LOGICAL_TYPE_G_E_O_G_R_A_P_H_Y:
      if (self->GEOGRAPHY != NULL)
        g_object_unref (self->GEOGRAPHY);
      self->GEOGRAPHY = g_value_dup_object (value);
      self->__isset_GEOGRAPHY = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
logical_type_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  LogicalType *self = LOGICAL_TYPE (object);

  switch (property_id)
  {
    case PROP_LOGICAL_TYPE_S_T_R_I_N_G:
      g_value_set_object (value, self->STRING);
      break;

    case PROP_LOGICAL_TYPE_M_A_P:
      g_value_set_object (value, self->MAP);
      break;

    case PROP_LOGICAL_TYPE_L_I_S_T:
      g_value_set_object (value, self->LIST);
      break;

    case PROP_LOGICAL_TYPE_E_N_U_M:
      g_value_set_object (value, self->ENUM);
      break;

    case PROP_LOGICAL_TYPE_D_E_C_I_M_A_L:
      g_value_set_object (value, self->DECIMAL);
      break;

    case PROP_LOGICAL_TYPE_D_A_T_E:
      g_value_set_object (value, self->DATE);
      break;

    case PROP_LOGICAL_TYPE_T_I_M_E:
      g_value_set_object (value, self->TIME);
      break;

    case PROP_LOGICAL_TYPE_T_I_M_E_S_T_A_M_P:
      g_value_set_object (value, self->TIMESTAMP);
      break;

    case PROP_LOGICAL_TYPE_I_N_T_E_G_E_R:
      g_value_set_object (value, self->INTEGER);
      break;

    case PROP_LOGICAL_TYPE_U_N_K_N_O_W_N:
      g_value_set_object (value, self->UNKNOWN);
      break;

    case PROP_LOGICAL_TYPE_J_S_O_N:
      g_value_set_object (value, self->JSON);
      break;

    case PROP_LOGICAL_TYPE_B_S_O_N:
      g_value_set_object (value, self->BSON);
      break;

    case PROP_LOGICAL_TYPE_U_U_I_D:
      g_value_set_object (value, self->UUID);
      break;

    case PROP_LOGICAL_TYPE_F_L_O_A_T16:
      g_value_set_object (value, self->FLOAT16);
      break;

    case PROP_LOGICAL_TYPE_V_A_R_I_A_N_T:
      g_value_set_object (value, self->VARIANT);
      break;

    case PROP_LOGICAL_TYPE_G_E_O_M_E_T_R_Y:
      g_value_set_object (value, self->GEOMETRY);
      break;

    case PROP_LOGICAL_TYPE_G_E_O_G_R_A_P_H_Y:
      g_value_set_object (value, self->GEOGRAPHY);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
logical_type_instance_init (LogicalType * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->STRING = g_object_new (TYPE_STRING_TYPE, NULL);
  object->__isset_STRING = FALSE;
  object->MAP = g_object_new (TYPE_MAP_TYPE, NULL);
  object->__isset_MAP = FALSE;
  object->LIST = g_object_new (TYPE_LIST_TYPE, NULL);
  object->__isset_LIST = FALSE;
  object->ENUM = g_object_new (TYPE_ENUM_TYPE, NULL);
  object->__isset_ENUM = FALSE;
  object->DECIMAL = g_object_new (TYPE_DECIMAL_TYPE, NULL);
  object->__isset_DECIMAL = FALSE;
  object->DATE = g_object_new (TYPE_DATE_TYPE, NULL);
  object->__isset_DATE = FALSE;
  object->TIME = g_object_new (TYPE_TIME_TYPE, NULL);
  object->__isset_TIME = FALSE;
  object->TIMESTAMP = g_object_new (TYPE_TIMESTAMP_TYPE, NULL);
  object->__isset_TIMESTAMP = FALSE;
  object->INTEGER = g_object_new (TYPE_INT_TYPE, NULL);
  object->__isset_INTEGER = FALSE;
  object->UNKNOWN = g_object_new (TYPE_NULL_TYPE, NULL);
  object->__isset_UNKNOWN = FALSE;
  object->JSON = g_object_new (TYPE_JSON_TYPE, NULL);
  object->__isset_JSON = FALSE;
  object->BSON = g_object_new (TYPE_BSON_TYPE, NULL);
  object->__isset_BSON = FALSE;
  object->UUID = g_object_new (TYPE_U_U_I_D_TYPE, NULL);
  object->__isset_UUID = FALSE;
  object->FLOAT16 = g_object_new (TYPE_FLOAT16_TYPE, NULL);
  object->__isset_FLOAT16 = FALSE;
  object->VARIANT = g_object_new (TYPE_VARIANT_TYPE, NULL);
  object->__isset_VARIANT = FALSE;
  object->GEOMETRY = g_object_new (TYPE_GEOMETRY_TYPE, NULL);
  object->__isset_GEOMETRY = FALSE;
  object->GEOGRAPHY = g_object_new (TYPE_GEOGRAPHY_TYPE, NULL);
  object->__isset_GEOGRAPHY = FALSE;
}

static void 
logical_type_finalize (GObject *object)
{
  LogicalType *tobject = LOGICAL_TYPE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->STRING != NULL)
  {
    g_object_unref(tobject->STRING);
    tobject->STRING = NULL;
  }
  if (tobject->MAP != NULL)
  {
    g_object_unref(tobject->MAP);
    tobject->MAP = NULL;
  }
  if (tobject->LIST != NULL)
  {
    g_object_unref(tobject->LIST);
    tobject->LIST = NULL;
  }
  if (tobject->ENUM != NULL)
  {
    g_object_unref(tobject->ENUM);
    tobject->ENUM = NULL;
  }
  if (tobject->DECIMAL != NULL)
  {
    g_object_unref(tobject->DECIMAL);
    tobject->DECIMAL = NULL;
  }
  if (tobject->DATE != NULL)
  {
    g_object_unref(tobject->DATE);
    tobject->DATE = NULL;
  }
  if (tobject->TIME != NULL)
  {
    g_object_unref(tobject->TIME);
    tobject->TIME = NULL;
  }
  if (tobject->TIMESTAMP != NULL)
  {
    g_object_unref(tobject->TIMESTAMP);
    tobject->TIMESTAMP = NULL;
  }
  if (tobject->INTEGER != NULL)
  {
    g_object_unref(tobject->INTEGER);
    tobject->INTEGER = NULL;
  }
  if (tobject->UNKNOWN != NULL)
  {
    g_object_unref(tobject->UNKNOWN);
    tobject->UNKNOWN = NULL;
  }
  if (tobject->JSON != NULL)
  {
    g_object_unref(tobject->JSON);
    tobject->JSON = NULL;
  }
  if (tobject->BSON != NULL)
  {
    g_object_unref(tobject->BSON);
    tobject->BSON = NULL;
  }
  if (tobject->UUID != NULL)
  {
    g_object_unref(tobject->UUID);
    tobject->UUID = NULL;
  }
  if (tobject->FLOAT16 != NULL)
  {
    g_object_unref(tobject->FLOAT16);
    tobject->FLOAT16 = NULL;
  }
  if (tobject->VARIANT != NULL)
  {
    g_object_unref(tobject->VARIANT);
    tobject->VARIANT = NULL;
  }
  if (tobject->GEOMETRY != NULL)
  {
    g_object_unref(tobject->GEOMETRY);
    tobject->GEOMETRY = NULL;
  }
  if (tobject->GEOGRAPHY != NULL)
  {
    g_object_unref(tobject->GEOGRAPHY);
    tobject->GEOGRAPHY = NULL;
  }
}

static void
logical_type_class_init (LogicalTypeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = logical_type_read;
  struct_class->write = logical_type_write;

  gobject_class->finalize = logical_type_finalize;
  gobject_class->get_property = logical_type_get_property;
  gobject_class->set_property = logical_type_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_S_T_R_I_N_G,
     g_param_spec_object ("STRING",
                         NULL,
                         NULL,
                         TYPE_STRING_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_M_A_P,
     g_param_spec_object ("MAP",
                         NULL,
                         NULL,
                         TYPE_MAP_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_L_I_S_T,
     g_param_spec_object ("LIST",
                         NULL,
                         NULL,
                         TYPE_LIST_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_E_N_U_M,
     g_param_spec_object ("ENUM",
                         NULL,
                         NULL,
                         TYPE_ENUM_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_D_E_C_I_M_A_L,
     g_param_spec_object ("DECIMAL",
                         NULL,
                         NULL,
                         TYPE_DECIMAL_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_D_A_T_E,
     g_param_spec_object ("DATE",
                         NULL,
                         NULL,
                         TYPE_DATE_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_T_I_M_E,
     g_param_spec_object ("TIME",
                         NULL,
                         NULL,
                         TYPE_TIME_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_T_I_M_E_S_T_A_M_P,
     g_param_spec_object ("TIMESTAMP",
                         NULL,
                         NULL,
                         TYPE_TIMESTAMP_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_I_N_T_E_G_E_R,
     g_param_spec_object ("INTEGER",
                         NULL,
                         NULL,
                         TYPE_INT_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_U_N_K_N_O_W_N,
     g_param_spec_object ("UNKNOWN",
                         NULL,
                         NULL,
                         TYPE_NULL_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_J_S_O_N,
     g_param_spec_object ("JSON",
                         NULL,
                         NULL,
                         TYPE_JSON_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_B_S_O_N,
     g_param_spec_object ("BSON",
                         NULL,
                         NULL,
                         TYPE_BSON_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_U_U_I_D,
     g_param_spec_object ("UUID",
                         NULL,
                         NULL,
                         TYPE_U_U_I_D_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_F_L_O_A_T16,
     g_param_spec_object ("FLOAT16",
                         NULL,
                         NULL,
                         TYPE_FLOAT16_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_V_A_R_I_A_N_T,
     g_param_spec_object ("VARIANT",
                         NULL,
                         NULL,
                         TYPE_VARIANT_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_G_E_O_M_E_T_R_Y,
     g_param_spec_object ("GEOMETRY",
                         NULL,
                         NULL,
                         TYPE_GEOMETRY_TYPE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOGICAL_TYPE_G_E_O_G_R_A_P_H_Y,
     g_param_spec_object ("GEOGRAPHY",
                         NULL,
                         NULL,
                         TYPE_GEOGRAPHY_TYPE,
                         G_PARAM_READWRITE));
}

GType
logical_type_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LogicalTypeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) logical_type_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LogicalType),
      0, /* n_preallocs */
      (GInstanceInitFunc) logical_type_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LogicalTypeType",
                                   &type_info, 0);
  }

  return type;
}

enum _SchemaElementProperties
{
  PROP_SCHEMA_ELEMENT_0,
  PROP_SCHEMA_ELEMENT_TYPE,
  PROP_SCHEMA_ELEMENT_TYPE_LENGTH,
  PROP_SCHEMA_ELEMENT_REPETITION_TYPE,
  PROP_SCHEMA_ELEMENT_NAME,
  PROP_SCHEMA_ELEMENT_NUM_CHILDREN,
  PROP_SCHEMA_ELEMENT_CONVERTED_TYPE,
  PROP_SCHEMA_ELEMENT_SCALE,
  PROP_SCHEMA_ELEMENT_PRECISION,
  PROP_SCHEMA_ELEMENT_FIELD_ID,
  PROP_SCHEMA_ELEMENT_LOGICAL_TYPE
};

/* reads a schema_element object */
static gint32
schema_element_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SchemaElement * this_object = SCHEMA_ELEMENT(object);
  gboolean isset_name = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast7;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast7, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (Type)ecast7;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->type_length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast8;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast8, error)) < 0)
            return -1;
          xfer += ret;
          this_object->repetition_type = (FieldRepetitionType)ecast8;
          this_object->__isset_repetition_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_children, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_num_children = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast9;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast9, error)) < 0)
            return -1;
          xfer += ret;
          this_object->converted_type = (ConvertedType)ecast9;
          this_object->__isset_converted_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->scale, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_scale = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->precision, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_precision = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->logicalType), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_logicalType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_name)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
schema_element_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SchemaElement * this_object = SCHEMA_ELEMENT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SchemaElement", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_type_length == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type_length", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->type_length, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_repetition_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "repetition_type", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->repetition_type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_num_children == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "num_children", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_children, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_converted_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "converted_type", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->converted_type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_scale == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "scale", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->scale, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_precision == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "precision", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->precision, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_field_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "field_id", T_I32, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->field_id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_logicalType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "logicalType", T_STRUCT, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->logicalType), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
schema_element_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  SchemaElement *self = SCHEMA_ELEMENT (object);

  switch (property_id)
  {
    case PROP_SCHEMA_ELEMENT_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    case PROP_SCHEMA_ELEMENT_TYPE_LENGTH:
      self->type_length = g_value_get_int (value);
      self->__isset_type_length = TRUE;
      break;

    case PROP_SCHEMA_ELEMENT_REPETITION_TYPE:
      self->repetition_type = g_value_get_int (value);
      self->__isset_repetition_type = TRUE;
      break;

    case PROP_SCHEMA_ELEMENT_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      break;

    case PROP_SCHEMA_ELEMENT_NUM_CHILDREN:
      self->num_children = g_value_get_int (value);
      self->__isset_num_children = TRUE;
      break;

    case PROP_SCHEMA_ELEMENT_CONVERTED_TYPE:
      self->converted_type = g_value_get_int (value);
      self->__isset_converted_type = TRUE;
      break;

    case PROP_SCHEMA_ELEMENT_SCALE:
      self->scale = g_value_get_int (value);
      self->__isset_scale = TRUE;
      break;

    case PROP_SCHEMA_ELEMENT_PRECISION:
      self->precision = g_value_get_int (value);
      self->__isset_precision = TRUE;
      break;

    case PROP_SCHEMA_ELEMENT_FIELD_ID:
      self->field_id = g_value_get_int (value);
      self->__isset_field_id = TRUE;
      break;

    case PROP_SCHEMA_ELEMENT_LOGICAL_TYPE:
      if (self->logicalType != NULL)
        g_object_unref (self->logicalType);
      self->logicalType = g_value_dup_object (value);
      self->__isset_logicalType = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
schema_element_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  SchemaElement *self = SCHEMA_ELEMENT (object);

  switch (property_id)
  {
    case PROP_SCHEMA_ELEMENT_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_SCHEMA_ELEMENT_TYPE_LENGTH:
      g_value_set_int (value, self->type_length);
      break;

    case PROP_SCHEMA_ELEMENT_REPETITION_TYPE:
      g_value_set_int (value, self->repetition_type);
      break;

    case PROP_SCHEMA_ELEMENT_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_SCHEMA_ELEMENT_NUM_CHILDREN:
      g_value_set_int (value, self->num_children);
      break;

    case PROP_SCHEMA_ELEMENT_CONVERTED_TYPE:
      g_value_set_int (value, self->converted_type);
      break;

    case PROP_SCHEMA_ELEMENT_SCALE:
      g_value_set_int (value, self->scale);
      break;

    case PROP_SCHEMA_ELEMENT_PRECISION:
      g_value_set_int (value, self->precision);
      break;

    case PROP_SCHEMA_ELEMENT_FIELD_ID:
      g_value_set_int (value, self->field_id);
      break;

    case PROP_SCHEMA_ELEMENT_LOGICAL_TYPE:
      g_value_set_object (value, self->logicalType);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
schema_element_instance_init (SchemaElement * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_type = FALSE;
  object->type_length = 0;
  object->__isset_type_length = FALSE;
  object->__isset_repetition_type = FALSE;
  object->name = NULL;
  object->num_children = 0;
  object->__isset_num_children = FALSE;
  object->__isset_converted_type = FALSE;
  object->scale = 0;
  object->__isset_scale = FALSE;
  object->precision = 0;
  object->__isset_precision = FALSE;
  object->field_id = 0;
  object->__isset_field_id = FALSE;
  object->logicalType = g_object_new (TYPE_LOGICAL_TYPE, NULL);
  object->__isset_logicalType = FALSE;
}

static void 
schema_element_finalize (GObject *object)
{
  SchemaElement *tobject = SCHEMA_ELEMENT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->logicalType != NULL)
  {
    g_object_unref(tobject->logicalType);
    tobject->logicalType = NULL;
  }
}

static void
schema_element_class_init (SchemaElementClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = schema_element_read;
  struct_class->write = schema_element_write;

  gobject_class->finalize = schema_element_finalize;
  gobject_class->get_property = schema_element_get_property;
  gobject_class->set_property = schema_element_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ELEMENT_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       7,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ELEMENT_TYPE_LENGTH,
     g_param_spec_int ("type_length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ELEMENT_REPETITION_TYPE,
     g_param_spec_int ("repetition_type",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ELEMENT_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ELEMENT_NUM_CHILDREN,
     g_param_spec_int ("num_children",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ELEMENT_CONVERTED_TYPE,
     g_param_spec_int ("converted_type",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ELEMENT_SCALE,
     g_param_spec_int ("scale",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ELEMENT_PRECISION,
     g_param_spec_int ("precision",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ELEMENT_FIELD_ID,
     g_param_spec_int ("field_id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SCHEMA_ELEMENT_LOGICAL_TYPE,
     g_param_spec_object ("logicalType",
                         NULL,
                         NULL,
                         TYPE_LOGICAL_TYPE,
                         G_PARAM_READWRITE));
}

GType
schema_element_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SchemaElementClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) schema_element_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SchemaElement),
      0, /* n_preallocs */
      (GInstanceInitFunc) schema_element_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SchemaElementType",
                                   &type_info, 0);
  }

  return type;
}

enum _DataPageHeaderProperties
{
  PROP_DATA_PAGE_HEADER_0,
  PROP_DATA_PAGE_HEADER_NUM_VALUES,
  PROP_DATA_PAGE_HEADER_ENCODING,
  PROP_DATA_PAGE_HEADER_DEFINITION_LEVEL_ENCODING,
  PROP_DATA_PAGE_HEADER_REPETITION_LEVEL_ENCODING,
  PROP_DATA_PAGE_HEADER_STATISTICS
};

/* reads a data_page_header object */
static gint32
data_page_header_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DataPageHeader * this_object = DATA_PAGE_HEADER(object);
  gboolean isset_num_values = FALSE;
  gboolean isset_encoding = FALSE;
  gboolean isset_definition_level_encoding = FALSE;
  gboolean isset_repetition_level_encoding = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_values, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast10;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast10, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoding = (Encoding)ecast10;
          isset_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast11;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast11, error)) < 0)
            return -1;
          xfer += ret;
          this_object->definition_level_encoding = (Encoding)ecast11;
          isset_definition_level_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast12;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast12, error)) < 0)
            return -1;
          xfer += ret;
          this_object->repetition_level_encoding = (Encoding)ecast12;
          isset_repetition_level_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_statistics = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_num_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_definition_level_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_repetition_level_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
data_page_header_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DataPageHeader * this_object = DATA_PAGE_HEADER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DataPageHeader", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_values", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_values, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encoding", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "definition_level_encoding", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->definition_level_encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "repetition_level_encoding", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->repetition_level_encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_statistics == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "statistics", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
data_page_header_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  DataPageHeader *self = DATA_PAGE_HEADER (object);

  switch (property_id)
  {
    case PROP_DATA_PAGE_HEADER_NUM_VALUES:
      self->num_values = g_value_get_int (value);
      break;

    case PROP_DATA_PAGE_HEADER_ENCODING:
      self->encoding = g_value_get_int (value);
      break;

    case PROP_DATA_PAGE_HEADER_DEFINITION_LEVEL_ENCODING:
      self->definition_level_encoding = g_value_get_int (value);
      break;

    case PROP_DATA_PAGE_HEADER_REPETITION_LEVEL_ENCODING:
      self->repetition_level_encoding = g_value_get_int (value);
      break;

    case PROP_DATA_PAGE_HEADER_STATISTICS:
      if (self->statistics != NULL)
        g_object_unref (self->statistics);
      self->statistics = g_value_dup_object (value);
      self->__isset_statistics = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
data_page_header_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  DataPageHeader *self = DATA_PAGE_HEADER (object);

  switch (property_id)
  {
    case PROP_DATA_PAGE_HEADER_NUM_VALUES:
      g_value_set_int (value, self->num_values);
      break;

    case PROP_DATA_PAGE_HEADER_ENCODING:
      g_value_set_int (value, self->encoding);
      break;

    case PROP_DATA_PAGE_HEADER_DEFINITION_LEVEL_ENCODING:
      g_value_set_int (value, self->definition_level_encoding);
      break;

    case PROP_DATA_PAGE_HEADER_REPETITION_LEVEL_ENCODING:
      g_value_set_int (value, self->repetition_level_encoding);
      break;

    case PROP_DATA_PAGE_HEADER_STATISTICS:
      g_value_set_object (value, self->statistics);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
data_page_header_instance_init (DataPageHeader * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->num_values = 0;
  object->statistics = g_object_new (TYPE_STATISTICS, NULL);
  object->__isset_statistics = FALSE;
}

static void 
data_page_header_finalize (GObject *object)
{
  DataPageHeader *tobject = DATA_PAGE_HEADER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->statistics != NULL)
  {
    g_object_unref(tobject->statistics);
    tobject->statistics = NULL;
  }
}

static void
data_page_header_class_init (DataPageHeaderClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = data_page_header_read;
  struct_class->write = data_page_header_write;

  gobject_class->finalize = data_page_header_finalize;
  gobject_class->get_property = data_page_header_get_property;
  gobject_class->set_property = data_page_header_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_NUM_VALUES,
     g_param_spec_int ("num_values",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_ENCODING,
     g_param_spec_int ("encoding",
                       NULL,
                       NULL,
                       0,
                       9,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_DEFINITION_LEVEL_ENCODING,
     g_param_spec_int ("definition_level_encoding",
                       NULL,
                       NULL,
                       0,
                       9,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_REPETITION_LEVEL_ENCODING,
     g_param_spec_int ("repetition_level_encoding",
                       NULL,
                       NULL,
                       0,
                       9,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_STATISTICS,
     g_param_spec_object ("statistics",
                         NULL,
                         NULL,
                         TYPE_STATISTICS,
                         G_PARAM_READWRITE));
}

GType
data_page_header_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DataPageHeaderClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) data_page_header_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DataPageHeader),
      0, /* n_preallocs */
      (GInstanceInitFunc) data_page_header_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DataPageHeaderType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a index_page_header object */
static gint32
index_page_header_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IndexPageHeader * this_object = INDEX_PAGE_HEADER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
index_page_header_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IndexPageHeader * this_object = INDEX_PAGE_HEADER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IndexPageHeader", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
index_page_header_instance_init (IndexPageHeader * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
index_page_header_finalize (GObject *object)
{
  IndexPageHeader *tobject = INDEX_PAGE_HEADER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
index_page_header_class_init (IndexPageHeaderClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = index_page_header_read;
  struct_class->write = index_page_header_write;

  gobject_class->finalize = index_page_header_finalize;
}

GType
index_page_header_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IndexPageHeaderClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) index_page_header_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IndexPageHeader),
      0, /* n_preallocs */
      (GInstanceInitFunc) index_page_header_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IndexPageHeaderType",
                                   &type_info, 0);
  }

  return type;
}

enum _DictionaryPageHeaderProperties
{
  PROP_DICTIONARY_PAGE_HEADER_0,
  PROP_DICTIONARY_PAGE_HEADER_NUM_VALUES,
  PROP_DICTIONARY_PAGE_HEADER_ENCODING,
  PROP_DICTIONARY_PAGE_HEADER_IS_SORTED
};

/* reads a dictionary_page_header object */
static gint32
dictionary_page_header_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DictionaryPageHeader * this_object = DICTIONARY_PAGE_HEADER(object);
  gboolean isset_num_values = FALSE;
  gboolean isset_encoding = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_values, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast13;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast13, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoding = (Encoding)ecast13;
          isset_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_sorted, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_sorted = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_num_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
dictionary_page_header_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DictionaryPageHeader * this_object = DICTIONARY_PAGE_HEADER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DictionaryPageHeader", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_values", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_values, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encoding", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_is_sorted == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "is_sorted", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->is_sorted, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
dictionary_page_header_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  DictionaryPageHeader *self = DICTIONARY_PAGE_HEADER (object);

  switch (property_id)
  {
    case PROP_DICTIONARY_PAGE_HEADER_NUM_VALUES:
      self->num_values = g_value_get_int (value);
      break;

    case PROP_DICTIONARY_PAGE_HEADER_ENCODING:
      self->encoding = g_value_get_int (value);
      break;

    case PROP_DICTIONARY_PAGE_HEADER_IS_SORTED:
      self->is_sorted = g_value_get_boolean (value);
      self->__isset_is_sorted = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
dictionary_page_header_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  DictionaryPageHeader *self = DICTIONARY_PAGE_HEADER (object);

  switch (property_id)
  {
    case PROP_DICTIONARY_PAGE_HEADER_NUM_VALUES:
      g_value_set_int (value, self->num_values);
      break;

    case PROP_DICTIONARY_PAGE_HEADER_ENCODING:
      g_value_set_int (value, self->encoding);
      break;

    case PROP_DICTIONARY_PAGE_HEADER_IS_SORTED:
      g_value_set_boolean (value, self->is_sorted);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
dictionary_page_header_instance_init (DictionaryPageHeader * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->num_values = 0;
  object->is_sorted = 0;
  object->__isset_is_sorted = FALSE;
}

static void 
dictionary_page_header_finalize (GObject *object)
{
  DictionaryPageHeader *tobject = DICTIONARY_PAGE_HEADER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
dictionary_page_header_class_init (DictionaryPageHeaderClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = dictionary_page_header_read;
  struct_class->write = dictionary_page_header_write;

  gobject_class->finalize = dictionary_page_header_finalize;
  gobject_class->get_property = dictionary_page_header_get_property;
  gobject_class->set_property = dictionary_page_header_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DICTIONARY_PAGE_HEADER_NUM_VALUES,
     g_param_spec_int ("num_values",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DICTIONARY_PAGE_HEADER_ENCODING,
     g_param_spec_int ("encoding",
                       NULL,
                       NULL,
                       0,
                       9,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DICTIONARY_PAGE_HEADER_IS_SORTED,
     g_param_spec_boolean ("is_sorted",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
dictionary_page_header_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DictionaryPageHeaderClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) dictionary_page_header_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DictionaryPageHeader),
      0, /* n_preallocs */
      (GInstanceInitFunc) dictionary_page_header_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DictionaryPageHeaderType",
                                   &type_info, 0);
  }

  return type;
}

enum _DataPageHeaderV2Properties
{
  PROP_DATA_PAGE_HEADER_V2_0,
  PROP_DATA_PAGE_HEADER_V2_NUM_VALUES,
  PROP_DATA_PAGE_HEADER_V2_NUM_NULLS,
  PROP_DATA_PAGE_HEADER_V2_NUM_ROWS,
  PROP_DATA_PAGE_HEADER_V2_ENCODING,
  PROP_DATA_PAGE_HEADER_V2_DEFINITION_LEVELS_BYTE_LENGTH,
  PROP_DATA_PAGE_HEADER_V2_REPETITION_LEVELS_BYTE_LENGTH,
  PROP_DATA_PAGE_HEADER_V2_IS_COMPRESSED,
  PROP_DATA_PAGE_HEADER_V2_STATISTICS
};

/* reads a data_page_header_v2 object */
static gint32
data_page_header_v2_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DataPageHeaderV2 * this_object = DATA_PAGE_HEADER_V2(object);
  gboolean isset_num_values = FALSE;
  gboolean isset_num_nulls = FALSE;
  gboolean isset_num_rows = FALSE;
  gboolean isset_encoding = FALSE;
  gboolean isset_definition_levels_byte_length = FALSE;
  gboolean isset_repetition_levels_byte_length = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_values, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_nulls, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_nulls = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->num_rows, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast14;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast14, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoding = (Encoding)ecast14;
          isset_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->definition_levels_byte_length, error)) < 0)
            return -1;
          xfer += ret;
          isset_definition_levels_byte_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->repetition_levels_byte_length, error)) < 0)
            return -1;
          xfer += ret;
          isset_repetition_levels_byte_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->is_compressed, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_is_compressed = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_statistics = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_num_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_num_nulls)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_num_rows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_definition_levels_byte_length)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_repetition_levels_byte_length)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
data_page_header_v2_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DataPageHeaderV2 * this_object = DATA_PAGE_HEADER_V2(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DataPageHeaderV2", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_values", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_values, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_nulls", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_nulls, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_rows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->num_rows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encoding", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "definition_levels_byte_length", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->definition_levels_byte_length, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "repetition_levels_byte_length", T_I32, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->repetition_levels_byte_length, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_is_compressed == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "is_compressed", T_BOOL, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->is_compressed, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_statistics == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "statistics", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
data_page_header_v2_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  DataPageHeaderV2 *self = DATA_PAGE_HEADER_V2 (object);

  switch (property_id)
  {
    case PROP_DATA_PAGE_HEADER_V2_NUM_VALUES:
      self->num_values = g_value_get_int (value);
      break;

    case PROP_DATA_PAGE_HEADER_V2_NUM_NULLS:
      self->num_nulls = g_value_get_int (value);
      break;

    case PROP_DATA_PAGE_HEADER_V2_NUM_ROWS:
      self->num_rows = g_value_get_int (value);
      break;

    case PROP_DATA_PAGE_HEADER_V2_ENCODING:
      self->encoding = g_value_get_int (value);
      break;

    case PROP_DATA_PAGE_HEADER_V2_DEFINITION_LEVELS_BYTE_LENGTH:
      self->definition_levels_byte_length = g_value_get_int (value);
      break;

    case PROP_DATA_PAGE_HEADER_V2_REPETITION_LEVELS_BYTE_LENGTH:
      self->repetition_levels_byte_length = g_value_get_int (value);
      break;

    case PROP_DATA_PAGE_HEADER_V2_IS_COMPRESSED:
      self->is_compressed = g_value_get_boolean (value);
      self->__isset_is_compressed = TRUE;
      break;

    case PROP_DATA_PAGE_HEADER_V2_STATISTICS:
      if (self->statistics != NULL)
        g_object_unref (self->statistics);
      self->statistics = g_value_dup_object (value);
      self->__isset_statistics = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
data_page_header_v2_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  DataPageHeaderV2 *self = DATA_PAGE_HEADER_V2 (object);

  switch (property_id)
  {
    case PROP_DATA_PAGE_HEADER_V2_NUM_VALUES:
      g_value_set_int (value, self->num_values);
      break;

    case PROP_DATA_PAGE_HEADER_V2_NUM_NULLS:
      g_value_set_int (value, self->num_nulls);
      break;

    case PROP_DATA_PAGE_HEADER_V2_NUM_ROWS:
      g_value_set_int (value, self->num_rows);
      break;

    case PROP_DATA_PAGE_HEADER_V2_ENCODING:
      g_value_set_int (value, self->encoding);
      break;

    case PROP_DATA_PAGE_HEADER_V2_DEFINITION_LEVELS_BYTE_LENGTH:
      g_value_set_int (value, self->definition_levels_byte_length);
      break;

    case PROP_DATA_PAGE_HEADER_V2_REPETITION_LEVELS_BYTE_LENGTH:
      g_value_set_int (value, self->repetition_levels_byte_length);
      break;

    case PROP_DATA_PAGE_HEADER_V2_IS_COMPRESSED:
      g_value_set_boolean (value, self->is_compressed);
      break;

    case PROP_DATA_PAGE_HEADER_V2_STATISTICS:
      g_value_set_object (value, self->statistics);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
data_page_header_v2_instance_init (DataPageHeaderV2 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->num_values = 0;
  object->num_nulls = 0;
  object->num_rows = 0;
  object->definition_levels_byte_length = 0;
  object->repetition_levels_byte_length = 0;
  object->is_compressed = 1;
  object->__isset_is_compressed = FALSE;
  object->statistics = g_object_new (TYPE_STATISTICS, NULL);
  object->__isset_statistics = FALSE;
}

static void 
data_page_header_v2_finalize (GObject *object)
{
  DataPageHeaderV2 *tobject = DATA_PAGE_HEADER_V2 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->statistics != NULL)
  {
    g_object_unref(tobject->statistics);
    tobject->statistics = NULL;
  }
}

static void
data_page_header_v2_class_init (DataPageHeaderV2Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = data_page_header_v2_read;
  struct_class->write = data_page_header_v2_write;

  gobject_class->finalize = data_page_header_v2_finalize;
  gobject_class->get_property = data_page_header_v2_get_property;
  gobject_class->set_property = data_page_header_v2_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_V2_NUM_VALUES,
     g_param_spec_int ("num_values",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_V2_NUM_NULLS,
     g_param_spec_int ("num_nulls",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_V2_NUM_ROWS,
     g_param_spec_int ("num_rows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_V2_ENCODING,
     g_param_spec_int ("encoding",
                       NULL,
                       NULL,
                       0,
                       9,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_V2_DEFINITION_LEVELS_BYTE_LENGTH,
     g_param_spec_int ("definition_levels_byte_length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_V2_REPETITION_LEVELS_BYTE_LENGTH,
     g_param_spec_int ("repetition_levels_byte_length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_V2_IS_COMPRESSED,
     g_param_spec_boolean ("is_compressed",
                           NULL,
                           NULL,
                           TRUE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DATA_PAGE_HEADER_V2_STATISTICS,
     g_param_spec_object ("statistics",
                         NULL,
                         NULL,
                         TYPE_STATISTICS,
                         G_PARAM_READWRITE));
}

GType
data_page_header_v2_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DataPageHeaderV2Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) data_page_header_v2_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DataPageHeaderV2),
      0, /* n_preallocs */
      (GInstanceInitFunc) data_page_header_v2_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DataPageHeaderV2Type",
                                   &type_info, 0);
  }

  return type;
}

/* reads a split_block_algorithm object */
static gint32
split_block_algorithm_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SplitBlockAlgorithm * this_object = SPLIT_BLOCK_ALGORITHM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
split_block_algorithm_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SplitBlockAlgorithm * this_object = SPLIT_BLOCK_ALGORITHM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SplitBlockAlgorithm", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
split_block_algorithm_instance_init (SplitBlockAlgorithm * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
split_block_algorithm_finalize (GObject *object)
{
  SplitBlockAlgorithm *tobject = SPLIT_BLOCK_ALGORITHM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
split_block_algorithm_class_init (SplitBlockAlgorithmClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = split_block_algorithm_read;
  struct_class->write = split_block_algorithm_write;

  gobject_class->finalize = split_block_algorithm_finalize;
}

GType
split_block_algorithm_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SplitBlockAlgorithmClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) split_block_algorithm_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SplitBlockAlgorithm),
      0, /* n_preallocs */
      (GInstanceInitFunc) split_block_algorithm_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SplitBlockAlgorithmType",
                                   &type_info, 0);
  }

  return type;
}

enum _BloomFilterAlgorithmProperties
{
  PROP_BLOOM_FILTER_ALGORITHM_0,
  PROP_BLOOM_FILTER_ALGORITHM_B_L_O_C_K
};

/* reads a bloom_filter_algorithm object */
static gint32
bloom_filter_algorithm_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BloomFilterAlgorithm * this_object = BLOOM_FILTER_ALGORITHM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->BLOCK), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_BLOCK = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bloom_filter_algorithm_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BloomFilterAlgorithm * this_object = BLOOM_FILTER_ALGORITHM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BloomFilterAlgorithm", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_BLOCK == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "BLOCK", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->BLOCK), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bloom_filter_algorithm_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  BloomFilterAlgorithm *self = BLOOM_FILTER_ALGORITHM (object);

  switch (property_id)
  {
    case PROP_BLOOM_FILTER_ALGORITHM_B_L_O_C_K:
      if (self->BLOCK != NULL)
        g_object_unref (self->BLOCK);
      self->BLOCK = g_value_dup_object (value);
      self->__isset_BLOCK = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bloom_filter_algorithm_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  BloomFilterAlgorithm *self = BLOOM_FILTER_ALGORITHM (object);

  switch (property_id)
  {
    case PROP_BLOOM_FILTER_ALGORITHM_B_L_O_C_K:
      g_value_set_object (value, self->BLOCK);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bloom_filter_algorithm_instance_init (BloomFilterAlgorithm * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->BLOCK = g_object_new (TYPE_SPLIT_BLOCK_ALGORITHM, NULL);
  object->__isset_BLOCK = FALSE;
}

static void 
bloom_filter_algorithm_finalize (GObject *object)
{
  BloomFilterAlgorithm *tobject = BLOOM_FILTER_ALGORITHM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->BLOCK != NULL)
  {
    g_object_unref(tobject->BLOCK);
    tobject->BLOCK = NULL;
  }
}

static void
bloom_filter_algorithm_class_init (BloomFilterAlgorithmClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bloom_filter_algorithm_read;
  struct_class->write = bloom_filter_algorithm_write;

  gobject_class->finalize = bloom_filter_algorithm_finalize;
  gobject_class->get_property = bloom_filter_algorithm_get_property;
  gobject_class->set_property = bloom_filter_algorithm_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BLOOM_FILTER_ALGORITHM_B_L_O_C_K,
     g_param_spec_object ("BLOCK",
                         NULL,
                         NULL,
                         TYPE_SPLIT_BLOCK_ALGORITHM,
                         G_PARAM_READWRITE));
}

GType
bloom_filter_algorithm_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BloomFilterAlgorithmClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bloom_filter_algorithm_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BloomFilterAlgorithm),
      0, /* n_preallocs */
      (GInstanceInitFunc) bloom_filter_algorithm_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BloomFilterAlgorithmType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a xx_hash object */
static gint32
xx_hash_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  XxHash * this_object = XX_HASH(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
xx_hash_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  XxHash * this_object = XX_HASH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "XxHash", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
xx_hash_instance_init (XxHash * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
xx_hash_finalize (GObject *object)
{
  XxHash *tobject = XX_HASH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
xx_hash_class_init (XxHashClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = xx_hash_read;
  struct_class->write = xx_hash_write;

  gobject_class->finalize = xx_hash_finalize;
}

GType
xx_hash_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (XxHashClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) xx_hash_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (XxHash),
      0, /* n_preallocs */
      (GInstanceInitFunc) xx_hash_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "XxHashType",
                                   &type_info, 0);
  }

  return type;
}

enum _BloomFilterHashProperties
{
  PROP_BLOOM_FILTER_HASH_0,
  PROP_BLOOM_FILTER_HASH_X_X_H_A_S_H
};

/* reads a bloom_filter_hash object */
static gint32
bloom_filter_hash_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BloomFilterHash * this_object = BLOOM_FILTER_HASH(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->XXHASH), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_XXHASH = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bloom_filter_hash_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BloomFilterHash * this_object = BLOOM_FILTER_HASH(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BloomFilterHash", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_XXHASH == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "XXHASH", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->XXHASH), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bloom_filter_hash_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  BloomFilterHash *self = BLOOM_FILTER_HASH (object);

  switch (property_id)
  {
    case PROP_BLOOM_FILTER_HASH_X_X_H_A_S_H:
      if (self->XXHASH != NULL)
        g_object_unref (self->XXHASH);
      self->XXHASH = g_value_dup_object (value);
      self->__isset_XXHASH = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bloom_filter_hash_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  BloomFilterHash *self = BLOOM_FILTER_HASH (object);

  switch (property_id)
  {
    case PROP_BLOOM_FILTER_HASH_X_X_H_A_S_H:
      g_value_set_object (value, self->XXHASH);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bloom_filter_hash_instance_init (BloomFilterHash * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->XXHASH = g_object_new (TYPE_XX_HASH, NULL);
  object->__isset_XXHASH = FALSE;
}

static void 
bloom_filter_hash_finalize (GObject *object)
{
  BloomFilterHash *tobject = BLOOM_FILTER_HASH (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->XXHASH != NULL)
  {
    g_object_unref(tobject->XXHASH);
    tobject->XXHASH = NULL;
  }
}

static void
bloom_filter_hash_class_init (BloomFilterHashClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bloom_filter_hash_read;
  struct_class->write = bloom_filter_hash_write;

  gobject_class->finalize = bloom_filter_hash_finalize;
  gobject_class->get_property = bloom_filter_hash_get_property;
  gobject_class->set_property = bloom_filter_hash_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BLOOM_FILTER_HASH_X_X_H_A_S_H,
     g_param_spec_object ("XXHASH",
                         NULL,
                         NULL,
                         TYPE_XX_HASH,
                         G_PARAM_READWRITE));
}

GType
bloom_filter_hash_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BloomFilterHashClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bloom_filter_hash_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BloomFilterHash),
      0, /* n_preallocs */
      (GInstanceInitFunc) bloom_filter_hash_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BloomFilterHashType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a uncompressed object */
static gint32
uncompressed_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Uncompressed * this_object = UNCOMPRESSED(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
uncompressed_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Uncompressed * this_object = UNCOMPRESSED(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Uncompressed", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
uncompressed_instance_init (Uncompressed * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
uncompressed_finalize (GObject *object)
{
  Uncompressed *tobject = UNCOMPRESSED (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
uncompressed_class_init (UncompressedClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = uncompressed_read;
  struct_class->write = uncompressed_write;

  gobject_class->finalize = uncompressed_finalize;
}

GType
uncompressed_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (UncompressedClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) uncompressed_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Uncompressed),
      0, /* n_preallocs */
      (GInstanceInitFunc) uncompressed_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "UncompressedType",
                                   &type_info, 0);
  }

  return type;
}

enum _BloomFilterCompressionProperties
{
  PROP_BLOOM_FILTER_COMPRESSION_0,
  PROP_BLOOM_FILTER_COMPRESSION_U_N_C_O_M_P_R_E_S_S_E_D
};

/* reads a bloom_filter_compression object */
static gint32
bloom_filter_compression_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BloomFilterCompression * this_object = BLOOM_FILTER_COMPRESSION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->UNCOMPRESSED), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_UNCOMPRESSED = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
bloom_filter_compression_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BloomFilterCompression * this_object = BLOOM_FILTER_COMPRESSION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BloomFilterCompression", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_UNCOMPRESSED == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "UNCOMPRESSED", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->UNCOMPRESSED), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bloom_filter_compression_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  BloomFilterCompression *self = BLOOM_FILTER_COMPRESSION (object);

  switch (property_id)
  {
    case PROP_BLOOM_FILTER_COMPRESSION_U_N_C_O_M_P_R_E_S_S_E_D:
      if (self->UNCOMPRESSED != NULL)
        g_object_unref (self->UNCOMPRESSED);
      self->UNCOMPRESSED = g_value_dup_object (value);
      self->__isset_UNCOMPRESSED = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bloom_filter_compression_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  BloomFilterCompression *self = BLOOM_FILTER_COMPRESSION (object);

  switch (property_id)
  {
    case PROP_BLOOM_FILTER_COMPRESSION_U_N_C_O_M_P_R_E_S_S_E_D:
      g_value_set_object (value, self->UNCOMPRESSED);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bloom_filter_compression_instance_init (BloomFilterCompression * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->UNCOMPRESSED = g_object_new (TYPE_UNCOMPRESSED, NULL);
  object->__isset_UNCOMPRESSED = FALSE;
}

static void 
bloom_filter_compression_finalize (GObject *object)
{
  BloomFilterCompression *tobject = BLOOM_FILTER_COMPRESSION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->UNCOMPRESSED != NULL)
  {
    g_object_unref(tobject->UNCOMPRESSED);
    tobject->UNCOMPRESSED = NULL;
  }
}

static void
bloom_filter_compression_class_init (BloomFilterCompressionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bloom_filter_compression_read;
  struct_class->write = bloom_filter_compression_write;

  gobject_class->finalize = bloom_filter_compression_finalize;
  gobject_class->get_property = bloom_filter_compression_get_property;
  gobject_class->set_property = bloom_filter_compression_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BLOOM_FILTER_COMPRESSION_U_N_C_O_M_P_R_E_S_S_E_D,
     g_param_spec_object ("UNCOMPRESSED",
                         NULL,
                         NULL,
                         TYPE_UNCOMPRESSED,
                         G_PARAM_READWRITE));
}

GType
bloom_filter_compression_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BloomFilterCompressionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bloom_filter_compression_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BloomFilterCompression),
      0, /* n_preallocs */
      (GInstanceInitFunc) bloom_filter_compression_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BloomFilterCompressionType",
                                   &type_info, 0);
  }

  return type;
}

enum _BloomFilterHeaderProperties
{
  PROP_BLOOM_FILTER_HEADER_0,
  PROP_BLOOM_FILTER_HEADER_NUM_BYTES,
  PROP_BLOOM_FILTER_HEADER_ALGORITHM,
  PROP_BLOOM_FILTER_HEADER_HASH,
  PROP_BLOOM_FILTER_HEADER_COMPRESSION
};

/* reads a bloom_filter_header object */
static gint32
bloom_filter_header_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  BloomFilterHeader * this_object = BLOOM_FILTER_HEADER(object);
  gboolean isset_numBytes = FALSE;
  gboolean isset_algorithm = FALSE;
  gboolean isset_hash = FALSE;
  gboolean isset_compression = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numBytes, error)) < 0)
            return -1;
          xfer += ret;
          isset_numBytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->algorithm), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_algorithm = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->hash), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_hash = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->compression), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_compression = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_numBytes)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_algorithm)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_hash)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_compression)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
bloom_filter_header_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  BloomFilterHeader * this_object = BLOOM_FILTER_HEADER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "BloomFilterHeader", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numBytes", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numBytes, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "algorithm", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->algorithm), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "hash", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->hash), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compression", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->compression), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
bloom_filter_header_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  BloomFilterHeader *self = BLOOM_FILTER_HEADER (object);

  switch (property_id)
  {
    case PROP_BLOOM_FILTER_HEADER_NUM_BYTES:
      self->numBytes = g_value_get_int (value);
      break;

    case PROP_BLOOM_FILTER_HEADER_ALGORITHM:
      if (self->algorithm != NULL)
        g_object_unref (self->algorithm);
      self->algorithm = g_value_dup_object (value);
      break;

    case PROP_BLOOM_FILTER_HEADER_HASH:
      if (self->hash != NULL)
        g_object_unref (self->hash);
      self->hash = g_value_dup_object (value);
      break;

    case PROP_BLOOM_FILTER_HEADER_COMPRESSION:
      if (self->compression != NULL)
        g_object_unref (self->compression);
      self->compression = g_value_dup_object (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
bloom_filter_header_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  BloomFilterHeader *self = BLOOM_FILTER_HEADER (object);

  switch (property_id)
  {
    case PROP_BLOOM_FILTER_HEADER_NUM_BYTES:
      g_value_set_int (value, self->numBytes);
      break;

    case PROP_BLOOM_FILTER_HEADER_ALGORITHM:
      g_value_set_object (value, self->algorithm);
      break;

    case PROP_BLOOM_FILTER_HEADER_HASH:
      g_value_set_object (value, self->hash);
      break;

    case PROP_BLOOM_FILTER_HEADER_COMPRESSION:
      g_value_set_object (value, self->compression);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
bloom_filter_header_instance_init (BloomFilterHeader * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->numBytes = 0;
  object->algorithm = g_object_new (TYPE_BLOOM_FILTER_ALGORITHM, NULL);
  object->hash = g_object_new (TYPE_BLOOM_FILTER_HASH, NULL);
  object->compression = g_object_new (TYPE_BLOOM_FILTER_COMPRESSION, NULL);
}

static void 
bloom_filter_header_finalize (GObject *object)
{
  BloomFilterHeader *tobject = BLOOM_FILTER_HEADER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->algorithm != NULL)
  {
    g_object_unref(tobject->algorithm);
    tobject->algorithm = NULL;
  }
  if (tobject->hash != NULL)
  {
    g_object_unref(tobject->hash);
    tobject->hash = NULL;
  }
  if (tobject->compression != NULL)
  {
    g_object_unref(tobject->compression);
    tobject->compression = NULL;
  }
}

static void
bloom_filter_header_class_init (BloomFilterHeaderClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = bloom_filter_header_read;
  struct_class->write = bloom_filter_header_write;

  gobject_class->finalize = bloom_filter_header_finalize;
  gobject_class->get_property = bloom_filter_header_get_property;
  gobject_class->set_property = bloom_filter_header_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_BLOOM_FILTER_HEADER_NUM_BYTES,
     g_param_spec_int ("numBytes",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BLOOM_FILTER_HEADER_ALGORITHM,
     g_param_spec_object ("algorithm",
                         NULL,
                         NULL,
                         TYPE_BLOOM_FILTER_ALGORITHM,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BLOOM_FILTER_HEADER_HASH,
     g_param_spec_object ("hash",
                         NULL,
                         NULL,
                         TYPE_BLOOM_FILTER_HASH,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_BLOOM_FILTER_HEADER_COMPRESSION,
     g_param_spec_object ("compression",
                         NULL,
                         NULL,
                         TYPE_BLOOM_FILTER_COMPRESSION,
                         G_PARAM_READWRITE));
}

GType
bloom_filter_header_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (BloomFilterHeaderClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) bloom_filter_header_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (BloomFilterHeader),
      0, /* n_preallocs */
      (GInstanceInitFunc) bloom_filter_header_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "BloomFilterHeaderType",
                                   &type_info, 0);
  }

  return type;
}

enum _PageHeaderProperties
{
  PROP_PAGE_HEADER_0,
  PROP_PAGE_HEADER_TYPE,
  PROP_PAGE_HEADER_UNCOMPRESSED_PAGE_SIZE,
  PROP_PAGE_HEADER_COMPRESSED_PAGE_SIZE,
  PROP_PAGE_HEADER_CRC,
  PROP_PAGE_HEADER_DATA_PAGE_HEADER,
  PROP_PAGE_HEADER_INDEX_PAGE_HEADER,
  PROP_PAGE_HEADER_DICTIONARY_PAGE_HEADER,
  PROP_PAGE_HEADER_DATA_PAGE_HEADER_V2
};

/* reads a page_header object */
static gint32
page_header_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PageHeader * this_object = PAGE_HEADER(object);
  gboolean isset_type = FALSE;
  gboolean isset_uncompressed_page_size = FALSE;
  gboolean isset_compressed_page_size = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast15;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast15, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (PageType)ecast15;
          isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->uncompressed_page_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_uncompressed_page_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->compressed_page_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_compressed_page_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->crc, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_crc = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->data_page_header), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_data_page_header = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->index_page_header), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_index_page_header = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->dictionary_page_header), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_dictionary_page_header = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->data_page_header_v2), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_data_page_header_v2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_uncompressed_page_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_compressed_page_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
page_header_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PageHeader * this_object = PAGE_HEADER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PageHeader", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "uncompressed_page_size", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->uncompressed_page_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compressed_page_size", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->compressed_page_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_crc == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "crc", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->crc, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_data_page_header == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "data_page_header", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->data_page_header), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_index_page_header == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "index_page_header", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->index_page_header), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_dictionary_page_header == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "dictionary_page_header", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->dictionary_page_header), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_data_page_header_v2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "data_page_header_v2", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->data_page_header_v2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
page_header_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  PageHeader *self = PAGE_HEADER (object);

  switch (property_id)
  {
    case PROP_PAGE_HEADER_TYPE:
      self->type = g_value_get_int (value);
      break;

    case PROP_PAGE_HEADER_UNCOMPRESSED_PAGE_SIZE:
      self->uncompressed_page_size = g_value_get_int (value);
      break;

    case PROP_PAGE_HEADER_COMPRESSED_PAGE_SIZE:
      self->compressed_page_size = g_value_get_int (value);
      break;

    case PROP_PAGE_HEADER_CRC:
      self->crc = g_value_get_int (value);
      self->__isset_crc = TRUE;
      break;

    case PROP_PAGE_HEADER_DATA_PAGE_HEADER:
      if (self->data_page_header != NULL)
        g_object_unref (self->data_page_header);
      self->data_page_header = g_value_dup_object (value);
      self->__isset_data_page_header = TRUE;
      break;

    case PROP_PAGE_HEADER_INDEX_PAGE_HEADER:
      if (self->index_page_header != NULL)
        g_object_unref (self->index_page_header);
      self->index_page_header = g_value_dup_object (value);
      self->__isset_index_page_header = TRUE;
      break;

    case PROP_PAGE_HEADER_DICTIONARY_PAGE_HEADER:
      if (self->dictionary_page_header != NULL)
        g_object_unref (self->dictionary_page_header);
      self->dictionary_page_header = g_value_dup_object (value);
      self->__isset_dictionary_page_header = TRUE;
      break;

    case PROP_PAGE_HEADER_DATA_PAGE_HEADER_V2:
      if (self->data_page_header_v2 != NULL)
        g_object_unref (self->data_page_header_v2);
      self->data_page_header_v2 = g_value_dup_object (value);
      self->__isset_data_page_header_v2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
page_header_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  PageHeader *self = PAGE_HEADER (object);

  switch (property_id)
  {
    case PROP_PAGE_HEADER_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_PAGE_HEADER_UNCOMPRESSED_PAGE_SIZE:
      g_value_set_int (value, self->uncompressed_page_size);
      break;

    case PROP_PAGE_HEADER_COMPRESSED_PAGE_SIZE:
      g_value_set_int (value, self->compressed_page_size);
      break;

    case PROP_PAGE_HEADER_CRC:
      g_value_set_int (value, self->crc);
      break;

    case PROP_PAGE_HEADER_DATA_PAGE_HEADER:
      g_value_set_object (value, self->data_page_header);
      break;

    case PROP_PAGE_HEADER_INDEX_PAGE_HEADER:
      g_value_set_object (value, self->index_page_header);
      break;

    case PROP_PAGE_HEADER_DICTIONARY_PAGE_HEADER:
      g_value_set_object (value, self->dictionary_page_header);
      break;

    case PROP_PAGE_HEADER_DATA_PAGE_HEADER_V2:
      g_value_set_object (value, self->data_page_header_v2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
page_header_instance_init (PageHeader * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->uncompressed_page_size = 0;
  object->compressed_page_size = 0;
  object->crc = 0;
  object->__isset_crc = FALSE;
  object->data_page_header = g_object_new (TYPE_DATA_PAGE_HEADER, NULL);
  object->__isset_data_page_header = FALSE;
  object->index_page_header = g_object_new (TYPE_INDEX_PAGE_HEADER, NULL);
  object->__isset_index_page_header = FALSE;
  object->dictionary_page_header = g_object_new (TYPE_DICTIONARY_PAGE_HEADER, NULL);
  object->__isset_dictionary_page_header = FALSE;
  object->data_page_header_v2 = g_object_new (TYPE_DATA_PAGE_HEADER_V2, NULL);
  object->__isset_data_page_header_v2 = FALSE;
}

static void 
page_header_finalize (GObject *object)
{
  PageHeader *tobject = PAGE_HEADER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->data_page_header != NULL)
  {
    g_object_unref(tobject->data_page_header);
    tobject->data_page_header = NULL;
  }
  if (tobject->index_page_header != NULL)
  {
    g_object_unref(tobject->index_page_header);
    tobject->index_page_header = NULL;
  }
  if (tobject->dictionary_page_header != NULL)
  {
    g_object_unref(tobject->dictionary_page_header);
    tobject->dictionary_page_header = NULL;
  }
  if (tobject->data_page_header_v2 != NULL)
  {
    g_object_unref(tobject->data_page_header_v2);
    tobject->data_page_header_v2 = NULL;
  }
}

static void
page_header_class_init (PageHeaderClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = page_header_read;
  struct_class->write = page_header_write;

  gobject_class->finalize = page_header_finalize;
  gobject_class->get_property = page_header_get_property;
  gobject_class->set_property = page_header_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_HEADER_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_HEADER_UNCOMPRESSED_PAGE_SIZE,
     g_param_spec_int ("uncompressed_page_size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_HEADER_COMPRESSED_PAGE_SIZE,
     g_param_spec_int ("compressed_page_size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_HEADER_CRC,
     g_param_spec_int ("crc",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_HEADER_DATA_PAGE_HEADER,
     g_param_spec_object ("data_page_header",
                         NULL,
                         NULL,
                         TYPE_DATA_PAGE_HEADER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_HEADER_INDEX_PAGE_HEADER,
     g_param_spec_object ("index_page_header",
                         NULL,
                         NULL,
                         TYPE_INDEX_PAGE_HEADER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_HEADER_DICTIONARY_PAGE_HEADER,
     g_param_spec_object ("dictionary_page_header",
                         NULL,
                         NULL,
                         TYPE_DICTIONARY_PAGE_HEADER,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_HEADER_DATA_PAGE_HEADER_V2,
     g_param_spec_object ("data_page_header_v2",
                         NULL,
                         NULL,
                         TYPE_DATA_PAGE_HEADER_V2,
                         G_PARAM_READWRITE));
}

GType
page_header_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PageHeaderClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) page_header_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PageHeader),
      0, /* n_preallocs */
      (GInstanceInitFunc) page_header_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PageHeaderType",
                                   &type_info, 0);
  }

  return type;
}

enum _KeyValueProperties
{
  PROP_KEY_VALUE_0,
  PROP_KEY_VALUE_KEY,
  PROP_KEY_VALUE_VALUE
};

/* reads a key_value object */
static gint32
key_value_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  KeyValue * this_object = KEY_VALUE(object);
  gboolean isset_key = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_key)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
key_value_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  KeyValue * this_object = KEY_VALUE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "KeyValue", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_value == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->value, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
key_value_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  KeyValue *self = KEY_VALUE (object);

  switch (property_id)
  {
    case PROP_KEY_VALUE_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      break;

    case PROP_KEY_VALUE_VALUE:
      if (self->value != NULL)
        g_free (self->value);
      self->value = g_value_dup_string (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
key_value_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  KeyValue *self = KEY_VALUE (object);

  switch (property_id)
  {
    case PROP_KEY_VALUE_KEY:
      g_value_set_string (value, self->key);
      break;

    case PROP_KEY_VALUE_VALUE:
      g_value_set_string (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
key_value_instance_init (KeyValue * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->value = NULL;
  object->__isset_value = FALSE;
}

static void 
key_value_finalize (GObject *object)
{
  KeyValue *tobject = KEY_VALUE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    g_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
key_value_class_init (KeyValueClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = key_value_read;
  struct_class->write = key_value_write;

  gobject_class->finalize = key_value_finalize;
  gobject_class->get_property = key_value_get_property;
  gobject_class->set_property = key_value_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_KEY_VALUE_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_KEY_VALUE_VALUE,
     g_param_spec_string ("value",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
key_value_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (KeyValueClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) key_value_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (KeyValue),
      0, /* n_preallocs */
      (GInstanceInitFunc) key_value_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "KeyValueType",
                                   &type_info, 0);
  }

  return type;
}

enum _SortingColumnProperties
{
  PROP_SORTING_COLUMN_0,
  PROP_SORTING_COLUMN_COLUMN_IDX,
  PROP_SORTING_COLUMN_DESCENDING,
  PROP_SORTING_COLUMN_NULLS_FIRST
};

/* reads a sorting_column object */
static gint32
sorting_column_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  SortingColumn * this_object = SORTING_COLUMN(object);
  gboolean isset_column_idx = FALSE;
  gboolean isset_descending = FALSE;
  gboolean isset_nulls_first = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->column_idx, error)) < 0)
            return -1;
          xfer += ret;
          isset_column_idx = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->descending, error)) < 0)
            return -1;
          xfer += ret;
          isset_descending = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->nulls_first, error)) < 0)
            return -1;
          xfer += ret;
          isset_nulls_first = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_column_idx)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_descending)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_nulls_first)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
sorting_column_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  SortingColumn * this_object = SORTING_COLUMN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SortingColumn", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "column_idx", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->column_idx, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "descending", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->descending, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nulls_first", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->nulls_first, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
sorting_column_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  SortingColumn *self = SORTING_COLUMN (object);

  switch (property_id)
  {
    case PROP_SORTING_COLUMN_COLUMN_IDX:
      self->column_idx = g_value_get_int (value);
      break;

    case PROP_SORTING_COLUMN_DESCENDING:
      self->descending = g_value_get_boolean (value);
      break;

    case PROP_SORTING_COLUMN_NULLS_FIRST:
      self->nulls_first = g_value_get_boolean (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
sorting_column_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  SortingColumn *self = SORTING_COLUMN (object);

  switch (property_id)
  {
    case PROP_SORTING_COLUMN_COLUMN_IDX:
      g_value_set_int (value, self->column_idx);
      break;

    case PROP_SORTING_COLUMN_DESCENDING:
      g_value_set_boolean (value, self->descending);
      break;

    case PROP_SORTING_COLUMN_NULLS_FIRST:
      g_value_set_boolean (value, self->nulls_first);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
sorting_column_instance_init (SortingColumn * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->column_idx = 0;
  object->descending = 0;
  object->nulls_first = 0;
}

static void 
sorting_column_finalize (GObject *object)
{
  SortingColumn *tobject = SORTING_COLUMN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
sorting_column_class_init (SortingColumnClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = sorting_column_read;
  struct_class->write = sorting_column_write;

  gobject_class->finalize = sorting_column_finalize;
  gobject_class->get_property = sorting_column_get_property;
  gobject_class->set_property = sorting_column_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SORTING_COLUMN_COLUMN_IDX,
     g_param_spec_int ("column_idx",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SORTING_COLUMN_DESCENDING,
     g_param_spec_boolean ("descending",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SORTING_COLUMN_NULLS_FIRST,
     g_param_spec_boolean ("nulls_first",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
sorting_column_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (SortingColumnClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) sorting_column_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (SortingColumn),
      0, /* n_preallocs */
      (GInstanceInitFunc) sorting_column_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "SortingColumnType",
                                   &type_info, 0);
  }

  return type;
}

enum _PageEncodingStatsProperties
{
  PROP_PAGE_ENCODING_STATS_0,
  PROP_PAGE_ENCODING_STATS_PAGE_TYPE,
  PROP_PAGE_ENCODING_STATS_ENCODING,
  PROP_PAGE_ENCODING_STATS_COUNT
};

/* reads a page_encoding_stats object */
static gint32
page_encoding_stats_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PageEncodingStats * this_object = PAGE_ENCODING_STATS(object);
  gboolean isset_page_type = FALSE;
  gboolean isset_encoding = FALSE;
  gboolean isset_count = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast16;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->page_type = (PageType)ecast16;
          isset_page_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast17;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast17, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoding = (Encoding)ecast17;
          isset_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->count, error)) < 0)
            return -1;
          xfer += ret;
          isset_count = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_page_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_encoding)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_count)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
page_encoding_stats_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PageEncodingStats * this_object = PAGE_ENCODING_STATS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PageEncodingStats", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "page_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->page_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encoding", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoding, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "count", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->count, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
page_encoding_stats_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  PageEncodingStats *self = PAGE_ENCODING_STATS (object);

  switch (property_id)
  {
    case PROP_PAGE_ENCODING_STATS_PAGE_TYPE:
      self->page_type = g_value_get_int (value);
      break;

    case PROP_PAGE_ENCODING_STATS_ENCODING:
      self->encoding = g_value_get_int (value);
      break;

    case PROP_PAGE_ENCODING_STATS_COUNT:
      self->count = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
page_encoding_stats_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  PageEncodingStats *self = PAGE_ENCODING_STATS (object);

  switch (property_id)
  {
    case PROP_PAGE_ENCODING_STATS_PAGE_TYPE:
      g_value_set_int (value, self->page_type);
      break;

    case PROP_PAGE_ENCODING_STATS_ENCODING:
      g_value_set_int (value, self->encoding);
      break;

    case PROP_PAGE_ENCODING_STATS_COUNT:
      g_value_set_int (value, self->count);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
page_encoding_stats_instance_init (PageEncodingStats * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->count = 0;
}

static void 
page_encoding_stats_finalize (GObject *object)
{
  PageEncodingStats *tobject = PAGE_ENCODING_STATS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
page_encoding_stats_class_init (PageEncodingStatsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = page_encoding_stats_read;
  struct_class->write = page_encoding_stats_write;

  gobject_class->finalize = page_encoding_stats_finalize;
  gobject_class->get_property = page_encoding_stats_get_property;
  gobject_class->set_property = page_encoding_stats_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_ENCODING_STATS_PAGE_TYPE,
     g_param_spec_int ("page_type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_ENCODING_STATS_ENCODING,
     g_param_spec_int ("encoding",
                       NULL,
                       NULL,
                       0,
                       9,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_ENCODING_STATS_COUNT,
     g_param_spec_int ("count",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
page_encoding_stats_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PageEncodingStatsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) page_encoding_stats_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PageEncodingStats),
      0, /* n_preallocs */
      (GInstanceInitFunc) page_encoding_stats_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PageEncodingStatsType",
                                   &type_info, 0);
  }

  return type;
}

enum _ColumnMetaDataProperties
{
  PROP_COLUMN_META_DATA_0,
  PROP_COLUMN_META_DATA_TYPE,
  PROP_COLUMN_META_DATA_ENCODINGS,
  PROP_COLUMN_META_DATA_PATH_IN_SCHEMA,
  PROP_COLUMN_META_DATA_CODEC,
  PROP_COLUMN_META_DATA_NUM_VALUES,
  PROP_COLUMN_META_DATA_TOTAL_UNCOMPRESSED_SIZE,
  PROP_COLUMN_META_DATA_TOTAL_COMPRESSED_SIZE,
  PROP_COLUMN_META_DATA_KEY_VALUE_METADATA,
  PROP_COLUMN_META_DATA_DATA_PAGE_OFFSET,
  PROP_COLUMN_META_DATA_INDEX_PAGE_OFFSET,
  PROP_COLUMN_META_DATA_DICTIONARY_PAGE_OFFSET,
  PROP_COLUMN_META_DATA_STATISTICS,
  PROP_COLUMN_META_DATA_ENCODING_STATS,
  PROP_COLUMN_META_DATA_BLOOM_FILTER_OFFSET,
  PROP_COLUMN_META_DATA_BLOOM_FILTER_LENGTH,
  PROP_COLUMN_META_DATA_SIZE_STATISTICS,
  PROP_COLUMN_META_DATA_GEOSPATIAL_STATISTICS
};

/* reads a column_meta_data object */
static gint32
column_meta_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnMetaData * this_object = COLUMN_META_DATA(object);
  gboolean isset_type = FALSE;
  gboolean isset_encodings = FALSE;
  gboolean isset_path_in_schema = FALSE;
  gboolean isset_codec = FALSE;
  gboolean isset_num_values = FALSE;
  gboolean isset_total_uncompressed_size = FALSE;
  gboolean isset_total_compressed_size = FALSE;
  gboolean isset_data_page_offset = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast18;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast18, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (Type)ecast18;
          isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Encoding* _elem19 = g_new (Encoding, 1);
              gint32 ecast20;
              if ((ret = thrift_protocol_read_i32 (protocol, &ecast20, error)) < 0)
                return -1;
              xfer += ret;
              *_elem19 = (Encoding)ecast20;
              g_array_append_vals (this_object->encodings, _elem19, 1);
              g_free (_elem19);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_encodings = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem21 = NULL;
              if (_elem21 != NULL)
              {
                g_free(_elem21);
                _elem21 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem21, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->path_in_schema, _elem21);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_path_in_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast22;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast22, error)) < 0)
            return -1;
          xfer += ret;
          this_object->codec = (CompressionCodec)ecast22;
          isset_codec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->num_values, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->total_uncompressed_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_total_uncompressed_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->total_compressed_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_total_compressed_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              KeyValue * _elem23 = NULL;
              if ( _elem23 != NULL)
              {
                g_object_unref (_elem23);
              }
              _elem23 = g_object_new (TYPE_KEY_VALUE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem23), protocol, error)) < 0)
              {
                g_object_unref (_elem23);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->key_value_metadata, _elem23);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_key_value_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->data_page_offset, error)) < 0)
            return -1;
          xfer += ret;
          isset_data_page_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->index_page_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_index_page_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->dictionary_page_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_dictionary_page_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_statistics = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PageEncodingStats * _elem24 = NULL;
              if ( _elem24 != NULL)
              {
                g_object_unref (_elem24);
              }
              _elem24 = g_object_new (TYPE_PAGE_ENCODING_STATS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem24), protocol, error)) < 0)
              {
                g_object_unref (_elem24);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->encoding_stats, _elem24);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_encoding_stats = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->bloom_filter_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bloom_filter_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->bloom_filter_length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_bloom_filter_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->size_statistics), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_size_statistics = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->geospatial_statistics), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_geospatial_statistics = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_encodings)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_path_in_schema)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_codec)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_num_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_total_uncompressed_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_total_compressed_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_data_page_offset)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
column_meta_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnMetaData * this_object = COLUMN_META_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnMetaData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encodings", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i25;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->encodings ? this_object->encodings->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i25 = 0; i25 < (this_object->encodings ? this_object->encodings->len : 0); i25++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (gint32) (g_array_index (this_object->encodings, Encoding, i25)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path_in_schema", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i26;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->path_in_schema ? this_object->path_in_schema->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i26 = 0; i26 < (this_object->path_in_schema ? this_object->path_in_schema->len : 0); i26++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->path_in_schema, i26)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "codec", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->codec, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_values", T_I64, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->num_values, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "total_uncompressed_size", T_I64, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->total_uncompressed_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "total_compressed_size", T_I64, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->total_compressed_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_key_value_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_value_metadata", T_LIST, 8, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i27;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->key_value_metadata ? this_object->key_value_metadata->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i27 = 0; i27 < (this_object->key_value_metadata ? this_object->key_value_metadata->len : 0); i27++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->key_value_metadata, i27))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "data_page_offset", T_I64, 9, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->data_page_offset, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_index_page_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "index_page_offset", T_I64, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->index_page_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_dictionary_page_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "dictionary_page_offset", T_I64, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->dictionary_page_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_statistics == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "statistics", T_STRUCT, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->statistics), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_encoding_stats == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encoding_stats", T_LIST, 13, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i28;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->encoding_stats ? this_object->encoding_stats->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i28 = 0; i28 < (this_object->encoding_stats ? this_object->encoding_stats->len : 0); i28++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->encoding_stats, i28))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_bloom_filter_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "bloom_filter_offset", T_I64, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->bloom_filter_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_bloom_filter_length == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "bloom_filter_length", T_I32, 15, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->bloom_filter_length, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_size_statistics == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "size_statistics", T_STRUCT, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->size_statistics), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_geospatial_statistics == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "geospatial_statistics", T_STRUCT, 17, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->geospatial_statistics), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
column_meta_data_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  ColumnMetaData *self = COLUMN_META_DATA (object);

  switch (property_id)
  {
    case PROP_COLUMN_META_DATA_TYPE:
      self->type = g_value_get_int (value);
      break;

    case PROP_COLUMN_META_DATA_ENCODINGS:
      if (self->encodings != NULL)
        g_array_unref (self->encodings);
      self->encodings = g_value_dup_boxed (value);
      break;

    case PROP_COLUMN_META_DATA_PATH_IN_SCHEMA:
      if (self->path_in_schema != NULL)
        g_ptr_array_unref (self->path_in_schema);
      self->path_in_schema = g_value_dup_boxed (value);
      break;

    case PROP_COLUMN_META_DATA_CODEC:
      self->codec = g_value_get_int (value);
      break;

    case PROP_COLUMN_META_DATA_NUM_VALUES:
      self->num_values = g_value_get_int64 (value);
      break;

    case PROP_COLUMN_META_DATA_TOTAL_UNCOMPRESSED_SIZE:
      self->total_uncompressed_size = g_value_get_int64 (value);
      break;

    case PROP_COLUMN_META_DATA_TOTAL_COMPRESSED_SIZE:
      self->total_compressed_size = g_value_get_int64 (value);
      break;

    case PROP_COLUMN_META_DATA_KEY_VALUE_METADATA:
      if (self->key_value_metadata != NULL)
        g_ptr_array_unref (self->key_value_metadata);
      self->key_value_metadata = g_value_dup_boxed (value);
      self->__isset_key_value_metadata = TRUE;
      break;

    case PROP_COLUMN_META_DATA_DATA_PAGE_OFFSET:
      self->data_page_offset = g_value_get_int64 (value);
      break;

    case PROP_COLUMN_META_DATA_INDEX_PAGE_OFFSET:
      self->index_page_offset = g_value_get_int64 (value);
      self->__isset_index_page_offset = TRUE;
      break;

    case PROP_COLUMN_META_DATA_DICTIONARY_PAGE_OFFSET:
      self->dictionary_page_offset = g_value_get_int64 (value);
      self->__isset_dictionary_page_offset = TRUE;
      break;

    case PROP_COLUMN_META_DATA_STATISTICS:
      if (self->statistics != NULL)
        g_object_unref (self->statistics);
      self->statistics = g_value_dup_object (value);
      self->__isset_statistics = TRUE;
      break;

    case PROP_COLUMN_META_DATA_ENCODING_STATS:
      if (self->encoding_stats != NULL)
        g_ptr_array_unref (self->encoding_stats);
      self->encoding_stats = g_value_dup_boxed (value);
      self->__isset_encoding_stats = TRUE;
      break;

    case PROP_COLUMN_META_DATA_BLOOM_FILTER_OFFSET:
      self->bloom_filter_offset = g_value_get_int64 (value);
      self->__isset_bloom_filter_offset = TRUE;
      break;

    case PROP_COLUMN_META_DATA_BLOOM_FILTER_LENGTH:
      self->bloom_filter_length = g_value_get_int (value);
      self->__isset_bloom_filter_length = TRUE;
      break;

    case PROP_COLUMN_META_DATA_SIZE_STATISTICS:
      if (self->size_statistics != NULL)
        g_object_unref (self->size_statistics);
      self->size_statistics = g_value_dup_object (value);
      self->__isset_size_statistics = TRUE;
      break;

    case PROP_COLUMN_META_DATA_GEOSPATIAL_STATISTICS:
      if (self->geospatial_statistics != NULL)
        g_object_unref (self->geospatial_statistics);
      self->geospatial_statistics = g_value_dup_object (value);
      self->__isset_geospatial_statistics = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
column_meta_data_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  ColumnMetaData *self = COLUMN_META_DATA (object);

  switch (property_id)
  {
    case PROP_COLUMN_META_DATA_TYPE:
      g_value_set_int (value, self->type);
      break;

    case PROP_COLUMN_META_DATA_ENCODINGS:
      g_value_set_boxed (value, self->encodings);
      break;

    case PROP_COLUMN_META_DATA_PATH_IN_SCHEMA:
      g_value_set_boxed (value, self->path_in_schema);
      break;

    case PROP_COLUMN_META_DATA_CODEC:
      g_value_set_int (value, self->codec);
      break;

    case PROP_COLUMN_META_DATA_NUM_VALUES:
      g_value_set_int64 (value, self->num_values);
      break;

    case PROP_COLUMN_META_DATA_TOTAL_UNCOMPRESSED_SIZE:
      g_value_set_int64 (value, self->total_uncompressed_size);
      break;

    case PROP_COLUMN_META_DATA_TOTAL_COMPRESSED_SIZE:
      g_value_set_int64 (value, self->total_compressed_size);
      break;

    case PROP_COLUMN_META_DATA_KEY_VALUE_METADATA:
      g_value_set_boxed (value, self->key_value_metadata);
      break;

    case PROP_COLUMN_META_DATA_DATA_PAGE_OFFSET:
      g_value_set_int64 (value, self->data_page_offset);
      break;

    case PROP_COLUMN_META_DATA_INDEX_PAGE_OFFSET:
      g_value_set_int64 (value, self->index_page_offset);
      break;

    case PROP_COLUMN_META_DATA_DICTIONARY_PAGE_OFFSET:
      g_value_set_int64 (value, self->dictionary_page_offset);
      break;

    case PROP_COLUMN_META_DATA_STATISTICS:
      g_value_set_object (value, self->statistics);
      break;

    case PROP_COLUMN_META_DATA_ENCODING_STATS:
      g_value_set_boxed (value, self->encoding_stats);
      break;

    case PROP_COLUMN_META_DATA_BLOOM_FILTER_OFFSET:
      g_value_set_int64 (value, self->bloom_filter_offset);
      break;

    case PROP_COLUMN_META_DATA_BLOOM_FILTER_LENGTH:
      g_value_set_int (value, self->bloom_filter_length);
      break;

    case PROP_COLUMN_META_DATA_SIZE_STATISTICS:
      g_value_set_object (value, self->size_statistics);
      break;

    case PROP_COLUMN_META_DATA_GEOSPATIAL_STATISTICS:
      g_value_set_object (value, self->geospatial_statistics);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
column_meta_data_instance_init (ColumnMetaData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->encodings = g_array_new (0, 1, sizeof (Encoding));
  object->path_in_schema = g_ptr_array_new_with_free_func (g_free);
  object->num_values = 0;
  object->total_uncompressed_size = 0;
  object->total_compressed_size = 0;
  object->key_value_metadata = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_key_value_metadata = FALSE;
  object->data_page_offset = 0;
  object->index_page_offset = 0;
  object->__isset_index_page_offset = FALSE;
  object->dictionary_page_offset = 0;
  object->__isset_dictionary_page_offset = FALSE;
  object->statistics = g_object_new (TYPE_STATISTICS, NULL);
  object->__isset_statistics = FALSE;
  object->encoding_stats = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_encoding_stats = FALSE;
  object->bloom_filter_offset = 0;
  object->__isset_bloom_filter_offset = FALSE;
  object->bloom_filter_length = 0;
  object->__isset_bloom_filter_length = FALSE;
  object->size_statistics = g_object_new (TYPE_SIZE_STATISTICS, NULL);
  object->__isset_size_statistics = FALSE;
  object->geospatial_statistics = g_object_new (TYPE_GEOSPATIAL_STATISTICS, NULL);
  object->__isset_geospatial_statistics = FALSE;
}

static void 
column_meta_data_finalize (GObject *object)
{
  ColumnMetaData *tobject = COLUMN_META_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->encodings != NULL)
  {
    g_array_unref (tobject->encodings);
    tobject->encodings = NULL;
  }
  if (tobject->path_in_schema != NULL)
  {
    g_ptr_array_unref (tobject->path_in_schema);
    tobject->path_in_schema = NULL;
  }
  if (tobject->key_value_metadata != NULL)
  {
    g_ptr_array_unref (tobject->key_value_metadata);
    tobject->key_value_metadata = NULL;
  }
  if (tobject->statistics != NULL)
  {
    g_object_unref(tobject->statistics);
    tobject->statistics = NULL;
  }
  if (tobject->encoding_stats != NULL)
  {
    g_ptr_array_unref (tobject->encoding_stats);
    tobject->encoding_stats = NULL;
  }
  if (tobject->size_statistics != NULL)
  {
    g_object_unref(tobject->size_statistics);
    tobject->size_statistics = NULL;
  }
  if (tobject->geospatial_statistics != NULL)
  {
    g_object_unref(tobject->geospatial_statistics);
    tobject->geospatial_statistics = NULL;
  }
}

static void
column_meta_data_class_init (ColumnMetaDataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = column_meta_data_read;
  struct_class->write = column_meta_data_write;

  gobject_class->finalize = column_meta_data_finalize;
  gobject_class->get_property = column_meta_data_get_property;
  gobject_class->set_property = column_meta_data_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       7,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_ENCODINGS,
     g_param_spec_boxed ("encodings",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_PATH_IN_SCHEMA,
     g_param_spec_boxed ("path_in_schema",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_CODEC,
     g_param_spec_int ("codec",
                       NULL,
                       NULL,
                       0,
                       7,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_NUM_VALUES,
     g_param_spec_int64 ("num_values",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_TOTAL_UNCOMPRESSED_SIZE,
     g_param_spec_int64 ("total_uncompressed_size",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_TOTAL_COMPRESSED_SIZE,
     g_param_spec_int64 ("total_compressed_size",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_KEY_VALUE_METADATA,
     g_param_spec_boxed ("key_value_metadata",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_DATA_PAGE_OFFSET,
     g_param_spec_int64 ("data_page_offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_INDEX_PAGE_OFFSET,
     g_param_spec_int64 ("index_page_offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_DICTIONARY_PAGE_OFFSET,
     g_param_spec_int64 ("dictionary_page_offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_STATISTICS,
     g_param_spec_object ("statistics",
                         NULL,
                         NULL,
                         TYPE_STATISTICS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_ENCODING_STATS,
     g_param_spec_boxed ("encoding_stats",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_BLOOM_FILTER_OFFSET,
     g_param_spec_int64 ("bloom_filter_offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_BLOOM_FILTER_LENGTH,
     g_param_spec_int ("bloom_filter_length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_SIZE_STATISTICS,
     g_param_spec_object ("size_statistics",
                         NULL,
                         NULL,
                         TYPE_SIZE_STATISTICS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_META_DATA_GEOSPATIAL_STATISTICS,
     g_param_spec_object ("geospatial_statistics",
                         NULL,
                         NULL,
                         TYPE_GEOSPATIAL_STATISTICS,
                         G_PARAM_READWRITE));
}

GType
column_meta_data_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnMetaDataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_meta_data_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColumnMetaData),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_meta_data_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnMetaDataType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a encryption_with_footer_key object */
static gint32
encryption_with_footer_key_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EncryptionWithFooterKey * this_object = ENCRYPTION_WITH_FOOTER_KEY(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
encryption_with_footer_key_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EncryptionWithFooterKey * this_object = ENCRYPTION_WITH_FOOTER_KEY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EncryptionWithFooterKey", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
encryption_with_footer_key_instance_init (EncryptionWithFooterKey * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
encryption_with_footer_key_finalize (GObject *object)
{
  EncryptionWithFooterKey *tobject = ENCRYPTION_WITH_FOOTER_KEY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
encryption_with_footer_key_class_init (EncryptionWithFooterKeyClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = encryption_with_footer_key_read;
  struct_class->write = encryption_with_footer_key_write;

  gobject_class->finalize = encryption_with_footer_key_finalize;
}

GType
encryption_with_footer_key_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EncryptionWithFooterKeyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) encryption_with_footer_key_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EncryptionWithFooterKey),
      0, /* n_preallocs */
      (GInstanceInitFunc) encryption_with_footer_key_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EncryptionWithFooterKeyType",
                                   &type_info, 0);
  }

  return type;
}

enum _EncryptionWithColumnKeyProperties
{
  PROP_ENCRYPTION_WITH_COLUMN_KEY_0,
  PROP_ENCRYPTION_WITH_COLUMN_KEY_PATH_IN_SCHEMA,
  PROP_ENCRYPTION_WITH_COLUMN_KEY_KEY_METADATA
};

/* reads a encryption_with_column_key object */
static gint32
encryption_with_column_key_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EncryptionWithColumnKey * this_object = ENCRYPTION_WITH_COLUMN_KEY(object);
  gboolean isset_path_in_schema = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem29 = NULL;
              if (_elem29 != NULL)
              {
                g_free(_elem29);
                _elem29 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem29, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->path_in_schema, _elem29);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_path_in_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->key_metadata != NULL)
          {
            g_free(this_object->key_metadata);
            this_object->key_metadata = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key_metadata = g_byte_array_new();
          g_byte_array_append (this_object->key_metadata, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_key_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_path_in_schema)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
encryption_with_column_key_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EncryptionWithColumnKey * this_object = ENCRYPTION_WITH_COLUMN_KEY(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EncryptionWithColumnKey", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "path_in_schema", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i30;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->path_in_schema ? this_object->path_in_schema->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i30 = 0; i30 < (this_object->path_in_schema ? this_object->path_in_schema->len : 0); i30++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->path_in_schema, i30)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_key_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_metadata", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->key_metadata ? ((GByteArray *) this_object->key_metadata)->data : NULL, this_object->key_metadata ? ((GByteArray *) this_object->key_metadata)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
encryption_with_column_key_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  EncryptionWithColumnKey *self = ENCRYPTION_WITH_COLUMN_KEY (object);

  switch (property_id)
  {
    case PROP_ENCRYPTION_WITH_COLUMN_KEY_PATH_IN_SCHEMA:
      if (self->path_in_schema != NULL)
        g_ptr_array_unref (self->path_in_schema);
      self->path_in_schema = g_value_dup_boxed (value);
      break;

    case PROP_ENCRYPTION_WITH_COLUMN_KEY_KEY_METADATA:
      if (self->key_metadata != NULL)
        g_byte_array_unref (self->key_metadata);
      self->key_metadata = g_value_dup_boxed (value);
      self->__isset_key_metadata = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
encryption_with_column_key_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  EncryptionWithColumnKey *self = ENCRYPTION_WITH_COLUMN_KEY (object);

  switch (property_id)
  {
    case PROP_ENCRYPTION_WITH_COLUMN_KEY_PATH_IN_SCHEMA:
      g_value_set_boxed (value, self->path_in_schema);
      break;

    case PROP_ENCRYPTION_WITH_COLUMN_KEY_KEY_METADATA:
      g_value_set_boxed (value, self->key_metadata);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
encryption_with_column_key_instance_init (EncryptionWithColumnKey * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->path_in_schema = g_ptr_array_new_with_free_func (g_free);
  object->key_metadata = NULL;
  object->__isset_key_metadata = FALSE;
}

static void 
encryption_with_column_key_finalize (GObject *object)
{
  EncryptionWithColumnKey *tobject = ENCRYPTION_WITH_COLUMN_KEY (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->path_in_schema != NULL)
  {
    g_ptr_array_unref (tobject->path_in_schema);
    tobject->path_in_schema = NULL;
  }
  if (tobject->key_metadata != NULL)
  {
    thrift_string_free(tobject->key_metadata);
    tobject->key_metadata = NULL;
  }
}

static void
encryption_with_column_key_class_init (EncryptionWithColumnKeyClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = encryption_with_column_key_read;
  struct_class->write = encryption_with_column_key_write;

  gobject_class->finalize = encryption_with_column_key_finalize;
  gobject_class->get_property = encryption_with_column_key_get_property;
  gobject_class->set_property = encryption_with_column_key_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ENCRYPTION_WITH_COLUMN_KEY_PATH_IN_SCHEMA,
     g_param_spec_boxed ("path_in_schema",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ENCRYPTION_WITH_COLUMN_KEY_KEY_METADATA,
     g_param_spec_boxed ("key_metadata",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
encryption_with_column_key_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EncryptionWithColumnKeyClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) encryption_with_column_key_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EncryptionWithColumnKey),
      0, /* n_preallocs */
      (GInstanceInitFunc) encryption_with_column_key_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EncryptionWithColumnKeyType",
                                   &type_info, 0);
  }

  return type;
}

enum _ColumnCryptoMetaDataProperties
{
  PROP_COLUMN_CRYPTO_META_DATA_0,
  PROP_COLUMN_CRYPTO_META_DATA_E_N_C_R_Y_P_T_I_O_N__W_I_T_H__F_O_O_T_E_R__K_E_Y,
  PROP_COLUMN_CRYPTO_META_DATA_E_N_C_R_Y_P_T_I_O_N__W_I_T_H__C_O_L_U_M_N__K_E_Y
};

/* reads a column_crypto_meta_data object */
static gint32
column_crypto_meta_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnCryptoMetaData * this_object = COLUMN_CRYPTO_META_DATA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ENCRYPTION_WITH_FOOTER_KEY), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ENCRYPTION_WITH_FOOTER_KEY = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ENCRYPTION_WITH_COLUMN_KEY), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ENCRYPTION_WITH_COLUMN_KEY = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
column_crypto_meta_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnCryptoMetaData * this_object = COLUMN_CRYPTO_META_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnCryptoMetaData", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ENCRYPTION_WITH_FOOTER_KEY == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ENCRYPTION_WITH_FOOTER_KEY", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ENCRYPTION_WITH_FOOTER_KEY), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ENCRYPTION_WITH_COLUMN_KEY == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ENCRYPTION_WITH_COLUMN_KEY", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ENCRYPTION_WITH_COLUMN_KEY), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
column_crypto_meta_data_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  ColumnCryptoMetaData *self = COLUMN_CRYPTO_META_DATA (object);

  switch (property_id)
  {
    case PROP_COLUMN_CRYPTO_META_DATA_E_N_C_R_Y_P_T_I_O_N__W_I_T_H__F_O_O_T_E_R__K_E_Y:
      if (self->ENCRYPTION_WITH_FOOTER_KEY != NULL)
        g_object_unref (self->ENCRYPTION_WITH_FOOTER_KEY);
      self->ENCRYPTION_WITH_FOOTER_KEY = g_value_dup_object (value);
      self->__isset_ENCRYPTION_WITH_FOOTER_KEY = TRUE;
      break;

    case PROP_COLUMN_CRYPTO_META_DATA_E_N_C_R_Y_P_T_I_O_N__W_I_T_H__C_O_L_U_M_N__K_E_Y:
      if (self->ENCRYPTION_WITH_COLUMN_KEY != NULL)
        g_object_unref (self->ENCRYPTION_WITH_COLUMN_KEY);
      self->ENCRYPTION_WITH_COLUMN_KEY = g_value_dup_object (value);
      self->__isset_ENCRYPTION_WITH_COLUMN_KEY = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
column_crypto_meta_data_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  ColumnCryptoMetaData *self = COLUMN_CRYPTO_META_DATA (object);

  switch (property_id)
  {
    case PROP_COLUMN_CRYPTO_META_DATA_E_N_C_R_Y_P_T_I_O_N__W_I_T_H__F_O_O_T_E_R__K_E_Y:
      g_value_set_object (value, self->ENCRYPTION_WITH_FOOTER_KEY);
      break;

    case PROP_COLUMN_CRYPTO_META_DATA_E_N_C_R_Y_P_T_I_O_N__W_I_T_H__C_O_L_U_M_N__K_E_Y:
      g_value_set_object (value, self->ENCRYPTION_WITH_COLUMN_KEY);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
column_crypto_meta_data_instance_init (ColumnCryptoMetaData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ENCRYPTION_WITH_FOOTER_KEY = g_object_new (TYPE_ENCRYPTION_WITH_FOOTER_KEY, NULL);
  object->__isset_ENCRYPTION_WITH_FOOTER_KEY = FALSE;
  object->ENCRYPTION_WITH_COLUMN_KEY = g_object_new (TYPE_ENCRYPTION_WITH_COLUMN_KEY, NULL);
  object->__isset_ENCRYPTION_WITH_COLUMN_KEY = FALSE;
}

static void 
column_crypto_meta_data_finalize (GObject *object)
{
  ColumnCryptoMetaData *tobject = COLUMN_CRYPTO_META_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ENCRYPTION_WITH_FOOTER_KEY != NULL)
  {
    g_object_unref(tobject->ENCRYPTION_WITH_FOOTER_KEY);
    tobject->ENCRYPTION_WITH_FOOTER_KEY = NULL;
  }
  if (tobject->ENCRYPTION_WITH_COLUMN_KEY != NULL)
  {
    g_object_unref(tobject->ENCRYPTION_WITH_COLUMN_KEY);
    tobject->ENCRYPTION_WITH_COLUMN_KEY = NULL;
  }
}

static void
column_crypto_meta_data_class_init (ColumnCryptoMetaDataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = column_crypto_meta_data_read;
  struct_class->write = column_crypto_meta_data_write;

  gobject_class->finalize = column_crypto_meta_data_finalize;
  gobject_class->get_property = column_crypto_meta_data_get_property;
  gobject_class->set_property = column_crypto_meta_data_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CRYPTO_META_DATA_E_N_C_R_Y_P_T_I_O_N__W_I_T_H__F_O_O_T_E_R__K_E_Y,
     g_param_spec_object ("ENCRYPTION_WITH_FOOTER_KEY",
                         NULL,
                         NULL,
                         TYPE_ENCRYPTION_WITH_FOOTER_KEY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CRYPTO_META_DATA_E_N_C_R_Y_P_T_I_O_N__W_I_T_H__C_O_L_U_M_N__K_E_Y,
     g_param_spec_object ("ENCRYPTION_WITH_COLUMN_KEY",
                         NULL,
                         NULL,
                         TYPE_ENCRYPTION_WITH_COLUMN_KEY,
                         G_PARAM_READWRITE));
}

GType
column_crypto_meta_data_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnCryptoMetaDataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_crypto_meta_data_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColumnCryptoMetaData),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_crypto_meta_data_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnCryptoMetaDataType",
                                   &type_info, 0);
  }

  return type;
}

enum _ColumnChunkProperties
{
  PROP_COLUMN_CHUNK_0,
  PROP_COLUMN_CHUNK_FILE_PATH,
  PROP_COLUMN_CHUNK_FILE_OFFSET,
  PROP_COLUMN_CHUNK_META_DATA,
  PROP_COLUMN_CHUNK_OFFSET_INDEX_OFFSET,
  PROP_COLUMN_CHUNK_OFFSET_INDEX_LENGTH,
  PROP_COLUMN_CHUNK_COLUMN_INDEX_OFFSET,
  PROP_COLUMN_CHUNK_COLUMN_INDEX_LENGTH,
  PROP_COLUMN_CHUNK_CRYPTO_METADATA,
  PROP_COLUMN_CHUNK_ENCRYPTED_COLUMN_METADATA
};

/* reads a column_chunk object */
static gint32
column_chunk_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnChunk * this_object = COLUMN_CHUNK(object);
  gboolean isset_file_offset = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->file_path != NULL)
          {
            g_free(this_object->file_path);
            this_object->file_path = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->file_path, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_file_path = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->file_offset, error)) < 0)
            return -1;
          xfer += ret;
          isset_file_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->meta_data), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_meta_data = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->offset_index_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offset_index_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->offset_index_length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offset_index_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->column_index_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_column_index_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->column_index_length, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_column_index_length = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->crypto_metadata), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_crypto_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->encrypted_column_metadata != NULL)
          {
            g_free(this_object->encrypted_column_metadata);
            this_object->encrypted_column_metadata = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encrypted_column_metadata = g_byte_array_new();
          g_byte_array_append (this_object->encrypted_column_metadata, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_encrypted_column_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_file_offset)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
column_chunk_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnChunk * this_object = COLUMN_CHUNK(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnChunk", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_file_path == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "file_path", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->file_path, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "file_offset", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->file_offset, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_meta_data == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "meta_data", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->meta_data), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_offset_index_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offset_index_offset", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->offset_index_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_offset_index_length == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offset_index_length", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->offset_index_length, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column_index_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_index_offset", T_I64, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->column_index_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column_index_length == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_index_length", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->column_index_length, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_crypto_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "crypto_metadata", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->crypto_metadata), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_encrypted_column_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encrypted_column_metadata", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->encrypted_column_metadata ? ((GByteArray *) this_object->encrypted_column_metadata)->data : NULL, this_object->encrypted_column_metadata ? ((GByteArray *) this_object->encrypted_column_metadata)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
column_chunk_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  ColumnChunk *self = COLUMN_CHUNK (object);

  switch (property_id)
  {
    case PROP_COLUMN_CHUNK_FILE_PATH:
      if (self->file_path != NULL)
        g_free (self->file_path);
      self->file_path = g_value_dup_string (value);
      self->__isset_file_path = TRUE;
      break;

    case PROP_COLUMN_CHUNK_FILE_OFFSET:
      self->file_offset = g_value_get_int64 (value);
      break;

    case PROP_COLUMN_CHUNK_META_DATA:
      if (self->meta_data != NULL)
        g_object_unref (self->meta_data);
      self->meta_data = g_value_dup_object (value);
      self->__isset_meta_data = TRUE;
      break;

    case PROP_COLUMN_CHUNK_OFFSET_INDEX_OFFSET:
      self->offset_index_offset = g_value_get_int64 (value);
      self->__isset_offset_index_offset = TRUE;
      break;

    case PROP_COLUMN_CHUNK_OFFSET_INDEX_LENGTH:
      self->offset_index_length = g_value_get_int (value);
      self->__isset_offset_index_length = TRUE;
      break;

    case PROP_COLUMN_CHUNK_COLUMN_INDEX_OFFSET:
      self->column_index_offset = g_value_get_int64 (value);
      self->__isset_column_index_offset = TRUE;
      break;

    case PROP_COLUMN_CHUNK_COLUMN_INDEX_LENGTH:
      self->column_index_length = g_value_get_int (value);
      self->__isset_column_index_length = TRUE;
      break;

    case PROP_COLUMN_CHUNK_CRYPTO_METADATA:
      if (self->crypto_metadata != NULL)
        g_object_unref (self->crypto_metadata);
      self->crypto_metadata = g_value_dup_object (value);
      self->__isset_crypto_metadata = TRUE;
      break;

    case PROP_COLUMN_CHUNK_ENCRYPTED_COLUMN_METADATA:
      if (self->encrypted_column_metadata != NULL)
        g_byte_array_unref (self->encrypted_column_metadata);
      self->encrypted_column_metadata = g_value_dup_boxed (value);
      self->__isset_encrypted_column_metadata = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
column_chunk_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  ColumnChunk *self = COLUMN_CHUNK (object);

  switch (property_id)
  {
    case PROP_COLUMN_CHUNK_FILE_PATH:
      g_value_set_string (value, self->file_path);
      break;

    case PROP_COLUMN_CHUNK_FILE_OFFSET:
      g_value_set_int64 (value, self->file_offset);
      break;

    case PROP_COLUMN_CHUNK_META_DATA:
      g_value_set_object (value, self->meta_data);
      break;

    case PROP_COLUMN_CHUNK_OFFSET_INDEX_OFFSET:
      g_value_set_int64 (value, self->offset_index_offset);
      break;

    case PROP_COLUMN_CHUNK_OFFSET_INDEX_LENGTH:
      g_value_set_int (value, self->offset_index_length);
      break;

    case PROP_COLUMN_CHUNK_COLUMN_INDEX_OFFSET:
      g_value_set_int64 (value, self->column_index_offset);
      break;

    case PROP_COLUMN_CHUNK_COLUMN_INDEX_LENGTH:
      g_value_set_int (value, self->column_index_length);
      break;

    case PROP_COLUMN_CHUNK_CRYPTO_METADATA:
      g_value_set_object (value, self->crypto_metadata);
      break;

    case PROP_COLUMN_CHUNK_ENCRYPTED_COLUMN_METADATA:
      g_value_set_boxed (value, self->encrypted_column_metadata);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
column_chunk_instance_init (ColumnChunk * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->file_path = NULL;
  object->__isset_file_path = FALSE;
  object->file_offset = G_GINT64_CONSTANT (0);
  object->meta_data = g_object_new (TYPE_COLUMN_META_DATA, NULL);
  object->__isset_meta_data = FALSE;
  object->offset_index_offset = 0;
  object->__isset_offset_index_offset = FALSE;
  object->offset_index_length = 0;
  object->__isset_offset_index_length = FALSE;
  object->column_index_offset = 0;
  object->__isset_column_index_offset = FALSE;
  object->column_index_length = 0;
  object->__isset_column_index_length = FALSE;
  object->crypto_metadata = g_object_new (TYPE_COLUMN_CRYPTO_META_DATA, NULL);
  object->__isset_crypto_metadata = FALSE;
  object->encrypted_column_metadata = NULL;
  object->__isset_encrypted_column_metadata = FALSE;
}

static void 
column_chunk_finalize (GObject *object)
{
  ColumnChunk *tobject = COLUMN_CHUNK (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->file_path != NULL)
  {
    g_free(tobject->file_path);
    tobject->file_path = NULL;
  }
  if (tobject->meta_data != NULL)
  {
    g_object_unref(tobject->meta_data);
    tobject->meta_data = NULL;
  }
  if (tobject->crypto_metadata != NULL)
  {
    g_object_unref(tobject->crypto_metadata);
    tobject->crypto_metadata = NULL;
  }
  if (tobject->encrypted_column_metadata != NULL)
  {
    thrift_string_free(tobject->encrypted_column_metadata);
    tobject->encrypted_column_metadata = NULL;
  }
}

static void
column_chunk_class_init (ColumnChunkClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = column_chunk_read;
  struct_class->write = column_chunk_write;

  gobject_class->finalize = column_chunk_finalize;
  gobject_class->get_property = column_chunk_get_property;
  gobject_class->set_property = column_chunk_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CHUNK_FILE_PATH,
     g_param_spec_string ("file_path",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CHUNK_FILE_OFFSET,
     g_param_spec_int64 ("file_offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CHUNK_META_DATA,
     g_param_spec_object ("meta_data",
                         NULL,
                         NULL,
                         TYPE_COLUMN_META_DATA,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CHUNK_OFFSET_INDEX_OFFSET,
     g_param_spec_int64 ("offset_index_offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CHUNK_OFFSET_INDEX_LENGTH,
     g_param_spec_int ("offset_index_length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CHUNK_COLUMN_INDEX_OFFSET,
     g_param_spec_int64 ("column_index_offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CHUNK_COLUMN_INDEX_LENGTH,
     g_param_spec_int ("column_index_length",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CHUNK_CRYPTO_METADATA,
     g_param_spec_object ("crypto_metadata",
                         NULL,
                         NULL,
                         TYPE_COLUMN_CRYPTO_META_DATA,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_CHUNK_ENCRYPTED_COLUMN_METADATA,
     g_param_spec_boxed ("encrypted_column_metadata",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
column_chunk_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnChunkClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_chunk_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColumnChunk),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_chunk_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnChunkType",
                                   &type_info, 0);
  }

  return type;
}

enum _RowGroupProperties
{
  PROP_ROW_GROUP_0,
  PROP_ROW_GROUP_COLUMNS,
  PROP_ROW_GROUP_TOTAL_BYTE_SIZE,
  PROP_ROW_GROUP_NUM_ROWS,
  PROP_ROW_GROUP_SORTING_COLUMNS,
  PROP_ROW_GROUP_FILE_OFFSET,
  PROP_ROW_GROUP_TOTAL_COMPRESSED_SIZE,
  PROP_ROW_GROUP_ORDINAL
};

/* reads a row_group object */
static gint32
row_group_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  RowGroup * this_object = ROW_GROUP(object);
  gboolean isset_columns = FALSE;
  gboolean isset_total_byte_size = FALSE;
  gboolean isset_num_rows = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ColumnChunk * _elem31 = NULL;
              if ( _elem31 != NULL)
              {
                g_object_unref (_elem31);
              }
              _elem31 = g_object_new (TYPE_COLUMN_CHUNK, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem31), protocol, error)) < 0)
              {
                g_object_unref (_elem31);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns, _elem31);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->total_byte_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_total_byte_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->num_rows, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              SortingColumn * _elem32 = NULL;
              if ( _elem32 != NULL)
              {
                g_object_unref (_elem32);
              }
              _elem32 = g_object_new (TYPE_SORTING_COLUMN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem32), protocol, error)) < 0)
              {
                g_object_unref (_elem32);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->sorting_columns, _elem32);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_sorting_columns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->file_offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_file_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->total_compressed_size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_total_compressed_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I16)
        {
          if ((ret = thrift_protocol_read_i16 (protocol, &this_object->ordinal, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ordinal = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_columns)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_total_byte_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_num_rows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
row_group_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  RowGroup * this_object = ROW_GROUP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "RowGroup", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i33;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns ? this_object->columns->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i33 = 0; i33 < (this_object->columns ? this_object->columns->len : 0); i33++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns, i33))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "total_byte_size", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->total_byte_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_rows", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->num_rows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_sorting_columns == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "sorting_columns", T_LIST, 4, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i34;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->sorting_columns ? this_object->sorting_columns->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i34 = 0; i34 < (this_object->sorting_columns ? this_object->sorting_columns->len : 0); i34++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->sorting_columns, i34))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_file_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "file_offset", T_I64, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->file_offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_total_compressed_size == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "total_compressed_size", T_I64, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->total_compressed_size, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ordinal == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ordinal", T_I16, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i16 (protocol, this_object->ordinal, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
row_group_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  RowGroup *self = ROW_GROUP (object);

  switch (property_id)
  {
    case PROP_ROW_GROUP_COLUMNS:
      if (self->columns != NULL)
        g_ptr_array_unref (self->columns);
      self->columns = g_value_dup_boxed (value);
      break;

    case PROP_ROW_GROUP_TOTAL_BYTE_SIZE:
      self->total_byte_size = g_value_get_int64 (value);
      break;

    case PROP_ROW_GROUP_NUM_ROWS:
      self->num_rows = g_value_get_int64 (value);
      break;

    case PROP_ROW_GROUP_SORTING_COLUMNS:
      if (self->sorting_columns != NULL)
        g_ptr_array_unref (self->sorting_columns);
      self->sorting_columns = g_value_dup_boxed (value);
      self->__isset_sorting_columns = TRUE;
      break;

    case PROP_ROW_GROUP_FILE_OFFSET:
      self->file_offset = g_value_get_int64 (value);
      self->__isset_file_offset = TRUE;
      break;

    case PROP_ROW_GROUP_TOTAL_COMPRESSED_SIZE:
      self->total_compressed_size = g_value_get_int64 (value);
      self->__isset_total_compressed_size = TRUE;
      break;

    case PROP_ROW_GROUP_ORDINAL:
      self->ordinal = g_value_get_int (value);
      self->__isset_ordinal = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
row_group_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  RowGroup *self = ROW_GROUP (object);

  switch (property_id)
  {
    case PROP_ROW_GROUP_COLUMNS:
      g_value_set_boxed (value, self->columns);
      break;

    case PROP_ROW_GROUP_TOTAL_BYTE_SIZE:
      g_value_set_int64 (value, self->total_byte_size);
      break;

    case PROP_ROW_GROUP_NUM_ROWS:
      g_value_set_int64 (value, self->num_rows);
      break;

    case PROP_ROW_GROUP_SORTING_COLUMNS:
      g_value_set_boxed (value, self->sorting_columns);
      break;

    case PROP_ROW_GROUP_FILE_OFFSET:
      g_value_set_int64 (value, self->file_offset);
      break;

    case PROP_ROW_GROUP_TOTAL_COMPRESSED_SIZE:
      g_value_set_int64 (value, self->total_compressed_size);
      break;

    case PROP_ROW_GROUP_ORDINAL:
      g_value_set_int (value, self->ordinal);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
row_group_instance_init (RowGroup * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->columns = g_ptr_array_new_with_free_func (g_object_unref);
  object->total_byte_size = 0;
  object->num_rows = 0;
  object->sorting_columns = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_sorting_columns = FALSE;
  object->file_offset = 0;
  object->__isset_file_offset = FALSE;
  object->total_compressed_size = 0;
  object->__isset_total_compressed_size = FALSE;
  object->ordinal = 0;
  object->__isset_ordinal = FALSE;
}

static void 
row_group_finalize (GObject *object)
{
  RowGroup *tobject = ROW_GROUP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->columns != NULL)
  {
    g_ptr_array_unref (tobject->columns);
    tobject->columns = NULL;
  }
  if (tobject->sorting_columns != NULL)
  {
    g_ptr_array_unref (tobject->sorting_columns);
    tobject->sorting_columns = NULL;
  }
}

static void
row_group_class_init (RowGroupClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = row_group_read;
  struct_class->write = row_group_write;

  gobject_class->finalize = row_group_finalize;
  gobject_class->get_property = row_group_get_property;
  gobject_class->set_property = row_group_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ROW_GROUP_COLUMNS,
     g_param_spec_boxed ("columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ROW_GROUP_TOTAL_BYTE_SIZE,
     g_param_spec_int64 ("total_byte_size",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ROW_GROUP_NUM_ROWS,
     g_param_spec_int64 ("num_rows",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ROW_GROUP_SORTING_COLUMNS,
     g_param_spec_boxed ("sorting_columns",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ROW_GROUP_FILE_OFFSET,
     g_param_spec_int64 ("file_offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ROW_GROUP_TOTAL_COMPRESSED_SIZE,
     g_param_spec_int64 ("total_compressed_size",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ROW_GROUP_ORDINAL,
     g_param_spec_int ("ordinal",
                       NULL,
                       NULL,
                       G_MININT16,
                       G_MAXINT16,
                       0,
                       G_PARAM_READWRITE));
}

GType
row_group_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RowGroupClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) row_group_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (RowGroup),
      0, /* n_preallocs */
      (GInstanceInitFunc) row_group_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RowGroupType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a type_defined_order object */
static gint32
type_defined_order_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TypeDefinedOrder * this_object = TYPE_DEFINED_ORDER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
type_defined_order_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TypeDefinedOrder * this_object = TYPE_DEFINED_ORDER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TypeDefinedOrder", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
type_defined_order_instance_init (TypeDefinedOrder * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
type_defined_order_finalize (GObject *object)
{
  TypeDefinedOrder *tobject = TYPE_DEFINED_ORDER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
type_defined_order_class_init (TypeDefinedOrderClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = type_defined_order_read;
  struct_class->write = type_defined_order_write;

  gobject_class->finalize = type_defined_order_finalize;
}

GType
type_defined_order_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TypeDefinedOrderClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) type_defined_order_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TypeDefinedOrder),
      0, /* n_preallocs */
      (GInstanceInitFunc) type_defined_order_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TypeDefinedOrderType",
                                   &type_info, 0);
  }

  return type;
}

enum _ColumnOrderProperties
{
  PROP_COLUMN_ORDER_0,
  PROP_COLUMN_ORDER_T_Y_P_E__O_R_D_E_R
};

/* reads a column_order object */
static gint32
column_order_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnOrder * this_object = COLUMN_ORDER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->TYPE_ORDER), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_TYPE_ORDER = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
column_order_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnOrder * this_object = COLUMN_ORDER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnOrder", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_TYPE_ORDER == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "TYPE_ORDER", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->TYPE_ORDER), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
column_order_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  ColumnOrder *self = COLUMN_ORDER (object);

  switch (property_id)
  {
    case PROP_COLUMN_ORDER_T_Y_P_E__O_R_D_E_R:
      if (self->TYPE_ORDER != NULL)
        g_object_unref (self->TYPE_ORDER);
      self->TYPE_ORDER = g_value_dup_object (value);
      self->__isset_TYPE_ORDER = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
column_order_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  ColumnOrder *self = COLUMN_ORDER (object);

  switch (property_id)
  {
    case PROP_COLUMN_ORDER_T_Y_P_E__O_R_D_E_R:
      g_value_set_object (value, self->TYPE_ORDER);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
column_order_instance_init (ColumnOrder * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->TYPE_ORDER = g_object_new (TYPE_TYPE_DEFINED_ORDER, NULL);
  object->__isset_TYPE_ORDER = FALSE;
}

static void 
column_order_finalize (GObject *object)
{
  ColumnOrder *tobject = COLUMN_ORDER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->TYPE_ORDER != NULL)
  {
    g_object_unref(tobject->TYPE_ORDER);
    tobject->TYPE_ORDER = NULL;
  }
}

static void
column_order_class_init (ColumnOrderClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = column_order_read;
  struct_class->write = column_order_write;

  gobject_class->finalize = column_order_finalize;
  gobject_class->get_property = column_order_get_property;
  gobject_class->set_property = column_order_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_ORDER_T_Y_P_E__O_R_D_E_R,
     g_param_spec_object ("TYPE_ORDER",
                         NULL,
                         NULL,
                         TYPE_TYPE_DEFINED_ORDER,
                         G_PARAM_READWRITE));
}

GType
column_order_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnOrderClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_order_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColumnOrder),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_order_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnOrderType",
                                   &type_info, 0);
  }

  return type;
}

enum _PageLocationProperties
{
  PROP_PAGE_LOCATION_0,
  PROP_PAGE_LOCATION_OFFSET,
  PROP_PAGE_LOCATION_COMPRESSED_PAGE_SIZE,
  PROP_PAGE_LOCATION_FIRST_ROW_INDEX
};

/* reads a page_location object */
static gint32
page_location_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PageLocation * this_object = PAGE_LOCATION(object);
  gboolean isset_offset = FALSE;
  gboolean isset_compressed_page_size = FALSE;
  gboolean isset_first_row_index = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->offset, error)) < 0)
            return -1;
          xfer += ret;
          isset_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->compressed_page_size, error)) < 0)
            return -1;
          xfer += ret;
          isset_compressed_page_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->first_row_index, error)) < 0)
            return -1;
          xfer += ret;
          isset_first_row_index = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_offset)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_compressed_page_size)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_first_row_index)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
page_location_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PageLocation * this_object = PAGE_LOCATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PageLocation", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "offset", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->offset, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compressed_page_size", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->compressed_page_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "first_row_index", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->first_row_index, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
page_location_set_property (GObject *object,
                            guint property_id,
                            const GValue *value,
                            GParamSpec *pspec)
{
  PageLocation *self = PAGE_LOCATION (object);

  switch (property_id)
  {
    case PROP_PAGE_LOCATION_OFFSET:
      self->offset = g_value_get_int64 (value);
      break;

    case PROP_PAGE_LOCATION_COMPRESSED_PAGE_SIZE:
      self->compressed_page_size = g_value_get_int (value);
      break;

    case PROP_PAGE_LOCATION_FIRST_ROW_INDEX:
      self->first_row_index = g_value_get_int64 (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
page_location_get_property (GObject *object,
                            guint property_id,
                            GValue *value,
                            GParamSpec *pspec)
{
  PageLocation *self = PAGE_LOCATION (object);

  switch (property_id)
  {
    case PROP_PAGE_LOCATION_OFFSET:
      g_value_set_int64 (value, self->offset);
      break;

    case PROP_PAGE_LOCATION_COMPRESSED_PAGE_SIZE:
      g_value_set_int (value, self->compressed_page_size);
      break;

    case PROP_PAGE_LOCATION_FIRST_ROW_INDEX:
      g_value_set_int64 (value, self->first_row_index);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
page_location_instance_init (PageLocation * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->offset = 0;
  object->compressed_page_size = 0;
  object->first_row_index = 0;
}

static void 
page_location_finalize (GObject *object)
{
  PageLocation *tobject = PAGE_LOCATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
page_location_class_init (PageLocationClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = page_location_read;
  struct_class->write = page_location_write;

  gobject_class->finalize = page_location_finalize;
  gobject_class->get_property = page_location_get_property;
  gobject_class->set_property = page_location_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_LOCATION_OFFSET,
     g_param_spec_int64 ("offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_LOCATION_COMPRESSED_PAGE_SIZE,
     g_param_spec_int ("compressed_page_size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PAGE_LOCATION_FIRST_ROW_INDEX,
     g_param_spec_int64 ("first_row_index",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
page_location_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PageLocationClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) page_location_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PageLocation),
      0, /* n_preallocs */
      (GInstanceInitFunc) page_location_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PageLocationType",
                                   &type_info, 0);
  }

  return type;
}

enum _OffsetIndexProperties
{
  PROP_OFFSET_INDEX_0,
  PROP_OFFSET_INDEX_PAGE_LOCATIONS,
  PROP_OFFSET_INDEX_UNENCODED_BYTE_ARRAY_DATA_BYTES
};

/* reads a offset_index object */
static gint32
offset_index_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  OffsetIndex * this_object = OFFSET_INDEX(object);
  gboolean isset_page_locations = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PageLocation * _elem35 = NULL;
              if ( _elem35 != NULL)
              {
                g_object_unref (_elem35);
              }
              _elem35 = g_object_new (TYPE_PAGE_LOCATION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem35), protocol, error)) < 0)
              {
                g_object_unref (_elem35);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->page_locations, _elem35);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_page_locations = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem36 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem36, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->unencoded_byte_array_data_bytes, _elem36, 1);
              g_free (_elem36);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_unencoded_byte_array_data_bytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_page_locations)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
offset_index_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  OffsetIndex * this_object = OFFSET_INDEX(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "OffsetIndex", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "page_locations", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i37;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->page_locations ? this_object->page_locations->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i37 = 0; i37 < (this_object->page_locations ? this_object->page_locations->len : 0); i37++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->page_locations, i37))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_unencoded_byte_array_data_bytes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "unencoded_byte_array_data_bytes", T_LIST, 2, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i38;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->unencoded_byte_array_data_bytes ? this_object->unencoded_byte_array_data_bytes->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i38 = 0; i38 < (this_object->unencoded_byte_array_data_bytes ? this_object->unencoded_byte_array_data_bytes->len : 0); i38++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->unencoded_byte_array_data_bytes, gint64, i38)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
offset_index_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  OffsetIndex *self = OFFSET_INDEX (object);

  switch (property_id)
  {
    case PROP_OFFSET_INDEX_PAGE_LOCATIONS:
      if (self->page_locations != NULL)
        g_ptr_array_unref (self->page_locations);
      self->page_locations = g_value_dup_boxed (value);
      break;

    case PROP_OFFSET_INDEX_UNENCODED_BYTE_ARRAY_DATA_BYTES:
      if (self->unencoded_byte_array_data_bytes != NULL)
        g_array_unref (self->unencoded_byte_array_data_bytes);
      self->unencoded_byte_array_data_bytes = g_value_dup_boxed (value);
      self->__isset_unencoded_byte_array_data_bytes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
offset_index_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  OffsetIndex *self = OFFSET_INDEX (object);

  switch (property_id)
  {
    case PROP_OFFSET_INDEX_PAGE_LOCATIONS:
      g_value_set_boxed (value, self->page_locations);
      break;

    case PROP_OFFSET_INDEX_UNENCODED_BYTE_ARRAY_DATA_BYTES:
      g_value_set_boxed (value, self->unencoded_byte_array_data_bytes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
offset_index_instance_init (OffsetIndex * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->page_locations = g_ptr_array_new_with_free_func (g_object_unref);
  object->unencoded_byte_array_data_bytes = g_array_new (0, 1, sizeof (gint64));
  object->__isset_unencoded_byte_array_data_bytes = FALSE;
}

static void 
offset_index_finalize (GObject *object)
{
  OffsetIndex *tobject = OFFSET_INDEX (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->page_locations != NULL)
  {
    g_ptr_array_unref (tobject->page_locations);
    tobject->page_locations = NULL;
  }
  if (tobject->unencoded_byte_array_data_bytes != NULL)
  {
    g_array_unref (tobject->unencoded_byte_array_data_bytes);
    tobject->unencoded_byte_array_data_bytes = NULL;
  }
}

static void
offset_index_class_init (OffsetIndexClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = offset_index_read;
  struct_class->write = offset_index_write;

  gobject_class->finalize = offset_index_finalize;
  gobject_class->get_property = offset_index_get_property;
  gobject_class->set_property = offset_index_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_OFFSET_INDEX_PAGE_LOCATIONS,
     g_param_spec_boxed ("page_locations",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_OFFSET_INDEX_UNENCODED_BYTE_ARRAY_DATA_BYTES,
     g_param_spec_boxed ("unencoded_byte_array_data_bytes",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
offset_index_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (OffsetIndexClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) offset_index_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (OffsetIndex),
      0, /* n_preallocs */
      (GInstanceInitFunc) offset_index_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "OffsetIndexType",
                                   &type_info, 0);
  }

  return type;
}

enum _ColumnIndexProperties
{
  PROP_COLUMN_INDEX_0,
  PROP_COLUMN_INDEX_NULL_PAGES,
  PROP_COLUMN_INDEX_MIN_VALUES,
  PROP_COLUMN_INDEX_MAX_VALUES,
  PROP_COLUMN_INDEX_BOUNDARY_ORDER,
  PROP_COLUMN_INDEX_NULL_COUNTS,
  PROP_COLUMN_INDEX_REPETITION_LEVEL_HISTOGRAMS,
  PROP_COLUMN_INDEX_DEFINITION_LEVEL_HISTOGRAMS
};

/* reads a column_index object */
static gint32
column_index_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ColumnIndex * this_object = COLUMN_INDEX(object);
  gboolean isset_null_pages = FALSE;
  gboolean isset_min_values = FALSE;
  gboolean isset_max_values = FALSE;
  gboolean isset_boundary_order = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gboolean* _elem39 = g_new (gboolean, 1);
              if ((ret = thrift_protocol_read_bool (protocol, &*_elem39, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->null_pages, _elem39, 1);
              g_free (_elem39);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_null_pages = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem40 = NULL;
              if (_elem40 != NULL)
              {
                g_free(_elem40);
                _elem40 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem40 = g_byte_array_new();
              g_byte_array_append (_elem40, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->min_values, _elem40);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_min_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem41 = NULL;
              if (_elem41 != NULL)
              {
                g_free(_elem41);
                _elem41 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem41 = g_byte_array_new();
              g_byte_array_append (_elem41, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->max_values, _elem41);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_max_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast42;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast42, error)) < 0)
            return -1;
          xfer += ret;
          this_object->boundary_order = (BoundaryOrder)ecast42;
          isset_boundary_order = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem43 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem43, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->null_counts, _elem43, 1);
              g_free (_elem43);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_null_counts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem44 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem44, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->repetition_level_histograms, _elem44, 1);
              g_free (_elem44);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_repetition_level_histograms = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem45 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem45, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->definition_level_histograms, _elem45, 1);
              g_free (_elem45);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_definition_level_histograms = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_null_pages)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_min_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_max_values)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_boundary_order)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
column_index_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ColumnIndex * this_object = COLUMN_INDEX(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ColumnIndex", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "null_pages", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i46;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_BOOL, (gint32) (this_object->null_pages ? this_object->null_pages->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i46 = 0; i46 < (this_object->null_pages ? this_object->null_pages->len : 0); i46++)
    {
      if ((ret = thrift_protocol_write_bool (protocol, (g_array_index (this_object->null_pages, gboolean, i46)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "min_values", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i47;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->min_values ? this_object->min_values->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i47 = 0; i47 < (this_object->min_values ? this_object->min_values->len : 0); i47++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->min_values, i47)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->min_values, i47)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->min_values, i47)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->min_values, i47)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "max_values", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i48;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->max_values ? this_object->max_values->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i48 = 0; i48 < (this_object->max_values ? this_object->max_values->len : 0); i48++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->max_values, i48)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->max_values, i48)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->max_values, i48)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->max_values, i48)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "boundary_order", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->boundary_order, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_null_counts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "null_counts", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i49;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->null_counts ? this_object->null_counts->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i49 = 0; i49 < (this_object->null_counts ? this_object->null_counts->len : 0); i49++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->null_counts, gint64, i49)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_repetition_level_histograms == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "repetition_level_histograms", T_LIST, 6, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i50;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->repetition_level_histograms ? this_object->repetition_level_histograms->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i50 = 0; i50 < (this_object->repetition_level_histograms ? this_object->repetition_level_histograms->len : 0); i50++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->repetition_level_histograms, gint64, i50)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_definition_level_histograms == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "definition_level_histograms", T_LIST, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i51;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->definition_level_histograms ? this_object->definition_level_histograms->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i51 = 0; i51 < (this_object->definition_level_histograms ? this_object->definition_level_histograms->len : 0); i51++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->definition_level_histograms, gint64, i51)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
column_index_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  ColumnIndex *self = COLUMN_INDEX (object);

  switch (property_id)
  {
    case PROP_COLUMN_INDEX_NULL_PAGES:
      if (self->null_pages != NULL)
        g_array_unref (self->null_pages);
      self->null_pages = g_value_dup_boxed (value);
      break;

    case PROP_COLUMN_INDEX_MIN_VALUES:
      if (self->min_values != NULL)
        g_ptr_array_unref (self->min_values);
      self->min_values = g_value_dup_boxed (value);
      break;

    case PROP_COLUMN_INDEX_MAX_VALUES:
      if (self->max_values != NULL)
        g_ptr_array_unref (self->max_values);
      self->max_values = g_value_dup_boxed (value);
      break;

    case PROP_COLUMN_INDEX_BOUNDARY_ORDER:
      self->boundary_order = g_value_get_int (value);
      break;

    case PROP_COLUMN_INDEX_NULL_COUNTS:
      if (self->null_counts != NULL)
        g_array_unref (self->null_counts);
      self->null_counts = g_value_dup_boxed (value);
      self->__isset_null_counts = TRUE;
      break;

    case PROP_COLUMN_INDEX_REPETITION_LEVEL_HISTOGRAMS:
      if (self->repetition_level_histograms != NULL)
        g_array_unref (self->repetition_level_histograms);
      self->repetition_level_histograms = g_value_dup_boxed (value);
      self->__isset_repetition_level_histograms = TRUE;
      break;

    case PROP_COLUMN_INDEX_DEFINITION_LEVEL_HISTOGRAMS:
      if (self->definition_level_histograms != NULL)
        g_array_unref (self->definition_level_histograms);
      self->definition_level_histograms = g_value_dup_boxed (value);
      self->__isset_definition_level_histograms = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
column_index_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  ColumnIndex *self = COLUMN_INDEX (object);

  switch (property_id)
  {
    case PROP_COLUMN_INDEX_NULL_PAGES:
      g_value_set_boxed (value, self->null_pages);
      break;

    case PROP_COLUMN_INDEX_MIN_VALUES:
      g_value_set_boxed (value, self->min_values);
      break;

    case PROP_COLUMN_INDEX_MAX_VALUES:
      g_value_set_boxed (value, self->max_values);
      break;

    case PROP_COLUMN_INDEX_BOUNDARY_ORDER:
      g_value_set_int (value, self->boundary_order);
      break;

    case PROP_COLUMN_INDEX_NULL_COUNTS:
      g_value_set_boxed (value, self->null_counts);
      break;

    case PROP_COLUMN_INDEX_REPETITION_LEVEL_HISTOGRAMS:
      g_value_set_boxed (value, self->repetition_level_histograms);
      break;

    case PROP_COLUMN_INDEX_DEFINITION_LEVEL_HISTOGRAMS:
      g_value_set_boxed (value, self->definition_level_histograms);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
column_index_instance_init (ColumnIndex * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->null_pages = g_array_new (0, 1, sizeof (gboolean));
  object->min_values = g_ptr_array_new_with_free_func (thrift_string_free);
  object->max_values = g_ptr_array_new_with_free_func (thrift_string_free);
  object->null_counts = g_array_new (0, 1, sizeof (gint64));
  object->__isset_null_counts = FALSE;
  object->repetition_level_histograms = g_array_new (0, 1, sizeof (gint64));
  object->__isset_repetition_level_histograms = FALSE;
  object->definition_level_histograms = g_array_new (0, 1, sizeof (gint64));
  object->__isset_definition_level_histograms = FALSE;
}

static void 
column_index_finalize (GObject *object)
{
  ColumnIndex *tobject = COLUMN_INDEX (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->null_pages != NULL)
  {
    g_array_unref (tobject->null_pages);
    tobject->null_pages = NULL;
  }
  if (tobject->min_values != NULL)
  {
    g_ptr_array_unref (tobject->min_values);
    tobject->min_values = NULL;
  }
  if (tobject->max_values != NULL)
  {
    g_ptr_array_unref (tobject->max_values);
    tobject->max_values = NULL;
  }
  if (tobject->null_counts != NULL)
  {
    g_array_unref (tobject->null_counts);
    tobject->null_counts = NULL;
  }
  if (tobject->repetition_level_histograms != NULL)
  {
    g_array_unref (tobject->repetition_level_histograms);
    tobject->repetition_level_histograms = NULL;
  }
  if (tobject->definition_level_histograms != NULL)
  {
    g_array_unref (tobject->definition_level_histograms);
    tobject->definition_level_histograms = NULL;
  }
}

static void
column_index_class_init (ColumnIndexClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = column_index_read;
  struct_class->write = column_index_write;

  gobject_class->finalize = column_index_finalize;
  gobject_class->get_property = column_index_get_property;
  gobject_class->set_property = column_index_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_INDEX_NULL_PAGES,
     g_param_spec_boxed ("null_pages",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_INDEX_MIN_VALUES,
     g_param_spec_boxed ("min_values",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_INDEX_MAX_VALUES,
     g_param_spec_boxed ("max_values",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_INDEX_BOUNDARY_ORDER,
     g_param_spec_int ("boundary_order",
                       NULL,
                       NULL,
                       0,
                       2,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_INDEX_NULL_COUNTS,
     g_param_spec_boxed ("null_counts",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_INDEX_REPETITION_LEVEL_HISTOGRAMS,
     g_param_spec_boxed ("repetition_level_histograms",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_COLUMN_INDEX_DEFINITION_LEVEL_HISTOGRAMS,
     g_param_spec_boxed ("definition_level_histograms",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
column_index_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ColumnIndexClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) column_index_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ColumnIndex),
      0, /* n_preallocs */
      (GInstanceInitFunc) column_index_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ColumnIndexType",
                                   &type_info, 0);
  }

  return type;
}

enum _AesGcmV1Properties
{
  PROP_AES_GCM_V1_0,
  PROP_AES_GCM_V1_AAD_PREFIX,
  PROP_AES_GCM_V1_AAD_FILE_UNIQUE,
  PROP_AES_GCM_V1_SUPPLY_AAD_PREFIX
};

/* reads a aes_gcm_v1 object */
static gint32
aes_gcm_v1_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  AesGcmV1 * this_object = AES_GCM_V1(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->aad_prefix != NULL)
          {
            g_free(this_object->aad_prefix);
            this_object->aad_prefix = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->aad_prefix = g_byte_array_new();
          g_byte_array_append (this_object->aad_prefix, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_aad_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->aad_file_unique != NULL)
          {
            g_free(this_object->aad_file_unique);
            this_object->aad_file_unique = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->aad_file_unique = g_byte_array_new();
          g_byte_array_append (this_object->aad_file_unique, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_aad_file_unique = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->supply_aad_prefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_supply_aad_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aes_gcm_v1_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  AesGcmV1 * this_object = AES_GCM_V1(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AesGcmV1", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_aad_prefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "aad_prefix", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->aad_prefix ? ((GByteArray *) this_object->aad_prefix)->data : NULL, this_object->aad_prefix ? ((GByteArray *) this_object->aad_prefix)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_aad_file_unique == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "aad_file_unique", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->aad_file_unique ? ((GByteArray *) this_object->aad_file_unique)->data : NULL, this_object->aad_file_unique ? ((GByteArray *) this_object->aad_file_unique)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_supply_aad_prefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "supply_aad_prefix", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->supply_aad_prefix, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aes_gcm_v1_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  AesGcmV1 *self = AES_GCM_V1 (object);

  switch (property_id)
  {
    case PROP_AES_GCM_V1_AAD_PREFIX:
      if (self->aad_prefix != NULL)
        g_byte_array_unref (self->aad_prefix);
      self->aad_prefix = g_value_dup_boxed (value);
      self->__isset_aad_prefix = TRUE;
      break;

    case PROP_AES_GCM_V1_AAD_FILE_UNIQUE:
      if (self->aad_file_unique != NULL)
        g_byte_array_unref (self->aad_file_unique);
      self->aad_file_unique = g_value_dup_boxed (value);
      self->__isset_aad_file_unique = TRUE;
      break;

    case PROP_AES_GCM_V1_SUPPLY_AAD_PREFIX:
      self->supply_aad_prefix = g_value_get_boolean (value);
      self->__isset_supply_aad_prefix = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aes_gcm_v1_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  AesGcmV1 *self = AES_GCM_V1 (object);

  switch (property_id)
  {
    case PROP_AES_GCM_V1_AAD_PREFIX:
      g_value_set_boxed (value, self->aad_prefix);
      break;

    case PROP_AES_GCM_V1_AAD_FILE_UNIQUE:
      g_value_set_boxed (value, self->aad_file_unique);
      break;

    case PROP_AES_GCM_V1_SUPPLY_AAD_PREFIX:
      g_value_set_boolean (value, self->supply_aad_prefix);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aes_gcm_v1_instance_init (AesGcmV1 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->aad_prefix = NULL;
  object->__isset_aad_prefix = FALSE;
  object->aad_file_unique = NULL;
  object->__isset_aad_file_unique = FALSE;
  object->supply_aad_prefix = 0;
  object->__isset_supply_aad_prefix = FALSE;
}

static void 
aes_gcm_v1_finalize (GObject *object)
{
  AesGcmV1 *tobject = AES_GCM_V1 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->aad_prefix != NULL)
  {
    thrift_string_free(tobject->aad_prefix);
    tobject->aad_prefix = NULL;
  }
  if (tobject->aad_file_unique != NULL)
  {
    thrift_string_free(tobject->aad_file_unique);
    tobject->aad_file_unique = NULL;
  }
}

static void
aes_gcm_v1_class_init (AesGcmV1Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aes_gcm_v1_read;
  struct_class->write = aes_gcm_v1_write;

  gobject_class->finalize = aes_gcm_v1_finalize;
  gobject_class->get_property = aes_gcm_v1_get_property;
  gobject_class->set_property = aes_gcm_v1_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AES_GCM_V1_AAD_PREFIX,
     g_param_spec_boxed ("aad_prefix",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AES_GCM_V1_AAD_FILE_UNIQUE,
     g_param_spec_boxed ("aad_file_unique",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AES_GCM_V1_SUPPLY_AAD_PREFIX,
     g_param_spec_boolean ("supply_aad_prefix",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
aes_gcm_v1_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AesGcmV1Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aes_gcm_v1_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (AesGcmV1),
      0, /* n_preallocs */
      (GInstanceInitFunc) aes_gcm_v1_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AesGcmV1Type",
                                   &type_info, 0);
  }

  return type;
}

enum _AesGcmCtrV1Properties
{
  PROP_AES_GCM_CTR_V1_0,
  PROP_AES_GCM_CTR_V1_AAD_PREFIX,
  PROP_AES_GCM_CTR_V1_AAD_FILE_UNIQUE,
  PROP_AES_GCM_CTR_V1_SUPPLY_AAD_PREFIX
};

/* reads a aes_gcm_ctr_v1 object */
static gint32
aes_gcm_ctr_v1_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  AesGcmCtrV1 * this_object = AES_GCM_CTR_V1(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->aad_prefix != NULL)
          {
            g_free(this_object->aad_prefix);
            this_object->aad_prefix = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->aad_prefix = g_byte_array_new();
          g_byte_array_append (this_object->aad_prefix, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_aad_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->aad_file_unique != NULL)
          {
            g_free(this_object->aad_file_unique);
            this_object->aad_file_unique = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->aad_file_unique = g_byte_array_new();
          g_byte_array_append (this_object->aad_file_unique, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_aad_file_unique = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->supply_aad_prefix, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_supply_aad_prefix = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
aes_gcm_ctr_v1_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  AesGcmCtrV1 * this_object = AES_GCM_CTR_V1(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "AesGcmCtrV1", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_aad_prefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "aad_prefix", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->aad_prefix ? ((GByteArray *) this_object->aad_prefix)->data : NULL, this_object->aad_prefix ? ((GByteArray *) this_object->aad_prefix)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_aad_file_unique == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "aad_file_unique", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->aad_file_unique ? ((GByteArray *) this_object->aad_file_unique)->data : NULL, this_object->aad_file_unique ? ((GByteArray *) this_object->aad_file_unique)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_supply_aad_prefix == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "supply_aad_prefix", T_BOOL, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->supply_aad_prefix, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
aes_gcm_ctr_v1_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  AesGcmCtrV1 *self = AES_GCM_CTR_V1 (object);

  switch (property_id)
  {
    case PROP_AES_GCM_CTR_V1_AAD_PREFIX:
      if (self->aad_prefix != NULL)
        g_byte_array_unref (self->aad_prefix);
      self->aad_prefix = g_value_dup_boxed (value);
      self->__isset_aad_prefix = TRUE;
      break;

    case PROP_AES_GCM_CTR_V1_AAD_FILE_UNIQUE:
      if (self->aad_file_unique != NULL)
        g_byte_array_unref (self->aad_file_unique);
      self->aad_file_unique = g_value_dup_boxed (value);
      self->__isset_aad_file_unique = TRUE;
      break;

    case PROP_AES_GCM_CTR_V1_SUPPLY_AAD_PREFIX:
      self->supply_aad_prefix = g_value_get_boolean (value);
      self->__isset_supply_aad_prefix = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
aes_gcm_ctr_v1_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  AesGcmCtrV1 *self = AES_GCM_CTR_V1 (object);

  switch (property_id)
  {
    case PROP_AES_GCM_CTR_V1_AAD_PREFIX:
      g_value_set_boxed (value, self->aad_prefix);
      break;

    case PROP_AES_GCM_CTR_V1_AAD_FILE_UNIQUE:
      g_value_set_boxed (value, self->aad_file_unique);
      break;

    case PROP_AES_GCM_CTR_V1_SUPPLY_AAD_PREFIX:
      g_value_set_boolean (value, self->supply_aad_prefix);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
aes_gcm_ctr_v1_instance_init (AesGcmCtrV1 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->aad_prefix = NULL;
  object->__isset_aad_prefix = FALSE;
  object->aad_file_unique = NULL;
  object->__isset_aad_file_unique = FALSE;
  object->supply_aad_prefix = 0;
  object->__isset_supply_aad_prefix = FALSE;
}

static void 
aes_gcm_ctr_v1_finalize (GObject *object)
{
  AesGcmCtrV1 *tobject = AES_GCM_CTR_V1 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->aad_prefix != NULL)
  {
    thrift_string_free(tobject->aad_prefix);
    tobject->aad_prefix = NULL;
  }
  if (tobject->aad_file_unique != NULL)
  {
    thrift_string_free(tobject->aad_file_unique);
    tobject->aad_file_unique = NULL;
  }
}

static void
aes_gcm_ctr_v1_class_init (AesGcmCtrV1Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = aes_gcm_ctr_v1_read;
  struct_class->write = aes_gcm_ctr_v1_write;

  gobject_class->finalize = aes_gcm_ctr_v1_finalize;
  gobject_class->get_property = aes_gcm_ctr_v1_get_property;
  gobject_class->set_property = aes_gcm_ctr_v1_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_AES_GCM_CTR_V1_AAD_PREFIX,
     g_param_spec_boxed ("aad_prefix",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AES_GCM_CTR_V1_AAD_FILE_UNIQUE,
     g_param_spec_boxed ("aad_file_unique",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_AES_GCM_CTR_V1_SUPPLY_AAD_PREFIX,
     g_param_spec_boolean ("supply_aad_prefix",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
aes_gcm_ctr_v1_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (AesGcmCtrV1Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) aes_gcm_ctr_v1_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (AesGcmCtrV1),
      0, /* n_preallocs */
      (GInstanceInitFunc) aes_gcm_ctr_v1_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "AesGcmCtrV1Type",
                                   &type_info, 0);
  }

  return type;
}

enum _EncryptionAlgorithmProperties
{
  PROP_ENCRYPTION_ALGORITHM_0,
  PROP_ENCRYPTION_ALGORITHM_A_E_S__G_C_M__V1,
  PROP_ENCRYPTION_ALGORITHM_A_E_S__G_C_M__C_T_R__V1
};

/* reads a encryption_algorithm object */
static gint32
encryption_algorithm_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  EncryptionAlgorithm * this_object = ENCRYPTION_ALGORITHM(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->AES_GCM_V1), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_AES_GCM_V1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->AES_GCM_CTR_V1), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_AES_GCM_CTR_V1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
encryption_algorithm_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  EncryptionAlgorithm * this_object = ENCRYPTION_ALGORITHM(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "EncryptionAlgorithm", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_AES_GCM_V1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "AES_GCM_V1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->AES_GCM_V1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_AES_GCM_CTR_V1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "AES_GCM_CTR_V1", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->AES_GCM_CTR_V1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
encryption_algorithm_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  EncryptionAlgorithm *self = ENCRYPTION_ALGORITHM (object);

  switch (property_id)
  {
    case PROP_ENCRYPTION_ALGORITHM_A_E_S__G_C_M__V1:
      if (self->AES_GCM_V1 != NULL)
        g_object_unref (self->AES_GCM_V1);
      self->AES_GCM_V1 = g_value_dup_object (value);
      self->__isset_AES_GCM_V1 = TRUE;
      break;

    case PROP_ENCRYPTION_ALGORITHM_A_E_S__G_C_M__C_T_R__V1:
      if (self->AES_GCM_CTR_V1 != NULL)
        g_object_unref (self->AES_GCM_CTR_V1);
      self->AES_GCM_CTR_V1 = g_value_dup_object (value);
      self->__isset_AES_GCM_CTR_V1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
encryption_algorithm_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  EncryptionAlgorithm *self = ENCRYPTION_ALGORITHM (object);

  switch (property_id)
  {
    case PROP_ENCRYPTION_ALGORITHM_A_E_S__G_C_M__V1:
      g_value_set_object (value, self->AES_GCM_V1);
      break;

    case PROP_ENCRYPTION_ALGORITHM_A_E_S__G_C_M__C_T_R__V1:
      g_value_set_object (value, self->AES_GCM_CTR_V1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
encryption_algorithm_instance_init (EncryptionAlgorithm * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->AES_GCM_V1 = g_object_new (TYPE_AES_GCM_V1, NULL);
  object->__isset_AES_GCM_V1 = FALSE;
  object->AES_GCM_CTR_V1 = g_object_new (TYPE_AES_GCM_CTR_V1, NULL);
  object->__isset_AES_GCM_CTR_V1 = FALSE;
}

static void 
encryption_algorithm_finalize (GObject *object)
{
  EncryptionAlgorithm *tobject = ENCRYPTION_ALGORITHM (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->AES_GCM_V1 != NULL)
  {
    g_object_unref(tobject->AES_GCM_V1);
    tobject->AES_GCM_V1 = NULL;
  }
  if (tobject->AES_GCM_CTR_V1 != NULL)
  {
    g_object_unref(tobject->AES_GCM_CTR_V1);
    tobject->AES_GCM_CTR_V1 = NULL;
  }
}

static void
encryption_algorithm_class_init (EncryptionAlgorithmClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = encryption_algorithm_read;
  struct_class->write = encryption_algorithm_write;

  gobject_class->finalize = encryption_algorithm_finalize;
  gobject_class->get_property = encryption_algorithm_get_property;
  gobject_class->set_property = encryption_algorithm_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_ENCRYPTION_ALGORITHM_A_E_S__G_C_M__V1,
     g_param_spec_object ("AES_GCM_V1",
                         NULL,
                         NULL,
                         TYPE_AES_GCM_V1,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_ENCRYPTION_ALGORITHM_A_E_S__G_C_M__C_T_R__V1,
     g_param_spec_object ("AES_GCM_CTR_V1",
                         NULL,
                         NULL,
                         TYPE_AES_GCM_CTR_V1,
                         G_PARAM_READWRITE));
}

GType
encryption_algorithm_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (EncryptionAlgorithmClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) encryption_algorithm_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (EncryptionAlgorithm),
      0, /* n_preallocs */
      (GInstanceInitFunc) encryption_algorithm_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "EncryptionAlgorithmType",
                                   &type_info, 0);
  }

  return type;
}

enum _FileMetaDataProperties
{
  PROP_FILE_META_DATA_0,
  PROP_FILE_META_DATA_VERSION,
  PROP_FILE_META_DATA_SCHEMA,
  PROP_FILE_META_DATA_NUM_ROWS,
  PROP_FILE_META_DATA_ROW_GROUPS,
  PROP_FILE_META_DATA_KEY_VALUE_METADATA,
  PROP_FILE_META_DATA_CREATED_BY,
  PROP_FILE_META_DATA_COLUMN_ORDERS,
  PROP_FILE_META_DATA_ENCRYPTION_ALGORITHM,
  PROP_FILE_META_DATA_FOOTER_SIGNING_KEY_METADATA
};

/* reads a file_meta_data object */
static gint32
file_meta_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FileMetaData * this_object = FILE_META_DATA(object);
  gboolean isset_version = FALSE;
  gboolean isset_schema = FALSE;
  gboolean isset_num_rows = FALSE;
  gboolean isset_row_groups = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              SchemaElement * _elem52 = NULL;
              if ( _elem52 != NULL)
              {
                g_object_unref (_elem52);
              }
              _elem52 = g_object_new (TYPE_SCHEMA_ELEMENT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem52), protocol, error)) < 0)
              {
                g_object_unref (_elem52);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->schema, _elem52);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->num_rows, error)) < 0)
            return -1;
          xfer += ret;
          isset_num_rows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              RowGroup * _elem53 = NULL;
              if ( _elem53 != NULL)
              {
                g_object_unref (_elem53);
              }
              _elem53 = g_object_new (TYPE_ROW_GROUP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem53), protocol, error)) < 0)
              {
                g_object_unref (_elem53);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->row_groups, _elem53);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          isset_row_groups = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              KeyValue * _elem54 = NULL;
              if ( _elem54 != NULL)
              {
                g_object_unref (_elem54);
              }
              _elem54 = g_object_new (TYPE_KEY_VALUE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem54), protocol, error)) < 0)
              {
                g_object_unref (_elem54);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->key_value_metadata, _elem54);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_key_value_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->created_by != NULL)
          {
            g_free(this_object->created_by);
            this_object->created_by = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->created_by, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_created_by = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              ColumnOrder * _elem55 = NULL;
              if ( _elem55 != NULL)
              {
                g_object_unref (_elem55);
              }
              _elem55 = g_object_new (TYPE_COLUMN_ORDER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem55), protocol, error)) < 0)
              {
                g_object_unref (_elem55);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->column_orders, _elem55);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_column_orders = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->encryption_algorithm), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_encryption_algorithm = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->footer_signing_key_metadata != NULL)
          {
            g_free(this_object->footer_signing_key_metadata);
            this_object->footer_signing_key_metadata = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->footer_signing_key_metadata = g_byte_array_new();
          g_byte_array_append (this_object->footer_signing_key_metadata, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_footer_signing_key_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_version)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_schema)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_num_rows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_row_groups)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
file_meta_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FileMetaData * this_object = FILE_META_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FileMetaData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->version, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i56;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->schema ? this_object->schema->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i56 = 0; i56 < (this_object->schema ? this_object->schema->len : 0); i56++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->schema, i56))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "num_rows", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->num_rows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "row_groups", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i57;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->row_groups ? this_object->row_groups->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i57 = 0; i57 < (this_object->row_groups ? this_object->row_groups->len : 0); i57++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->row_groups, i57))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_key_value_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_value_metadata", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i58;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->key_value_metadata ? this_object->key_value_metadata->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i58 = 0; i58 < (this_object->key_value_metadata ? this_object->key_value_metadata->len : 0); i58++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->key_value_metadata, i58))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_created_by == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "created_by", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->created_by, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_column_orders == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "column_orders", T_LIST, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i59;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->column_orders ? this_object->column_orders->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i59 = 0; i59 < (this_object->column_orders ? this_object->column_orders->len : 0); i59++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->column_orders, i59))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_encryption_algorithm == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encryption_algorithm", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->encryption_algorithm), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_footer_signing_key_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "footer_signing_key_metadata", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->footer_signing_key_metadata ? ((GByteArray *) this_object->footer_signing_key_metadata)->data : NULL, this_object->footer_signing_key_metadata ? ((GByteArray *) this_object->footer_signing_key_metadata)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
file_meta_data_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  FileMetaData *self = FILE_META_DATA (object);

  switch (property_id)
  {
    case PROP_FILE_META_DATA_VERSION:
      self->version = g_value_get_int (value);
      break;

    case PROP_FILE_META_DATA_SCHEMA:
      if (self->schema != NULL)
        g_ptr_array_unref (self->schema);
      self->schema = g_value_dup_boxed (value);
      break;

    case PROP_FILE_META_DATA_NUM_ROWS:
      self->num_rows = g_value_get_int64 (value);
      break;

    case PROP_FILE_META_DATA_ROW_GROUPS:
      if (self->row_groups != NULL)
        g_ptr_array_unref (self->row_groups);
      self->row_groups = g_value_dup_boxed (value);
      break;

    case PROP_FILE_META_DATA_KEY_VALUE_METADATA:
      if (self->key_value_metadata != NULL)
        g_ptr_array_unref (self->key_value_metadata);
      self->key_value_metadata = g_value_dup_boxed (value);
      self->__isset_key_value_metadata = TRUE;
      break;

    case PROP_FILE_META_DATA_CREATED_BY:
      if (self->created_by != NULL)
        g_free (self->created_by);
      self->created_by = g_value_dup_string (value);
      self->__isset_created_by = TRUE;
      break;

    case PROP_FILE_META_DATA_COLUMN_ORDERS:
      if (self->column_orders != NULL)
        g_ptr_array_unref (self->column_orders);
      self->column_orders = g_value_dup_boxed (value);
      self->__isset_column_orders = TRUE;
      break;

    case PROP_FILE_META_DATA_ENCRYPTION_ALGORITHM:
      if (self->encryption_algorithm != NULL)
        g_object_unref (self->encryption_algorithm);
      self->encryption_algorithm = g_value_dup_object (value);
      self->__isset_encryption_algorithm = TRUE;
      break;

    case PROP_FILE_META_DATA_FOOTER_SIGNING_KEY_METADATA:
      if (self->footer_signing_key_metadata != NULL)
        g_byte_array_unref (self->footer_signing_key_metadata);
      self->footer_signing_key_metadata = g_value_dup_boxed (value);
      self->__isset_footer_signing_key_metadata = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
file_meta_data_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  FileMetaData *self = FILE_META_DATA (object);

  switch (property_id)
  {
    case PROP_FILE_META_DATA_VERSION:
      g_value_set_int (value, self->version);
      break;

    case PROP_FILE_META_DATA_SCHEMA:
      g_value_set_boxed (value, self->schema);
      break;

    case PROP_FILE_META_DATA_NUM_ROWS:
      g_value_set_int64 (value, self->num_rows);
      break;

    case PROP_FILE_META_DATA_ROW_GROUPS:
      g_value_set_boxed (value, self->row_groups);
      break;

    case PROP_FILE_META_DATA_KEY_VALUE_METADATA:
      g_value_set_boxed (value, self->key_value_metadata);
      break;

    case PROP_FILE_META_DATA_CREATED_BY:
      g_value_set_string (value, self->created_by);
      break;

    case PROP_FILE_META_DATA_COLUMN_ORDERS:
      g_value_set_boxed (value, self->column_orders);
      break;

    case PROP_FILE_META_DATA_ENCRYPTION_ALGORITHM:
      g_value_set_object (value, self->encryption_algorithm);
      break;

    case PROP_FILE_META_DATA_FOOTER_SIGNING_KEY_METADATA:
      g_value_set_boxed (value, self->footer_signing_key_metadata);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
file_meta_data_instance_init (FileMetaData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->version = 0;
  object->schema = g_ptr_array_new_with_free_func (g_object_unref);
  object->num_rows = 0;
  object->row_groups = g_ptr_array_new_with_free_func (g_object_unref);
  object->key_value_metadata = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_key_value_metadata = FALSE;
  object->created_by = NULL;
  object->__isset_created_by = FALSE;
  object->column_orders = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_column_orders = FALSE;
  object->encryption_algorithm = g_object_new (TYPE_ENCRYPTION_ALGORITHM, NULL);
  object->__isset_encryption_algorithm = FALSE;
  object->footer_signing_key_metadata = NULL;
  object->__isset_footer_signing_key_metadata = FALSE;
}

static void 
file_meta_data_finalize (GObject *object)
{
  FileMetaData *tobject = FILE_META_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema != NULL)
  {
    g_ptr_array_unref (tobject->schema);
    tobject->schema = NULL;
  }
  if (tobject->row_groups != NULL)
  {
    g_ptr_array_unref (tobject->row_groups);
    tobject->row_groups = NULL;
  }
  if (tobject->key_value_metadata != NULL)
  {
    g_ptr_array_unref (tobject->key_value_metadata);
    tobject->key_value_metadata = NULL;
  }
  if (tobject->created_by != NULL)
  {
    g_free(tobject->created_by);
    tobject->created_by = NULL;
  }
  if (tobject->column_orders != NULL)
  {
    g_ptr_array_unref (tobject->column_orders);
    tobject->column_orders = NULL;
  }
  if (tobject->encryption_algorithm != NULL)
  {
    g_object_unref(tobject->encryption_algorithm);
    tobject->encryption_algorithm = NULL;
  }
  if (tobject->footer_signing_key_metadata != NULL)
  {
    thrift_string_free(tobject->footer_signing_key_metadata);
    tobject->footer_signing_key_metadata = NULL;
  }
}

static void
file_meta_data_class_init (FileMetaDataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = file_meta_data_read;
  struct_class->write = file_meta_data_write;

  gobject_class->finalize = file_meta_data_finalize;
  gobject_class->get_property = file_meta_data_get_property;
  gobject_class->set_property = file_meta_data_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_META_DATA_VERSION,
     g_param_spec_int ("version",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_META_DATA_SCHEMA,
     g_param_spec_boxed ("schema",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_META_DATA_NUM_ROWS,
     g_param_spec_int64 ("num_rows",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_META_DATA_ROW_GROUPS,
     g_param_spec_boxed ("row_groups",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_META_DATA_KEY_VALUE_METADATA,
     g_param_spec_boxed ("key_value_metadata",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_META_DATA_CREATED_BY,
     g_param_spec_string ("created_by",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_META_DATA_COLUMN_ORDERS,
     g_param_spec_boxed ("column_orders",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_META_DATA_ENCRYPTION_ALGORITHM,
     g_param_spec_object ("encryption_algorithm",
                         NULL,
                         NULL,
                         TYPE_ENCRYPTION_ALGORITHM,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_META_DATA_FOOTER_SIGNING_KEY_METADATA,
     g_param_spec_boxed ("footer_signing_key_metadata",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
file_meta_data_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (FileMetaDataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) file_meta_data_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (FileMetaData),
      0, /* n_preallocs */
      (GInstanceInitFunc) file_meta_data_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "FileMetaDataType",
                                   &type_info, 0);
  }

  return type;
}

enum _FileCryptoMetaDataProperties
{
  PROP_FILE_CRYPTO_META_DATA_0,
  PROP_FILE_CRYPTO_META_DATA_ENCRYPTION_ALGORITHM,
  PROP_FILE_CRYPTO_META_DATA_KEY_METADATA
};

/* reads a file_crypto_meta_data object */
static gint32
file_crypto_meta_data_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FileCryptoMetaData * this_object = FILE_CRYPTO_META_DATA(object);
  gboolean isset_encryption_algorithm = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->encryption_algorithm), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          isset_encryption_algorithm = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->key_metadata != NULL)
          {
            g_free(this_object->key_metadata);
            this_object->key_metadata = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->key_metadata = g_byte_array_new();
          g_byte_array_append (this_object->key_metadata, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_key_metadata = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_encryption_algorithm)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
file_crypto_meta_data_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FileCryptoMetaData * this_object = FILE_CRYPTO_META_DATA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FileCryptoMetaData", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "encryption_algorithm", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->encryption_algorithm), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_key_metadata == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "key_metadata", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->key_metadata ? ((GByteArray *) this_object->key_metadata)->data : NULL, this_object->key_metadata ? ((GByteArray *) this_object->key_metadata)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
file_crypto_meta_data_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  FileCryptoMetaData *self = FILE_CRYPTO_META_DATA (object);

  switch (property_id)
  {
    case PROP_FILE_CRYPTO_META_DATA_ENCRYPTION_ALGORITHM:
      if (self->encryption_algorithm != NULL)
        g_object_unref (self->encryption_algorithm);
      self->encryption_algorithm = g_value_dup_object (value);
      break;

    case PROP_FILE_CRYPTO_META_DATA_KEY_METADATA:
      if (self->key_metadata != NULL)
        g_byte_array_unref (self->key_metadata);
      self->key_metadata = g_value_dup_boxed (value);
      self->__isset_key_metadata = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
file_crypto_meta_data_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  FileCryptoMetaData *self = FILE_CRYPTO_META_DATA (object);

  switch (property_id)
  {
    case PROP_FILE_CRYPTO_META_DATA_ENCRYPTION_ALGORITHM:
      g_value_set_object (value, self->encryption_algorithm);
      break;

    case PROP_FILE_CRYPTO_META_DATA_KEY_METADATA:
      g_value_set_boxed (value, self->key_metadata);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
file_crypto_meta_data_instance_init (FileCryptoMetaData * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->encryption_algorithm = g_object_new (TYPE_ENCRYPTION_ALGORITHM, NULL);
  object->key_metadata = NULL;
  object->__isset_key_metadata = FALSE;
}

static void 
file_crypto_meta_data_finalize (GObject *object)
{
  FileCryptoMetaData *tobject = FILE_CRYPTO_META_DATA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->encryption_algorithm != NULL)
  {
    g_object_unref(tobject->encryption_algorithm);
    tobject->encryption_algorithm = NULL;
  }
  if (tobject->key_metadata != NULL)
  {
    thrift_string_free(tobject->key_metadata);
    tobject->key_metadata = NULL;
  }
}

static void
file_crypto_meta_data_class_init (FileCryptoMetaDataClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = file_crypto_meta_data_read;
  struct_class->write = file_crypto_meta_data_write;

  gobject_class->finalize = file_crypto_meta_data_finalize;
  gobject_class->get_property = file_crypto_meta_data_get_property;
  gobject_class->set_property = file_crypto_meta_data_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_CRYPTO_META_DATA_ENCRYPTION_ALGORITHM,
     g_param_spec_object ("encryption_algorithm",
                         NULL,
                         NULL,
                         TYPE_ENCRYPTION_ALGORITHM,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FILE_CRYPTO_META_DATA_KEY_METADATA,
     g_param_spec_boxed ("key_metadata",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
file_crypto_meta_data_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (FileCryptoMetaDataClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) file_crypto_meta_data_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (FileCryptoMetaData),
      0, /* n_preallocs */
      (GInstanceInitFunc) file_crypto_meta_data_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "FileCryptoMetaDataType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

