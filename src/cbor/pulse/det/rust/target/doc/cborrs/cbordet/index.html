<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module is an implementation of Deterministically Encoded CBOR (RFC 8949 Section 4.2.1) minus floating-point values, fully formally verified for functional correctness and absence of panics related to breach of abstraction, buffer overruns or arithmetic overflow/underflow. This module never allocates into the heap."><title>cborrs::cbordet - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="cborrs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.0 (4d91de4e4 2025-02-17)" data-channel="1.85.0" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../cborrs/index.html">cborrs</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module cbordet</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate cborrs</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">cborrs</a></span><h1>Module <span>cbordet</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/cborrs/cbordet.rs.html#6-449">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module is an implementation of Deterministically Encoded CBOR
(RFC 8949 Section 4.2.1) minus floating-point values, fully
formally verified for functional correctness and absence of panics
related to breach of abstraction, buffer overruns or arithmetic
overflow/underflow. This module never allocates into the heap.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CborDetArray.html" title="struct cborrs::cbordet::CborDetArray">Cbor<wbr>DetArray</a></div><div class="desc docblock-short">The read-only type of Deterministic CBOR arrays. Values of this
type cannot be manually constructed by the user, they are meant to
be obtained only via <code>cbor_det_destruct</code> below. The abstraction is
justified by the use of a refinement type, as per the definition
of <code>cbor_det_array</code> in <code>pulse/CBOR.Pulse.Det.API.Rust.fst</code></div></li><li><div class="item-name"><a class="struct" href="struct.CborDetArrayIterator.html" title="struct cborrs::cbordet::CborDetArrayIterator">Cbor<wbr>DetArray<wbr>Iterator</a></div><div class="desc docblock-short">The type of iterators over Deterministic CBOR arrays. It is made
abstract since it is meant to be used with an implementation of
the <code>Iterator</code> trait only.</div></li><li><div class="item-name"><a class="struct" href="struct.CborDetMap.html" title="struct cborrs::cbordet::CborDetMap">Cbor<wbr>DetMap</a></div><div class="desc docblock-short">The read-only type of Deterministic CBOR maps. Values of this
type cannot be manually constructed by the user, they are meant to
be obtained only via <code>cbor_det_destruct</code> below. The abstraction is
justified by the use of a refinement type, as per the definition
of <code>cbor_det_map</code> in <code>pulse/CBOR.Pulse.Det.API.Rust.fst</code></div></li><li><div class="item-name"><a class="struct" href="struct.CborDetMapIterator.html" title="struct cborrs::cbordet::CborDetMapIterator">Cbor<wbr>DetMap<wbr>Iterator</a></div><div class="desc docblock-short">The type of iterators over Deterministic CBOR maps. It is made
abstract since it is meant to be used with an implementation of
the <code>Iterator</code> trait only.</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.CborDetIntKind.html" title="enum cborrs::cbordet::CborDetIntKind">Cbor<wbr>DetInt<wbr>Kind</a></div><div class="desc docblock-short">The kind of 64-bit integer: unsigned (to represent non-negative
values), or negative (to represent negative values in two’s
complement.)</div></li><li><div class="item-name"><a class="enum" href="enum.CborDetView.html" title="enum cborrs::cbordet::CborDetView">Cbor<wbr>DetView</a></div><div class="desc docblock-short">A read-only view of a Deterministic CBOR object, as obtained by
peeling the first layer of nesting via <code>cbor_det_destruct</code> below.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.cbor_det_destruct.html" title="fn cborrs::cbordet::cbor_det_destruct">cbor_<wbr>det_<wbr>destruct</a></div><div class="desc docblock-short">Destructs a Deterministic CBOR object by peeling its first layer
of nesting. This function does not recursively descend into array
or map payloads, and only reads the header of a tagged payload. As
such, it consumes constant stack space. This function respects the
UTF-8 well-formedness invariants.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_equal.html" title="fn cborrs::cbordet::cbor_det_equal">cbor_<wbr>det_<wbr>equal</a></div><div class="desc docblock-short">Compares Deterministic CBOR objects for semantic equality. This
function consumes stack space linear in the maximum nesting of its
two arguments.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_get_array_item.html" title="fn cborrs::cbordet::cbor_det_get_array_item">cbor_<wbr>det_<wbr>get_<wbr>array_<wbr>item</a></div><div class="desc docblock-short">Returns the <code>i</code>th element of the CBOR array <code>x</code>. Returns <code>None</code> if
<code>i</code> is equal to or larger than the number of array elements,
<code>Some(object)</code> otherwise.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_get_array_length.html" title="fn cborrs::cbordet::cbor_det_get_array_length">cbor_<wbr>det_<wbr>get_<wbr>array_<wbr>length</a></div><div class="desc docblock-short">Returns the number of elements in a Deterministic CBOR array.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_get_map_length.html" title="fn cborrs::cbordet::cbor_det_get_map_length">cbor_<wbr>det_<wbr>get_<wbr>map_<wbr>length</a></div><div class="desc docblock-short">Returns the number of elements in a Deterministic CBOR map.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_map_entry_key.html" title="fn cborrs::cbordet::cbor_det_map_entry_key">cbor_<wbr>det_<wbr>map_<wbr>entry_<wbr>key</a></div><div class="desc docblock-short">Read the key of a map entry.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_map_entry_value.html" title="fn cborrs::cbordet::cbor_det_map_entry_value">cbor_<wbr>det_<wbr>map_<wbr>entry_<wbr>value</a></div><div class="desc docblock-short">Read the value of a map entry.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_map_get.html" title="fn cborrs::cbordet::cbor_det_map_get">cbor_<wbr>det_<wbr>map_<wbr>get</a></div><div class="desc docblock-short">Looks up a map <code>x</code> for an entry associated to the key <code>k</code>. If such
an entry exists, returns <code>Some(object)</code> where <code>object</code> is the
value associated to that key. Otherwise, returns <code>None</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_mk_array.html" title="fn cborrs::cbordet::cbor_det_mk_array">cbor_<wbr>det_<wbr>mk_<wbr>array</a></div><div class="desc docblock-short">Constructs a Deterministic CBOR of “array” type. This function
does not copy its input array. It returns <code>None</code> if the input
array has more than $2^64 - 1$ elements, <code>Some(object)</code> otherwise.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_mk_byte_string.html" title="fn cborrs::cbordet::cbor_det_mk_byte_string">cbor_<wbr>det_<wbr>mk_<wbr>byte_<wbr>string</a></div><div class="desc docblock-short">Constructs a Deterministic CBOR object of “byte string” type, with
the contents of <code>s</code> as value. This function does not perform any
copy of its input <code>s</code>. It returns <code>None</code> if the byte size of <code>s</code>
is larger than $2^64 - 1$, <code>Some(object)</code> otherwise.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_mk_int64.html" title="fn cborrs::cbordet::cbor_det_mk_int64">cbor_<wbr>det_<wbr>mk_<wbr>int64</a></div><div class="desc docblock-short">Constructs a Deterministic CBOR object of “integer” type, with
kind <code>ty</code> and value <code>v</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_mk_map.html" title="fn cborrs::cbordet::cbor_det_mk_map">cbor_<wbr>det_<wbr>mk_<wbr>map</a></div><div class="desc docblock-short">Constructs a map from a slice of map entries. This function does
not copy its input array. If the input slice has more than $2^64 -
1$ entries, then this function returns <code>None</code> and does not change
the input slice. Otherwise, this function tries to sort the input
slice in-place with respect to the key order specified in Section
4.2.1 of RFC 8949 (without actually serializing the map entries.)
If the sorting detects duplicate keys, then this function returns
<code>None</code>. Otherwise, it returns <code>Some(object)</code>. Due to the sorting,
this function consumes stack space logarithmic in the size of the
input slice, and linear in the maximum nesting of map entry keys,
and the function may have changed the order of map entries in the
input slice.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_mk_map_entry.html" title="fn cborrs::cbordet::cbor_det_mk_map_entry">cbor_<wbr>det_<wbr>mk_<wbr>map_<wbr>entry</a></div><div class="desc docblock-short">Constructs a map entry from a key <code>xk</code> and a value <code>xv</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_mk_simple_value.html" title="fn cborrs::cbordet::cbor_det_mk_simple_value">cbor_<wbr>det_<wbr>mk_<wbr>simple_<wbr>value</a></div><div class="desc docblock-short">Constructs a Deterministic CBOR object of “simple value” type,
with value <code>v</code>. Returns <code>None</code> if the value <code>v</code> lies in the
reserved range (<code>24..31</code>), as specified by Table 4 of RFC 8949
Section 3.3; <code>Some(object)</code> otherwise.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_mk_tagged.html" title="fn cborrs::cbordet::cbor_det_mk_tagged">cbor_<wbr>det_<wbr>mk_<wbr>tagged</a></div><div class="desc docblock-short">Constructs a Deterministic CBOR object of Tagged type, with tag
<code>tag</code>, and the contents of <code>r</code> as value. This function does not
perform any copy of its input <code>r</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_mk_text_string.html" title="fn cborrs::cbordet::cbor_det_mk_text_string">cbor_<wbr>det_<wbr>mk_<wbr>text_<wbr>string</a></div><div class="desc docblock-short">Constructs a Deterministic CBOR object of “text string” type, with
the contents of <code>s</code> as value. This function does not perform any
copy of its input <code>s</code>. It returns <code>None</code> if the byte size of <code>s</code>
is larger than $2^64 - 1$, <code>Some(object)</code> otherwise. This function
respects the UTF-8 well-formedness invariants.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_parse.html" title="fn cborrs::cbordet::cbor_det_parse">cbor_<wbr>det_<wbr>parse</a></div><div class="desc docblock-short">Tries to parse a Deterministic CBOR object from the first bytes of
<code>input</code>, following RFC 8949 Section 4.2.1, minus floating-point
values. Returns <code>None</code> in case of failure, or <code>Some(object, rem)</code>
in case of success, where <code>rem</code> is the remainder of the input
slice past those first bytes of <code>input</code> that contain the valid
binary representation of
<code>input</code>. This function does not perform a deep parse of <code>input</code>,
it only copies the object type, tag and/or size of the top-most
object. As such, it uses constant stack space (including data
validation.) “Destructor” functions are to be used on the returned
object, to examine each level of nesting one at a time. NOTE: This
implementation checks for the basic validity constraints of
Section 5.3.1, i.e. the absence of duplicate map keys (which is a
consequence of the deterministic encoding.), and the
well-formedness of UTF-8 text strings.</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_serialize.html" title="fn cborrs::cbordet::cbor_det_serialize">cbor_<wbr>det_<wbr>serialize</a></div><div class="desc docblock-short">Writes the binary representation of the Deterministic CBOR object
<code>x</code> into the first bytes of the <code>output</code> byte slice, following RFC
8949 Section 4.2.1. This function first checks the size of <code>x</code> and
returns <code>None</code> if it is larger than the size of <code>output</code>;
otherwise it returns <code>Some(size)</code>, where <code>size</code> is the byte size
of <code>x</code>, the number of bytes written to <code>output</code>. This function
uses stack space in the order of the level of nesting of the use
of “constructor” functions used to build <code>x</code>; the serialization of
those “subobjects” of <code>x</code> obtained from <code>cbor_det_parse</code> uses only
constant extra stack space for each such subobject (in the sense
that the serialization does not recursively nest into such
subobjects.)</div></li><li><div class="item-name"><a class="fn" href="fn.cbor_det_size.html" title="fn cborrs::cbordet::cbor_det_size">cbor_<wbr>det_<wbr>size</a></div><div class="desc docblock-short">Computes the byte size of the binary representation of the
Deterministic CBOR object <code>x</code> following RFC 8949 Section 4.2.1,
but without serializing <code>x</code>. Returns <code>None</code> if that size is
strictly larger than <code>bound</code>; <code>Some(size)</code> otherwise. This function
uses stack space in the order of the level of nesting of the use
of “constructor” functions used to build <code>x</code>; the computation of
the sizes of those “subobjects” of <code>x</code> obtained from
<code>cbor_det_parse</code> uses only constant extra stack space for each
such subobject (in the sense that the computation does not
recursively nest into such subobjects.)</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.CborDet.html" title="type cborrs::cbordet::CborDet">CborDet</a></div><div class="desc docblock-short">An abstract type to represent a Deterministic CBOR object, which
can be obtained either using “constructor” functions of this
module, or by parsing from serialized data. Declared in
<code>pulse/CBOR.Pulse.Det.API.Rust.fsti</code>. Its corresponding pure
(“mathematical”) functional specification is the <code>cbor</code> type in
<code>spec/CBOR.Spec.Type.fsti</code>.</div></li><li><div class="item-name"><a class="type" href="type.CborDetMapEntry.html" title="type cborrs::cbordet::CborDetMapEntry">Cbor<wbr>DetMap<wbr>Entry</a></div><div class="desc docblock-short">The type of key-value map entries.</div></li></ul></section></div></main></body></html>