<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This module is an implementation of Deterministically Encoded CBOR (RFC 8949 Section 4.2.1) minus floating-point values, fully formally verified for functional correctness and absence of panics related to breach of abstraction, buffer overruns or arithmetic overflow/underflow. This module never allocates into the heap."><title>cborrs::cbordet - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="cborrs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../cborrs/index.html">cborrs</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module cbordet</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate cborrs</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">cborrs</a></div><h1>Module <span>cbordet</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/cborrs/cbordet.rs.html#6-449">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This module is an implementation of Deterministically Encoded CBOR
(RFC 8949 Section 4.2.1) minus floating-point values, fully
formally verified for functional correctness and absence of panics
related to breach of abstraction, buffer overruns or arithmetic
overflow/underflow. This module never allocates into the heap.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.CborDetArray.html" title="struct cborrs::cbordet::CborDetArray">Cbor<wbr>DetArray</a></dt><dd>The read-only type of Deterministic CBOR arrays. Values of this
type cannot be manually constructed by the user, they are meant to
be obtained only via <code>cbor_det_destruct</code> below. The abstraction is
justified by the use of a refinement type, as per the definition
of <code>cbor_det_array</code> in <code>pulse/CBOR.Pulse.Det.API.Rust.fst</code></dd><dt><a class="struct" href="struct.CborDetArrayIterator.html" title="struct cborrs::cbordet::CborDetArrayIterator">Cbor<wbr>DetArray<wbr>Iterator</a></dt><dd>The type of iterators over Deterministic CBOR arrays. It is made
abstract since it is meant to be used with an implementation of
the <code>Iterator</code> trait only.</dd><dt><a class="struct" href="struct.CborDetMap.html" title="struct cborrs::cbordet::CborDetMap">Cbor<wbr>DetMap</a></dt><dd>The read-only type of Deterministic CBOR maps. Values of this
type cannot be manually constructed by the user, they are meant to
be obtained only via <code>cbor_det_destruct</code> below. The abstraction is
justified by the use of a refinement type, as per the definition
of <code>cbor_det_map</code> in <code>pulse/CBOR.Pulse.Det.API.Rust.fst</code></dd><dt><a class="struct" href="struct.CborDetMapIterator.html" title="struct cborrs::cbordet::CborDetMapIterator">Cbor<wbr>DetMap<wbr>Iterator</a></dt><dd>The type of iterators over Deterministic CBOR maps. It is made
abstract since it is meant to be used with an implementation of
the <code>Iterator</code> trait only.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.CborDetIntKind.html" title="enum cborrs::cbordet::CborDetIntKind">Cbor<wbr>DetInt<wbr>Kind</a></dt><dd>The kind of 64-bit integer: unsigned (to represent non-negative
values), or negative (to represent negative values in two’s
complement.)</dd><dt><a class="enum" href="enum.CborDetView.html" title="enum cborrs::cbordet::CborDetView">Cbor<wbr>DetView</a></dt><dd>A read-only view of a Deterministic CBOR object, as obtained by
peeling the first layer of nesting via <code>cbor_det_destruct</code> below.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.cbor_det_destruct.html" title="fn cborrs::cbordet::cbor_det_destruct">cbor_<wbr>det_<wbr>destruct</a></dt><dd>Destructs a Deterministic CBOR object by peeling its first layer
of nesting. This function does not recursively descend into array
or map payloads, and only reads the header of a tagged payload. As
such, it consumes constant stack space. This function respects the
UTF-8 well-formedness invariants.</dd><dt><a class="fn" href="fn.cbor_det_equal.html" title="fn cborrs::cbordet::cbor_det_equal">cbor_<wbr>det_<wbr>equal</a></dt><dd>Compares Deterministic CBOR objects for semantic equality. This
function consumes stack space linear in the maximum nesting of its
two arguments.</dd><dt><a class="fn" href="fn.cbor_det_get_array_item.html" title="fn cborrs::cbordet::cbor_det_get_array_item">cbor_<wbr>det_<wbr>get_<wbr>array_<wbr>item</a></dt><dd>Returns the <code>i</code>th element of the CBOR array <code>x</code>. Returns <code>None</code> if
<code>i</code> is equal to or larger than the number of array elements,
<code>Some(object)</code> otherwise.</dd><dt><a class="fn" href="fn.cbor_det_get_array_length.html" title="fn cborrs::cbordet::cbor_det_get_array_length">cbor_<wbr>det_<wbr>get_<wbr>array_<wbr>length</a></dt><dd>Returns the number of elements in a Deterministic CBOR array.</dd><dt><a class="fn" href="fn.cbor_det_get_map_length.html" title="fn cborrs::cbordet::cbor_det_get_map_length">cbor_<wbr>det_<wbr>get_<wbr>map_<wbr>length</a></dt><dd>Returns the number of elements in a Deterministic CBOR map.</dd><dt><a class="fn" href="fn.cbor_det_map_entry_key.html" title="fn cborrs::cbordet::cbor_det_map_entry_key">cbor_<wbr>det_<wbr>map_<wbr>entry_<wbr>key</a></dt><dd>Read the key of a map entry.</dd><dt><a class="fn" href="fn.cbor_det_map_entry_value.html" title="fn cborrs::cbordet::cbor_det_map_entry_value">cbor_<wbr>det_<wbr>map_<wbr>entry_<wbr>value</a></dt><dd>Read the value of a map entry.</dd><dt><a class="fn" href="fn.cbor_det_map_get.html" title="fn cborrs::cbordet::cbor_det_map_get">cbor_<wbr>det_<wbr>map_<wbr>get</a></dt><dd>Looks up a map <code>x</code> for an entry associated to the key <code>k</code>. If such
an entry exists, returns <code>Some(object)</code> where <code>object</code> is the
value associated to that key. Otherwise, returns <code>None</code>.</dd><dt><a class="fn" href="fn.cbor_det_mk_array.html" title="fn cborrs::cbordet::cbor_det_mk_array">cbor_<wbr>det_<wbr>mk_<wbr>array</a></dt><dd>Constructs a Deterministic CBOR of “array” type. This function
does not copy its input array. It returns <code>None</code> if the input
array has more than $2^64 - 1$ elements, <code>Some(object)</code> otherwise.</dd><dt><a class="fn" href="fn.cbor_det_mk_byte_string.html" title="fn cborrs::cbordet::cbor_det_mk_byte_string">cbor_<wbr>det_<wbr>mk_<wbr>byte_<wbr>string</a></dt><dd>Constructs a Deterministic CBOR object of “byte string” type, with
the contents of <code>s</code> as value. This function does not perform any
copy of its input <code>s</code>. It returns <code>None</code> if the byte size of <code>s</code>
is larger than $2^64 - 1$, <code>Some(object)</code> otherwise.</dd><dt><a class="fn" href="fn.cbor_det_mk_int64.html" title="fn cborrs::cbordet::cbor_det_mk_int64">cbor_<wbr>det_<wbr>mk_<wbr>int64</a></dt><dd>Constructs a Deterministic CBOR object of “integer” type, with
kind <code>ty</code> and value <code>v</code>.</dd><dt><a class="fn" href="fn.cbor_det_mk_map.html" title="fn cborrs::cbordet::cbor_det_mk_map">cbor_<wbr>det_<wbr>mk_<wbr>map</a></dt><dd>Constructs a map from a slice of map entries. This function does
not copy its input array. If the input slice has more than $2^64 -
1$ entries, then this function returns <code>None</code> and does not change
the input slice. Otherwise, this function tries to sort the input
slice in-place with respect to the key order specified in Section
4.2.1 of RFC 8949 (without actually serializing the map entries.)
If the sorting detects duplicate keys, then this function returns
<code>None</code>. Otherwise, it returns <code>Some(object)</code>. Due to the sorting,
this function consumes stack space logarithmic in the size of the
input slice, and linear in the maximum nesting of map entry keys,
and the function may have changed the order of map entries in the
input slice.</dd><dt><a class="fn" href="fn.cbor_det_mk_map_entry.html" title="fn cborrs::cbordet::cbor_det_mk_map_entry">cbor_<wbr>det_<wbr>mk_<wbr>map_<wbr>entry</a></dt><dd>Constructs a map entry from a key <code>xk</code> and a value <code>xv</code>.</dd><dt><a class="fn" href="fn.cbor_det_mk_simple_value.html" title="fn cborrs::cbordet::cbor_det_mk_simple_value">cbor_<wbr>det_<wbr>mk_<wbr>simple_<wbr>value</a></dt><dd>Constructs a Deterministic CBOR object of “simple value” type,
with value <code>v</code>. Returns <code>None</code> if the value <code>v</code> lies in the
reserved range (<code>24..31</code>), as specified by Table 4 of RFC 8949
Section 3.3; <code>Some(object)</code> otherwise.</dd><dt><a class="fn" href="fn.cbor_det_mk_tagged.html" title="fn cborrs::cbordet::cbor_det_mk_tagged">cbor_<wbr>det_<wbr>mk_<wbr>tagged</a></dt><dd>Constructs a Deterministic CBOR object of Tagged type, with tag
<code>tag</code>, and the contents of <code>r</code> as value. This function does not
perform any copy of its input <code>r</code>.</dd><dt><a class="fn" href="fn.cbor_det_mk_text_string.html" title="fn cborrs::cbordet::cbor_det_mk_text_string">cbor_<wbr>det_<wbr>mk_<wbr>text_<wbr>string</a></dt><dd>Constructs a Deterministic CBOR object of “text string” type, with
the contents of <code>s</code> as value. This function does not perform any
copy of its input <code>s</code>. It returns <code>None</code> if the byte size of <code>s</code>
is larger than $2^64 - 1$, <code>Some(object)</code> otherwise. This function
respects the UTF-8 well-formedness invariants.</dd><dt><a class="fn" href="fn.cbor_det_parse.html" title="fn cborrs::cbordet::cbor_det_parse">cbor_<wbr>det_<wbr>parse</a></dt><dd>Tries to parse a Deterministic CBOR object from the first bytes of
<code>input</code>, following RFC 8949 Section 4.2.1, minus floating-point
values. Returns <code>None</code> in case of failure, or <code>Some(object, rem)</code>
in case of success, where <code>rem</code> is the remainder of the input
slice past those first bytes of <code>input</code> that contain the valid
binary representation of
<code>input</code>. This function does not perform a deep parse of <code>input</code>,
it only copies the object type, tag and/or size of the top-most
object. As such, it uses constant stack space (including data
validation.) “Destructor” functions are to be used on the returned
object, to examine each level of nesting one at a time. NOTE: This
implementation checks for the basic validity constraints of
Section 5.3.1, i.e. the absence of duplicate map keys (which is a
consequence of the deterministic encoding.), and the
well-formedness of UTF-8 text strings.</dd><dt><a class="fn" href="fn.cbor_det_serialize.html" title="fn cborrs::cbordet::cbor_det_serialize">cbor_<wbr>det_<wbr>serialize</a></dt><dd>Writes the binary representation of the Deterministic CBOR object
<code>x</code> into the first bytes of the <code>output</code> byte slice, following RFC
8949 Section 4.2.1. This function first checks the size of <code>x</code> and
returns <code>None</code> if it is larger than the size of <code>output</code>;
otherwise it returns <code>Some(size)</code>, where <code>size</code> is the byte size
of <code>x</code>, the number of bytes written to <code>output</code>. This function
uses stack space in the order of the level of nesting of the use
of “constructor” functions used to build <code>x</code>; the serialization of
those “subobjects” of <code>x</code> obtained from <code>cbor_det_parse</code> uses only
constant extra stack space for each such subobject (in the sense
that the serialization does not recursively nest into such
subobjects.)</dd><dt><a class="fn" href="fn.cbor_det_size.html" title="fn cborrs::cbordet::cbor_det_size">cbor_<wbr>det_<wbr>size</a></dt><dd>Computes the byte size of the binary representation of the
Deterministic CBOR object <code>x</code> following RFC 8949 Section 4.2.1,
but without serializing <code>x</code>. Returns <code>None</code> if that size is
strictly larger than <code>bound</code>; <code>Some(size)</code> otherwise. This function
uses stack space in the order of the level of nesting of the use
of “constructor” functions used to build <code>x</code>; the computation of
the sizes of those “subobjects” of <code>x</code> obtained from
<code>cbor_det_parse</code> uses only constant extra stack space for each
such subobject (in the sense that the computation does not
recursively nest into such subobjects.)</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.CborDet.html" title="type cborrs::cbordet::CborDet">CborDet</a></dt><dd>An abstract type to represent a Deterministic CBOR object, which
can be obtained either using “constructor” functions of this
module, or by parsing from serialized data. Declared in
<code>pulse/CBOR.Pulse.Det.API.Rust.fsti</code>. Its corresponding pure
(“mathematical”) functional specification is the <code>cbor</code> type in
<code>spec/CBOR.Spec.Type.fsti</code>.</dd><dt><a class="type" href="type.CborDetMapEntry.html" title="type cborrs::cbordet::CborDetMapEntry">Cbor<wbr>DetMap<wbr>Entry</a></dt><dd>The type of key-value map entries.</dd></dl></section></div></main></body></html>